/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * A structure to represent an annotated commit, the input to merge and rebase.
 *
 * An annotated commit contains information about how it was looked up, which
 * may be useful for functions like merge or rebase to provide context to the
 * operation.
 */
export declare class AnnotatedCommit {
  /**
   * Gets the commit ID that the given Annotated Commit refers to.
   *
   * @category AnnotatedCommit/Methods
   * @signature
   * ```ts
   * class AnnotatedCommit {
   *   id(): string;
   * }
   * ```
   *
   * @returns The commit ID that this Annotated Commit refers to.
   */
  id(): string
  /**
   * Get the refname that the given Annotated Commit refers to.
   *
   * @category AnnotatedCommit/Methods
   * @signature
   * ```ts
   * class AnnotatedCommit {
   *   refname(): string | null;
   * }
   * ```
   *
   * @returns The refname that this Annotated Commit refers to. If this created from a reference,
   * the return value is `null`.
   * @throws Throws error if the refname is not valid utf-8.
   */
  refname(): string | null
}

/** A wrapper around git2::Blame providing Node.js bindings */
export declare class Blame {
  /**
   * Gets the number of hunks in the blame result
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkCount(): number;
   * }
   * ```
   *
   * @returns The number of hunks in the blame result
   */
  getHunkCount(): number
  /**
   * Checks if the blame result is empty
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns True if the blame result contains no hunks
   */
  isEmpty(): boolean
  /**
   * Gets blame information for the specified index
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkByIndex(index: number): BlameHunk;
   * }
   * ```
   *
   * @param {number} index - Index of the hunk to get (0-based)
   * @returns Blame information for the specified index
   * @throws If no hunk is found at the index
   */
  getHunkByIndex(index: number): BlameHunk
  /**
   * Gets blame information for the specified line
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkByLine(line: number): BlameHunk;
   * }
   * ```
   *
   * @param {number} line - Line number to get blame information for (1-based)
   * @returns Blame information for the specified line
   * @throws If no hunk is found for the line
   */
  getHunkByLine(line: number): BlameHunk
  /**
   * Gets all blame hunks as an iterator
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   iter(): Generator<BlameHunk>;
   * }
   * ```
   *
   * @returns Iterator of all blame hunks
   * @example
   * ```ts
   * // Using for...of loop
   * for (const hunk of blame.iter()) {
   *   console.log(hunk.finalCommitId);
   * }
   *
   * // Using spread operator to collect all hunks
   * const hunks = [...blame.iter()];
   * ```
   */
  iter(): BlameHunks
  /**
   * Collects blame hunks by scanning file lines as an iterator
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   iterByLine(): Generator<BlameHunk>;
   * }
   * ```
   *
   * @returns Iterator of blame hunks collected by line scanning
   * @example
   * ```ts
   * // Using for...of loop
   * for (const hunk of blame.iterByLine()) {
   *   console.log(hunk.finalCommitId);
   * }
   *
   * // Using spread operator to collect all hunks
   * const hunks = [...blame.iterByLine()];
   * ```
   */
  iterByLine(): BlameHunksByLine
  /**
   * Generates blame information from an in-memory buffer
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   buffer(buffer: Buffer): Blame;
   * }
   * ```
   *
   * @example
   * ```ts
   * const buffer = Buffer.from('modified content');
   * const bufferBlame = blame.buffer(buffer);
   * ```
   *
   * @param {Buffer} buffer - Buffer containing file content to blame
   * @returns A new Blame object for the buffer content
   */
  buffer(buffer: Buffer): Blame
}

/**
 * An iterator over blame hunks.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class BlameHunks extends Iterator<BlameHunk, void, void> {

  next(value?: void): IteratorResult<BlameHunk, void>
}

/**
 * Iterator over blame hunks collected line by line.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class BlameHunksByLine extends Iterator<BlameHunk, void, void> {

  next(value?: void): IteratorResult<BlameHunk, void>
}

/**
 * A class to represent a git [blob][1].
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Blob {
  /**
   * Get the id (SHA1) of a repository blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository blob.
   */
  id(): string
  /**
   * Determine if the blob content is most certainly binary or not.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   isBinary(): boolean;
   * }
   * ```
   *
   * @returns `true` if blob content is binary.
   */
  isBinary(): boolean
  /**
   * Get the content of this blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   content(): Uint8Array;
   * }
   * ```
   *
   * @returns Content of this blob.
   */
  content(): Uint8Array
  /**
   * Get the size in bytes of the contents of this blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   size(): bigint;
   * }
   * ```
   *
   * @returns Size in bytes of the contents of this blob.
   */
  size(): bigint
}

/**
 * A structure to represent a git [branch][1]
 *
 * A branch is currently just a wrapper to an underlying `Reference`. The
 * reference can be accessed through the `get` and `into_reference` methods.
 *
 * [1]: http://git-scm.com/book/en/Git-Branching-What-a-Branch-Is
 */
export declare class Branch {
  /**
   * Get the OID pointed to by a reference which is this branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   referenceTarget(): string | null;
   * }
   * ```
   *
   * @returns The OID pointed to by a reference which is this branch.
   */
  referenceTarget(): string | null
  /**
   * Delete an existing branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   delete(): void;
   * }
   * ```
   */
  delete(): void
  /**
   * Determine if the current local branch is pointed at by `HEAD`.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   isHead(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the current local branch is pointed at by `HEAD`.
   */
  isHead(): boolean
  /**
   * Move/rename an existing local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   rename(newBranchName: string, options?: BranchRenameOptions | null | undefined): Branch;
   * }
   * ```
   *
   * @param {string} newBranchName - Branch name to move/rename.
   * @param {BranchRenameOptions} [options] - Options for move/rename branch.
   * @returns Move/renamed branch.
   */
  rename(newBranchName: string, options?: BranchRenameOptions | undefined | null): Branch
  /**
   * Return the name of the given local or remote branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   name(): string;
   * }
   * ```
   *
   * @returns The name of the given local or remote branch.
   * @throws If the name is not valid utf-8.
   */
  name(): string
  /**
   * Return the reference supporting the remote tracking branch, given a
   * local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   findUpstream(): Branch | null;
   * }
   * ```
   *
   * @returns The reference supporting the remote tacking branch.
   */
  findUpstream(): Branch | null
  /**
   * Return the reference supporting the remote tracking branch, given a
   * local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   getUpstream(): Branch;
   * }
   * ```
   *
   * @returns The reference supporting the remote tacking branch.
   * @throws Throws error if upstream does not exist.
   */
  getUpstream(): Branch
  /**
   * Set the upstream configuration for a given local branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   setUpstream(upstreamName: string): void;
   * }
   * ```
   *
   * @param {string} upstreamName - Branch name to set as upstream.
   */
  setUpstream(upstreamName: string): void
  /**
   * Unset the upstream configuration for a given local branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   unsetUpstream(): void;
   * }
   * ```
   */
  unsetUpstream(): void
}

/**
 * An iterator over the branches inside of a repository.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class Branches extends Iterator<BranchesItem, void, void> {

  next(value?: void): IteratorResult<BranchesItem, void>
}

/** A class to represent a git commit. */
export declare class Commit {
  /**
   * Get the id (SHA1) of a repository commit
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository commit.
   */
  id(): string
  /**
   * Get the author of this commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   author(): Signature;
   * }
   * ```
   *
   * @returns Author signature of this commit.
   */
  author(): Signature
  /**
   * Get the committer of this commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   committer(): Signature;
   * }
   * ```
   *
   * @returns Committer signature of this commit.
   */
  committer(): Signature
  /**
   * Get the full message of a commit.
   *
   * The returned message will be slightly prettified by removing any
   * potential leading newlines.
   *
   * Throws error if the message is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   message(): string;
   * }
   * ```
   *
   * @returns Full message of this commit.
   * @throws If the message is not valid utf-8.
   */
  message(): string
  /**
   * Get the short "summary" of the git commit message.
   *
   * The returned message is the summary of the commit, comprising the first
   * paragraph of the message with whitespace trimmed and squashed.
   *
   * Throws error if the summary is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   summary(): string | null;
   * }
   * ```
   *
   * @returns Short summary of this commit message.
   * @throws If the summary is not valid utf-8.
   */
  summary(): string | null
  /**
   * Get the long "body" of the git commit message.
   *
   * The returned message is the body of the commit, comprising everything
   * but the first paragraph of the message. Leading and trailing whitespaces
   * are trimmed.
   *
   * Throws error if the summary is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   body(): string | null;
   * }
   * ```
   *
   * @returns Long body of this commit message.
   * @throws If the body is not valid utf-8.
   */
  body(): string | null
  /**
   * Get the commit time (i.e. committer time) of a commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   time(): Date;
   * }
   * ```
   *
   * @returns Commit time of a commit.
   */
  time(): Date
  /**
   * Get the id of the tree pointed to by this commit.
   *
   * No attempts are made to fetch an object from the ODB.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   treeId(): string;
   * }
   * ```
   *
   * @returns Get the id of the tree pointed to by a commit.
   */
  treeId(): string
  /**
   * Get the tree pointed to by a commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   tree(): Tree;
   * }
   * ```
   *
   * @returns Tree pointed to by a commit.
   */
  tree(): Tree
  /**
   * Casts this Commit to be usable as an `GitObject`.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   asObject(): GitObject;
   * }
   * ```
   *
   * @returns `GitObject` that casted from this commit.
   */
  asObject(): GitObject
  /**
   * Amend this existing commit with all non-nullable values
   *
   * This creates a new commit that is exactly the same as the old commit,
   * except that any non-nullable values will be updated. The new commit has
   * the same parents as the old commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   amend(options?: AmendOptions, tree?: Tree): string;
   * }
   * ```
   *
   * @param {AmendOptions} [options] - Options for amending commit.
   * @param {Tree} [tree] - Tree to use for amending commit.
   * @returns ID(SHA1) of amended commit.
   */
  amend(options?: AmendOptions | undefined | null, tree?: Tree | undefined | null): string
  /**
   * Get the author of this commit, using the mailmap to map it to the canonical name and email.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   authorWithMailmap(mailmap: Mailmap): Signature;
   * }
   * ```
   *
   * @param {Mailmap} mailmap - The mailmap to use for mapping
   * @returns Author signature of this commit with mapping applied
   * @throws An error if the operation failed.
   */
  authorWithMailmap(mailmap: Mailmap): Signature
  /**
   * Get the committer of this commit, using the mailmap to map it to the canonical name and email.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   committerWithMailmap(mailmap: Mailmap): Signature;
   * }
   * ```
   *
   * @param {Mailmap} mailmap - The mailmap to use for mapping
   * @returns Committer signature of this commit with mapping applied
   * @throws An error if the operation failed.
   */
  committerWithMailmap(mailmap: Mailmap): Signature
}

export declare class Config {
  /**
   * Delete a config variable from the config file with the highest level
   * (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   remove(name: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   */
  remove(name: string): void
  /**
   * Remove multivar config variables in the config file with the highest level (usually the
   * local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   removeMultivar(name: string, regexp: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} regexp - The regular expression is applied case-sensitively on the value.
   */
  removeMultivar(name: string, regexp: string): void
  /**
   * Get the value of a boolean config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getBool(name: string): boolean;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a boolean config variable.
   */
  getBool(name: string): boolean
  /**
   * Find the value of a boolean config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findBool(name: string): boolean | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a boolean config variable.
   */
  findBool(name: string): boolean | null
  /**
   * Get the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getI32(name: string): number;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  getI32(name: string): number
  /**
   * Find the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findI32(name: string): number | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  findI32(name: string): number | null
  /**
   * Get the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getI64(name: string): number;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  getI64(name: string): number
  /**
   * Find the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findI64(name: string): number | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  findI64(name: string): number | null
  /**
   * Get the value of a string config variable as a byte slice.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getBytes(name: string): Uint8Array;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable as a byte slice.
   */
  getBytes(name: string): Uint8Array
  /**
   * Find the value of a string config variable as a byte slice.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findBytes(name: string): Uint8Array | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable as a byte slice.
   */
  findBytes(name: string): Uint8Array | null
  /**
   * Get the value of a string config variable as an owned string.
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getString(name: string): string;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable.
   * @throws An error will be returned if the config value is not valid utf-8.
   */
  getString(name: string): string
  /**
   * Find the value of a string config variable as an owned string.
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findString(name: string): string | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable.
   */
  findString(name: string): string | null
  /**
   * Get the value of a path config variable.
   *
   * A leading '~' will be expanded to the global search path (which
   * defaults to the user's home directory but can be overridden via
   * [`git_libgit2_opts`][1].
   *
   * [1]: https://libgit2.org/docs/reference/v1.9.0/common/git_libgit2_opts.html
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getPath(name: string): string;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a path config variable.
   */
  getPath(name: string): string
  /**
   * Get the entry for a config variable.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getEntry(name: string): ConfigEntry;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns `ConfigEntry` object representing a certain entry owned by a `Config` instance.
   */
  getEntry(name: string): ConfigEntry
  /**
   * Find the entry for a config variable.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findEntry(name: string): ConfigEntry | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns `ConfigEntry` object representing a certain entry owned by a `Config` instance.
   */
  findEntry(name: string): ConfigEntry | null
  /**
   * Iterate over all the config variables.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   entries(glob?: string): ConfigEntries;
   * }
   * ```
   *
   * @param {string} [glob] - If `glob` is provided, then the iterator will only iterate over all
   * variables whose name matches the pattern.
   * The regular expression is applied case-sensitively on the normalized form of
   * the variable name: the section and variable parts are lower-cased. The
   * subsection is left unchanged.
   *
   * @returns An iterator over the `ConfigEntry` values of a config.
   * @example
   *
   * ```ts
   * import { openDefaultConfig } from 'es-git';
   *
   * const config = openDefaultConfig();
   * for (const entry of config.entries()) {
   *   console.log(entry.name, entry.value);
   * }
   * ```
   */
  entries(glob?: string | undefined | null): ConfigEntries
  /**
   * Iterate over the values of a multivar.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   multivar(name: string, regexp?: string): ConfigEntries;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} [regexp] - If `regexp` is provided, then the iterator will only iterate over all
   * values which match the pattern.
   * The regular expression is applied case-sensitively on the normalized form of
   * the variable name: the section and variable parts are lower-cased. The
   * subsection is left unchanged.
   *
   * @returns An iterator over the `ConfigEntry` values of a config.
   */
  multivar(name: string, regexp?: string | undefined | null): ConfigEntries
  /**
   * Set the value of a boolean config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setBool(name: string, value: boolean): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {boolean} value - The value of config entry.
   */
  setBool(name: string, value: boolean): void
  /**
   * Set the value of an integer config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setI32(name: string, value: number): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {number} value - The value of config entry.
   */
  setI32(name: string, value: number): void
  /**
   * Set the value of an integer config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setI64(name: string, value: number): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {number} value - The value of config entry.
   */
  setI64(name: string, value: number): void
  /**
   * Set the value of an multivar config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setMultivar(name: string, regexp: string, value: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} regexp - The regular expression is applied case-sensitively on the value.
   * @param {string} value - The value of config entry.
   */
  setMultivar(name: string, regexp: string, value: string): void
  /**
   * Set the value of a string config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setString(name: string, value: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} value - The value of config entry.
   */
  setString(name: string, value: string): void
}

/**
 * An iterator over the `ConfigEntry` values of a config.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class ConfigEntries extends Iterator<ConfigEntry, void, void> {

  next(value?: void): IteratorResult<ConfigEntry, void>
}

/**
 * An iterator over the diffs in a delta.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class Deltas extends Iterator<DiffDelta, void, void> {

  next(value?: void): IteratorResult<DiffDelta, void>
}

/**
 * The result of a `describe` operation on either an `Describe` or a
 * `Repository`.
 */
export declare class Describe {
  /**
   * Prints this describe result, returning the result as a string.
   *
   * @category Describe/Methods
   * @signature
   * ```ts
   * class Describe {
   *   format(options?: DescribeFormatOptions | null | undefined): string;
   * }
   * ```
   *
   * @param {DescribeFormatOptions} [options] - Options for formatting describe.
   * @returns Formatted string for this describe.
   */
  format(options?: DescribeFormatOptions | undefined | null): string
}

/**
 * The diff object that contains all individual file deltas.
 *
 * This is an opaque structure which will be allocated by one of the diff
 * generator functions on the `Repository` class (e.g. `diffTreeToTree`
 * or other `diff*` functions).
 */
export declare class Diff {
  /**
   * Merge one diff into another.
   *
   * This merges items from the "from" list into the "self" list.  The
   * resulting diff will have all items that appear in either list.
   * If an item appears in both lists, then it will be "merged" to appear
   * as if the old version was from the "onto" list and the new version
   * is from the "from" list (with the exception that if the item has a
   * pending DELETE in the middle, then it will show as deleted).
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   merge(diff: Diff): void;
   * }
   * ```
   *
   * @param {Diff} diff - Another diff to merge.
   */
  merge(diff: Diff): void
  /**
   * Returns an iterator over the deltas in this diff.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   deltas(): Deltas;
   * }
   * ```
   *
   * @returns An iterator over the deltas in this diff.
   */
  deltas(): Deltas
  /**
   * Check if deltas are sorted case sensitively or insensitively.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   isSortedIcase(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if deltas are sorted case insensitively.
   */
  isSortedIcase(): boolean
  /**
   * Accumulate diff statistics for all patches.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   stats(): DiffStats;
   * }
   * ```
   *
   * @returns Diff statistics for all patches.
   */
  stats(): DiffStats
  /**
   * Iterate over a diff generating formatted text output.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   print(options?: DiffPrintOptions | null | undefined): string;
   * }
   * ```
   *
   * @param {DiffPrintOptions} [options] - Print options for diff.
   * @returns Formatted text output.
   */
  print(options?: DiffPrintOptions | undefined | null): string
  /**
   * Transform a diff marking file renames, copies, etc.
   *
   * This modifies a diff in place, replacing old entries that look like
   * renames or copies with new entries reflecting those changes. This also
   * will, if requested, break modified files into add/remove pairs if the
   * amount of change is above a threshold.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   findSimilar(options?: DiffFindOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {DiffFindOptions} [options] - Options for finding diff.
   */
  findSimilar(options?: DiffFindOptions | undefined | null): void
}

/** Description of changes to one entry. */
export declare class DiffDelta {
  /**
   * Returns the flags on the delta.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   flags(): number;
   * }
   * ```
   *
   * @returns The flags on the delta.
   *
   * @example
   * ```ts
   * import { DiffDelta, DiffFlags, diffFlagsContains } from 'es-git';
   *
   * const delta: DiffDelta;
   * console.assert(diffFlagsContains(delta.flags(), DiffFlags.Binary | DiffFlags.ValidId));
   * ```
   */
  flags(): number
  /**
   * Returns the number of files in this delta.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   numFiles(): number;
   * }
   * ```
   *
   * @returns The number of files in this delta.
   */
  numFiles(): number
  /**
   * Returns the status of this entry.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   status(): DeltaType;
   * }
   * ```
   *
   * @returns The status of this entry.
   */
  status(): DeltaType
  /**
   * Return the file which represents the "from" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   oldFile(): DiffFile;
   * }
   * ```
   *
   * @returns The file which represents the "from" side of the diff.
   */
  oldFile(): DiffFile
  /**
   * Return the file which represents the "to" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   newFile(): DiffFile;
   * }
   * ```
   *
   * @returns The file which represents the "to" side of the diff.
   */
  newFile(): DiffFile
}

/**
 * Description of one side of a delta.
 *
 * Although this is called a "file" it could represent a file, a symbolic
 * link, a submodule commit id, or even a tree (although that only happens if
 * you are tracking type changes or ignored/untracked directories).
 */
export declare class DiffFile {
  /**
   * Returns the Oid of this item.
   *
   * If this entry represents an absent side of a diff (e.g. the `oldFile`
   * of a `Added` delta), then the oid returned will be zeroes.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   id(): string;
   * }
   * ```
   *
   * @returns The Oid of this item.
   */
  id(): string
  /**
   * Returns the path of the entry relative to the working directory of the
   * repository.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   path(): string | null;
   * }
   * ```
   *
   * @returns Ths path of the entry relative to the working directory of the repository.
   */
  path(): string | null
  /**
   * Returns the size of this entry, in bytes.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   size(): bigint;
   * }
   * ```
   *
   * @returns The size of this entry, in bytes.
   */
  size(): bigint
  /**
   * Returns `true` if file(s) are treated as binary data.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   isBinary(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if file(s) are treated as binary data.
   */
  isBinary(): boolean
  /**
   * Returns `true` if `id` value is known correct.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   isValidId(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if `id` value is known correct.
   */
  isValidId(): boolean
  /**
   * Returns `true` if file exists at this side of the delta.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   exists(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if file exists at this side of the delta.
   */
  exists(): boolean
  /**
   * Returns file mode.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   mode(): FileMode;
   * }
   * ```
   *
   * @returns
   */
  mode(): FileMode
}

/** A class describing a hunk of a diff. */
export declare class DiffStats {
  /**
   * Get the total number of files changed in a diff.
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get filesChanged(): bigint;
   * }
   * ```
   *
   * @returns Total number of files changed in a diff.
   */
  get filesChanged(): bigint
  /**
   * Get the total number of insertions in a diff
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get insertions(): bigint;
   * }
   * ```
   *
   * @returns Total number of insertions in a diff.
   */
  get insertions(): bigint
  /**
   * Get the total number of deletions in a diff
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get deletions(): bigint;
   * }
   * ```
   *
   * @returns Total number of deletions in a diff.
   */
  get deletions(): bigint
}

/**
 * A class to represent a git [object][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class GitObject {
  /**
   * Describes a commit
   *
   * Performs a describe operation on this commitish object.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class Object {
   *   describe(options?: DescribeOptions | null | undefined): Describe;
   * }
   * ```
   *
   * @param {DescribeOptions} [options] - Options for describe operation.
   * @returns Instance of describe.
   */
  describe(options?: DescribeOptions | undefined | null): Describe
  /**
   * Get the id (SHA1) of a repository object.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository object.
   */
  id(): string
  /**
   * Get the object type of object.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   type(): ObjectType | null;
   * }
   * ```
   *
   * @returns If the type is unknown, then `null` is returned.
   */
  type(): ObjectType | null
  /**
   * Recursively peel an object until an object of the specified type is met.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peel(objType: ObjectType): GitObject;
   * }
   * ```
   *
   * @param {ObjectType} objType - If you pass `Any` as the target type, then the object will be
   * peeled until the type changes (e.g. a tag will be chased until the
   * referenced object is no longer a tag).
   *
   * @returns Git object which recursively peeled.
   */
  peel(objType: ObjectType): GitObject
  /**
   * Recursively peel an object until a commit is found.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peelToCommit(): Commit;
   * }
   * ```
   *
   * @returns Git commit.
   */
  peelToCommit(): Commit
  /**
   * Recursively peel an object until a blob is found.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peelToBlob(): Blob;
   * }
   * ```
   *
   * @returns Git blob.
   */
  peelToBlob(): Blob
  /**
   * Attempt to view this object as a commit.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   asCommit(): Commit | null;
   * }
   * ```
   *
   * @returns Returns `null` if the object is not actually a commit.
   */
  asCommit(): Commit | null
}

/**
 * A class to represent a git [index][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Index {
  /**
   * Get index on-disk version.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   version(): number;
   * }
   * ```
   *
   * @returns Index on-disk version.
   * Valid return values are 2, 3, or 4. If 3 is returned, an index
   * with version 2 may be written instead, if the extension data in
   * version 3 is not necessary.
   */
  version(): number
  /**
   * Set index on-disk version.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   setVersion(version: number): void;
   * }
   * ```
   *
   * @param {string} version - Version to set.
   * Valid values are 2, 3, or 4. If 2 is given, git_index_write may
   * write an index with version 3 instead, if necessary to accurately
   * represent the index.
   */
  setVersion(version: number): void
  /**
   * Get one of the entries in the index by its path.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   getByPath(path: string, stage?: IndexStage | null | undefined): IndexEntry | null;
   * }
   * ```
   *
   * @param {string} path - Path to lookup entry.
   * @param {IndexStage} [stage] - Git index stage states.
   * @returns Index entry for the path.
   */
  getByPath(path: string, stage?: IndexStage | undefined | null): IndexEntry | null
  /**
   * Add or update an index entry from a file on disk.
   *
   * This forces the file to be added to the index, not looking at gitignore
   * rules.
   *
   * If this file currently is the result of a merge conflict, this file will
   * no longer be marked as conflicting. The data about the conflict will be
   * moved to the "resolve undo" (REUC) section.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   addPath(path: string): void;
   * }
   * ```
   *
   * @param {string} path - Relative file path to the repository's working directory and must be
   * readable.
   *
   * @throws This method will fail in bare index instances.
   */
  addPath(path: string): void
  /**
   * Add or update index entries matching files in the working directory.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   addAll(pathspecs: string[], options?: IndexAddAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory. Each file that matches will be added
   * to the index (either updating an existing entry or adding a new entry).
   * @param {IndexAddAllOptions} [options] - Options for add or update index entries.
   *
   * @throws This method will fail in bare index instances.
   *
   * @example
   *
   * Emulate `git add *`:
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const index = repo.index();
   * index.addAll(['*']);
   * index.write();
   * ```
   */
  addAll(pathspecs: Array<string>, options?: IndexAddAllOptions | undefined | null): void
  /**
   * Update the contents of an existing index object in memory by reading
   * from the hard disk.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   read(force?: boolean | null | undefined): void;
   * }
   * ```
   *
   * @param {boolean} [force] - If force is `true`, this performs a "hard" read that discards
   * in-memory changes and always reloads the on-disk index data. If there is no on-disk version,
   * the index will be cleared.
   *
   * If force is `false`, this does a "soft" read that reloads the index data
   * from disk only if it has changed since the last time it was loaded.
   * Purely in-memory index data will be untouched. Be aware: if there are
   * changes on disk, unwritten in-memory changes are discarded.
   */
  read(force?: boolean | undefined | null): void
  /**
   * Write an existing index object from memory back to disk using an atomic
   * file lock.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   write(): void;
   * }
   * ```
   */
  write(): void
  /**
   * Write the index as a tree.
   *
   * This method will scan the index and write a representation of its
   * current state back to disk; it recursively creates tree objects for each
   * of the subtrees stored in the index, but only returns the OID of the
   * root tree. This is the OID that can be used e.g. to create a commit.
   *
   * The index instance cannot be bare, and needs to be associated to an
   * existing repository.
   *
   * The index must not contain any file in conflict.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   writeTree(): string;
   * }
   * ```
   */
  writeTree(): string
  /**
   * Remove an index entry corresponding to a file on disk.
   *
   * If this file currently is the result of a merge conflict, this file will
   * no longer be marked as conflicting. The data about the conflict will be
   * moved to the "resolve undo" (REUC) section.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   removePath(path: string, options?: IndexRemoveOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string} path - Relative file path to the repository's working directory.
   * @param {IndexRemoveOptions} options - Options for remove an index entry.
   */
  removePath(path: string, options?: IndexRemoveOptions | undefined | null): void
  /**
   * Remove all matching index entries.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   removeAll(pathspecs: string[], options?: IndexRemoveAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory
   * @param {IndexRemoveAllOptions} options - Options for remove all matching index entry.
   */
  removeAll(pathspecs: Array<string>, options?: IndexRemoveAllOptions | undefined | null): void
  /**
   * Update all index entries to match the working directory.
   *
   * This scans the existing index entries and synchronizes them with the
   * working directory, deleting them if the corresponding working directory
   * file no longer exists otherwise updating the information (including
   * adding the latest version of file to the ODB if needed).
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   updateAll(pathspecs: string[], options?: IndexUpdateAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory
   * @param {IndexUpdateAllOptions} options - Options for update all matching index entry.
   *
   * @throws This method will fail in bare index instances.
   */
  updateAll(pathspecs: Array<string>, options?: IndexUpdateAllOptions | undefined | null): void
  /**
   * Get the count of entries currently in the index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   count(): number;
   * }
   * ```
   *
   * @returns The count of entries currently in the index.
   */
  count(): number
  /**
   * Return `true` is there is no entry in the index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` is there is no entry in the index.
   */
  isEmpty(): boolean
  /**
   * Get the full path to the index file on disk.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   path(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if this is an in-memory index.
   */
  path(): string | null
  /**
   * Does this index have conflicts?
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   hasConflicts(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the index contains conflicts, `false` if it does not.
   */
  hasConflicts(): boolean
  /**
   * Get an iterator over the entries in this index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   entries(): IndexEntries;
   * }
   * ```
   *
   * @returns An iterator over the entries in this index.
   */
  entries(): IndexEntries
}

/**
 * An iterator over the entries in an index.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class IndexEntries extends Iterator<IndexEntry, void, void> {

  next(value?: void): IteratorResult<IndexEntry, void>
}

/** A wrapper around git2::Mailmap providing Node.js bindings */
export declare class Mailmap {
  /**
   * Add a new Mailmap entry.
   *
   * Maps an author/committer (specified by `replace_name` and `replace_email`)
   * to the specified real name and email. The `replace_email` is required but
   * the other parameters can be null.
   *
   * If both `replace_name` and `replace_email` are provided, then the entry will
   * apply to those who match both. If only `replace_name` is provided,
   * it will apply to anyone with that name, regardless of email. If only
   * `replace_email` is provided, it will apply to anyone with that email,
   * regardless of name.
   *
   * @param {AddMailmapEntryData} entry - The mailmap entry data.
   * @returns {void}
   * @throws An error if the operation failed.
   *
   * @category Mailmap/Methods
   *
   * @signature
   * ```ts
   * class Mailmap {
   *   addEntry(entry: AddMailmapEntryData): void;
   * }
   * ```
   */
  addEntry(entry: AddMailmapEntryData): void
  /**
   * Resolve a signature to its canonical form using a mailmap.
   *
   * Returns a new signature with the canonical name and email.
   *
   * @param {SignaturePayload} signature - Signature to resolve
   * @returns The resolved signature with canonical name and email
   * @throws An error if the operation failed.
   *
   * @category Mailmap/Methods
   *
   * @signature
   * ```ts
   * class Mailmap {
   *   resolveSignature(signature: SignaturePayload): Signature;
   * }
   * ```
   */
  resolveSignature(signature: SignaturePayload): Signature
}

/**
 * A structure representing a [note][1] in git.
 *
 * [1]: http://alblue.bandlem.com/2011/11/git-tip-of-week-git-notes.html
 */
export declare class Note {
  /**
   * Get the note object's id
   *
   * @category Note/Methods
   * @signature
   * ```ts
   * class Note {
   *   id(): string;
   * }
   * ```
   *
   * @returns The note object's id.
   */
  id(): string
  /**
   * Get the note author
   *
   * @category Note/Methods
   * @signature
   * ```ts
   * class Note {
   *   author(): Signature;
   * }
   * ```
   *
   * @returns The note author signature.
   */
  author(): Signature
  /**
   * Get the note committer
   *
   * @category Note/Methods
   * @signature
   * ```ts
   * class Note {
   *   committer(): Signature;
   * }
   * ```
   *
   * @returns The note committer signature.
   */
  committer(): Signature
  /**
   * Get the note message as a string.
   *
   * @category Note/Methods
   * @signature
   * ```ts
   * class Note {
   *   message(): string;
   * }
   * ```
   *
   * @returns The note message as a string
   * @throws Throws error if message is not utf-8.
   */
  message(): string
}

/**
 * An iterator over all of the notes within a repository.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class Notes extends Iterator<NoteIterItem, void, void> {

  next(value?: void): IteratorResult<NoteIterItem, void>
}

/**
 * Representation of a rebase
 * Begin the rebase by iterating the returned `Rebase`
 * (e.g., `for (const op of rebase) { ... }` or calling `next()`).
 */
export declare class Rebase {
  /**
   * Gets the count of rebase operations that are to be applied.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   len(): number;
   * }
   * ```
   *
   * @returns The count of rebase operations.
   */
  len(): bigint
  /**
   * Gets the original `HEAD` ref name for merge rebases.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   originHeadName(): string | null;
   * }
   * ```
   *
   * @returns The original `HEAD` ref name for merge rebases.
   */
  originHeadName(): string | null
  /**
   * Gets the original `HEAD` id for merge rebases.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   originHeadId(): string | null;
   * }
   * ```
   *
   * @returns The original `HEAD` id for merge rebases.
   */
  originHeadId(): string | null
  /**
   * Gets the index produced by the last operation, which is the result of
   * `next()` and which will be committed by the next invocation of
   * `commit()`. This is useful for resolving conflicts in an in-memory
   * rebase before committing them.
   *
   * This is only applicable for in-memory rebases; for rebases within a
   * working directory, the changes were applied to the repository's index.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   inmemoryIndex(): Index;
   * }
   * ```
   *
   * @returns The index produced by the last operation.
   */
  inmemoryIndex(): Index
  /**
   * Commits the current patch.  You must have resolved any conflicts that
   * were introduced during the patch application from the rebase next
   * invocation.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   commit(options: RebaseCommitOptions): string;
   * }
   * ```
   *
   * @param {RebaseCommitOptions} options - Options for committing the patch.
   * @returns The commit ID of the commit that was created.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const rebase = repo.rebase(...);
   * const sig = { name: 'Seokju Na', email: 'seokju.me@toss.im' };
   * for (const op of rebase) {
   *   rebase.commit({ committer: sig });
   * }
   * ```
   */
  commit(options: RebaseCommitOptions): string
  /**
   * Aborts a rebase that is currently in progress, resetting the repository
   * and working directory to their state before rebase began.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   abort(): void;
   * }
   * ```
   */
  abort(): void
  /**
   * Finishes a rebase that is currently in progress once all patches have
   * been applied.
   *
   * @category Rebase/Methods
   * @signature
   * ```ts
   * class Rebase {
   *   finish(signature?: SignaturePayload | undefined | null): void;
   * }
   * ```
   *
   * @params {SignaturePayload | undefined | null} [signature] - The identity that is finishing the rebase
   */
  finish(signature?: SignaturePayload | undefined | null): void
  next(): RebaseOperation | null
}

/**
 * A class to represent a git [reference][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-References
 */
export declare class Reference {
  /**
   * Delete an existing reference.
   *
   * This method works for both direct and symbolic references. The reference
   * will be immediately removed on disk.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   delete(): void;
   * }
   * ```
   *
   * @throws This method will throws an error if the reference has changed from the
   * time it was looked up.
   */
  delete(): void
  /**
   * Check if a reference is a local branch.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isBranch(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a local branch.
   */
  isBranch(): boolean
  /**
   * Check if a reference is a note.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isNote(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a note.
   */
  isNote(): boolean
  /**
   * Check if a reference is a remote tracking branch.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isRemote(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a remote tracking branch.
   */
  isRemote(): boolean
  /**
   * Check if a reference is a tag.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isTag(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a tag.
   */
  isTag(): boolean
  /**
   * Get the reference type of a reference.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   type(): ReferenceType | null;
   * }
   * ```
   *
   * @returns Returns `null` if the type is unknown.
   */
  type(): ReferenceType | null
  /**
   * Get the full name of a reference.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   name(): string;
   * }
   * ```
   *
   * @returns Full name of a reference.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string
  /**
   * Get the full shorthand of a reference.
   *
   * This will transform the reference name into a name "human-readable"
   * version. If no shortname is appropriate, it will return the full name.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   shorthand(): string;
   * }
   * ```
   *
   * @returns Full shorthand of a reference.
   * @throws Throws error if the shorthand is not valid utf-8.
   */
  shorthand(): string
  /**
   * Get the OID pointed to by a direct reference.
   *
   * Only available if the reference is direct (i.e. an object id reference,
   * not a symbolic one).
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   target(): string | null;
   * }
   * ```
   *
   * @returns OID pointed to by a direct reference.
   */
  target(): string | null
  /**
   * Return the peeled OID target of this reference.
   *
   * This peeled OID only applies to direct references that point to a hard.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   targetPeel(): string | null;
   * }
   * ```
   *
   * @returns Peeled OID of this reference.
   */
  targetPeel(): string | null
  /**
   * Peel a reference to a tree.
   *
   * This method recursively peels the reference until it reaches
   * a tree.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   peelToTree(): Tree;
   * }
   * ```
   *
   * @returns Peeled `Tree` of this reference.
   */
  peelToTree(): Tree
  /**
   * Get full name to the reference pointed to by a symbolic reference.
   *
   * Only available if the reference is symbolic.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   symbolicTarget(): string | null;
   * }
   * ```
   *
   * @returns Full name of the reference pointed to by a symbolic reference.
   */
  symbolicTarget(): string | null
  /**
   * Resolve a symbolic reference to a direct reference.
   *
   * This method iteratively peels a symbolic reference until it resolves to
   * a direct reference to an OID.
   *
   * If a direct reference is passed as an argument, a copy of that
   * reference is returned.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   resolve(): Reference;
   * }
   * ```
   *
   * @returns Resolved reference.
   */
  resolve(): Reference
  /**
   * Rename an existing reference.
   *
   * This method works for both direct and symbolic references.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   rename(newName: string, options?: RenameReferenceOptions | null | undefined): Reference;
   * }
   * ```
   *
   * @param {string} newName - Name to rename an existing reference.
   * @param {RenameReferenceOptions} [options] - Options to rename an existing reference.
   * @returns Renamed reference.
   */
  rename(newName: string, options?: RenameReferenceOptions | undefined | null): Reference
}

/**
 * A class representing a [remote][1] of a git repository.
 *
 * [1]: https://git-scm.com/book/en/Git-Basics-Working-with-Remotes
 */
export declare class Remote {
  /**
   * Get the remote's name.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   name(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if this remote has not yet been named.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string | null
  /**
   * Get the remote's URL.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   url(): string;
   * }
   * ```
   *
   * @throws Throws error if the URL is not valid utf-8.
   */
  url(): string
  /**
   * Get the remote's URL.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   pushurl(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if push url not exists.
   * @throws Throws error if the URL is not valid utf-8.
   */
  pushurl(): string | null
  /**
   * List all refspecs.
   *
   * Filter refspec if has not valid `src` or `dst` with utf-8.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   refspecs(): Refspec[];
   * }
   * ```
   *
   * @returns List all refspecs.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Retrieving the Refspecs configured for this remote
   * const refspecs = remote.refspecs();
   * console.log(refspecs[0]);
   * // For the "+refs/heads/*:refs/remotes/origin/*" Refspec
   * // {
   * //   "direction": "Fetch",
   * //   "src": "refs/heads/*",
   * //   "dst": "refs/remotes/origin/*",
   * //   "force": true
   * // }
   * ```
   */
  refspecs(): Array<Refspec>
  /**
   * Download new data and update tips.
   *
   * Convenience function to connect to a remote, download the data, disconnect and update the remote-tracking branches.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   fetch(
   *     refspecs: string[],
   *     options?: FetchRemoteOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {string[]} refspecs - Refspecs to fetch from remote.
   * @param {FetchRemoteOptions} [options] - Options for fetch remote.
   * @param {AbortSignal} [signal] Abort signal.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Fetching data from the "main" branch
   * await remote.fetch(['main']);
   *
   * // Providing an empty array fetches data using the default Refspec configured for the remote
   * await remote.fetch([]);
   * ```
   */
  fetch(refspecs: Array<string>, options?: FetchRemoteOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Perform a push.
   *
   * Perform all the steps for a push.
   * If no refspecs are passed, then the configured refspecs will be used.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   push(
   *     refspecs: string[],
   *     options?: PushOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {string[]} refspecs - Refspecs to push to remote.
   * @param {FetchRemoteOptions} [options] - Options for push remote.
   * @param {AbortSignal} [signal] Abort signal.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Push the local "main" branch to the remote "other" branch
   * await remote.push(['refs/heads/main:refs/heads/other']);
   *
   * // Push with credential.
   * await remote.push(['refs/heads/main:refs/heads/other'], {
   *   credential: {
   *     type: 'Plain',
   *     password: '<personal access token>',
   *   },
   * });
   * ```
   */
  push(refspecs: Array<string>, options?: PushOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Prune tracking refs that are no longer present on remote.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   prune(options?: PruneOptions | null | undefined, signal?: AbortSignal | null | undefined): Promise<void>;
   * }
   * ```
   *
   * @param {PruneOptions} [options] - Options for prune remote.
   * @param {AbortSignal} [signal] Abort signal.
   */
  prune(options?: PruneOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Get the remotes default branch.
   *
   * The `fetch` operation from the remote is also performed.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   defaultBranch(signal?: AbortSignal | null | undefined): Promise<string>;
   * }
   * ```
   *
   * @param {AbortSignal} [signal] Abort signal.
   * @returns Default branch name.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * const branch = await remote.defaultBranch();
   * console.log(branch); // "refs/heads/main"
   * ```
   */
  defaultBranch(signal?: AbortSignal | undefined | null): Promise<string>
}

/**
 * An owned git repository, representing all state associated with the
 * underlying filesystem.
 *
 * This class corresponds to a git repository in libgit2.
 */
export declare class Repository {
  /**
   * Creates an Annotated Commit from the given commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommit(commit: Commit): AnnotatedCommit;
   * }
   * ```
   *
   * @param {Commit} commit - Commit to creates a Annotated Commit.
   * @returns An Annotated Commit created from commit.
   */
  getAnnotatedCommit(commit: Commit): AnnotatedCommit
  /**
   * Creates a Annotated Commit from the given reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommitFromReference(reference: Reference): AnnotatedCommit;
   * }
   * ```
   *
   * @param {Reference} reference - Reference to creates a Annotated Commit.
   * @returns An Annotated Commit created from reference.
   */
  getAnnotatedCommitFromReference(reference: GitReference): AnnotatedCommit
  /**
   * Creates a Annotated Commit from `FETCH_HEAD`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommitFromFetchHead(
   *     branchName: string,
   *     remoteUrl: string,
   *     id: string,
   *   ): AnnotatedCommit;
   * }
   * ```
   *
   * @param {String} branchName - Name of the remote branch.
   * @param {String} remoteUrl - Url of the remote.
   * @param {String} id - The commit object id of the remote branch.
   * @returns An Annotated Commit created from `FETCH_HEAD`.
   */
  getAnnotatedCommitFromFetchHead(branchName: string, remoteUrl: string, id: string): AnnotatedCommit
  /**
   * Apply a Diff to the given repo, making changes directly in the working directory, the index, or both.
   *
   * @category Repository/Methods
   * ```ts
   * class Repository {
   *   apply(diff: Diff, location: ApplyLocation, options?: ApplyOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {Diff} diff - The diff to apply
   * @param {ApplyLocation} location - The location to apply
   * @param {ApplyOptions} [options] - The options for the apply
   */
  apply(diff: Diff, location: ApplyLocation, options?: ApplyOptions | undefined | null): void
  /**
   * Apply a Diff to the provided tree, and return the resulting Index.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   applyToTree(
   *     tree: Tree,
   *     diff: Diff,
   *     options?: ApplyOptions | null | undefined
   *   ): Index;
   * }
   * ```
   *
   * @param {Tree} tree - The tree to apply the diff to
   * @param {Diff} diff - The diff to apply
   * @param {ApplyOptions} [options] - The options for the apply
   *
   * @returns The postimage of the application
   */
  applyToTree(tree: Tree, diff: Diff, options?: ApplyOptions | undefined | null): Index
  /**
   * Get the value of a git attribute for a path.
   *
   * @ository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAttr(
   *     path: string,
   *     name: string,
   *     options?: AttrOptions | null | undefined
   *   ): boolean | string | Buffer | null;
   * ```
   *
   * @param {string} path - The path to check for attributes. Relative paths are interpreted relative to the repo root.
   * @param {string} name - The name of the attribute to look up.
   * @param {AttrOptions} [options] - Options for attribute lookup.
   *
   * @returns Output of the value of the attribute.
   */
  getAttr(path: string, name: string, options?: AttrOptions | undefined | null): boolean | string | Buffer | null
  /**
   * Creates a blame object for the file at the given path
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   blameFile(path: string, options?: BlameOptions): Blame;
   * }
   * ```
   *
   * @example
   * ```ts
   * // Blame the entire file
   * const blame = repo.blameFile('path/to/file.js');
   *
   * // Blame a single line
   * const lineBlame = repo.blameFile('path/to/file.js', { minLine: 10, maxLine: 10 });
   *
   * // Blame a range of lines
   * const rangeBlame = repo.blameFile('path/to/file.js', { minLine: 5, maxLine: 15 });
   * ```
   *
   * @param {string} path - Path to the file to blame
   * @param {BlameOptions} [options] - Options to control blame behavior
   * @returns Blame object for the specified file
   * @throws If the file doesn't exist or can't be opened
   */
  blameFile(path: string, options?: BlameOptions | undefined | null): Blame
  /**
   * Create a new branch pointing at a target commit
   *
   * A new direct reference will be created pointing to this target commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createBranch(
   *     branchName: string,
   *     target: Commit,
   *     options?: CreateBranchOptions | null | undefined,
   *   ): Branch;
   * }
   * ```
   *
   * @param {string} branchName - Name for the new branch.
   * @param {Commit} target - Target commit which will be pointed by this branch.
   * @param {CreateBranchOptions} [options] - Options for create branch.
   * @returns {Branch} Newly created branch.
   */
  createBranch(branchName: string, target: Commit, options?: CreateBranchOptions | undefined | null): Branch
  /**
   * Lookup a branch by its name in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findBranch(name: string, branchType: BranchType): Branch | null;
   * }
   * ```
   *
   * @param {string} name - A branch name.
   * @param {BranchType} branchType - Branch type to lookup.
   * @returns A found branch.
   */
  findBranch(name: string, branchType: BranchType): Branch | null
  /**
   * Lookup a branch by its name in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getBranch(name: string, branchType: BranchType): Branch;
   * }
   * ```
   *
   * @param {string} name - A branch name.
   * @param {BranchType} branchType - Branch type to lookup.
   * @returns A found branch.
   * @throws Throws error if branch does not exist.
   */
  getBranch(name: string, branchType: BranchType): Branch
  /**
   * Create an iterator which loops over the requested branches.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   branches(filter?: BranchesFilter | null | undefined): Branches;
   * }
   * ```
   *
   * @param {BranchesFilter} [filter] - Filter for the branches iterator.
   * @returns An iterator which loops over the requested branches.
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   *
   * for (const branch of repo.branches()) {
   *   console.log(branch.type); // "Local"
   *   console.log(branch.name); // "main"
   * }
   * ```
   */
  branches(filter?: BranchesFilter | undefined | null): Branches
  /**
   * Updates files in the index and the working tree to match the content of
   * the commit pointed at by HEAD.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutHead(options?: CheckoutOptions | undefined | null): void;
   * }
   * ```
   *
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutHead(options?: CheckoutOptions | undefined | null): void
  /**
   * Updates files in the working tree to match the content of the index.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutIndex(
   *     index?: Index | undefined | null,
   *     options?: CheckoutOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {Index} [index] - Index to checkout. If not given, the repository's index will be used.
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutIndex(index?: Index | undefined | null, options?: CheckoutOptions | undefined | null): void
  /**
   * Updates files in the index and working tree to match the content of the
   * tree pointed at by the treeish.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutTree(treeish: GitObject, options?: CheckoutOptions | undefined | null): void;
   * }
   * ```
   *
   * @param {GitObject} treeish - Git object which tree pointed.
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutTree(treeish: GitObject, options?: CheckoutOptions | undefined | null): void
  /**
   * Cherrypicks the given commit onto HEAD and updates the working tree and index.
   * This method prepares the index and tree as if the commit were applied, but does not actually make a new commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   cherrypick(
   *     commit: Commit,
   *     options?: CherrypickOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {Commit} commit - The commit to cherrypick.
   * @param {CherrypickOptions} [options] - Options for the cherrypick operation.
   * @throws {Error} If the commit is a merge commit and no mainline is specified.
   * @throws {Error} If there are conflicts during the cherrypick operation.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const cherrypickCommit = repo.getCommit('cherrypick-commit');
   *
   * // Cherrypick the commit onto HEAD and working tree
   * repo.cherrypick(cherrypickCommit);
   * repo.cleanupState();
   *
   * // Cherrypick the commit against our commit selecting the first parent as mainline (This is necessary because, for merge commits, there is ambiguity about which side of the merge should be treated as the baseline.)
   * repo.cherrypick(cherrypickCommit, { mainline: 1 });
   * repo.cleanupState();
   *
   * // Prevent working tree changes (dry run) but compute conflicts
   * repo.cherrypick(cherrypickCommit, { checkoutOptions: { dryRun: true } });
   * repo.cleanupState();
   *
   * // Cherrypick the commit against our commit selecting the first parent as mainline and prevent working tree changes (dry run) but compute conflicts
   * repo.cherrypick(cherrypickCommit, { mainline: 1, checkoutOptions: { dryRun: true } });
   * repo.cleanupState();
   * ```
   */
  cherrypick(commit: Commit, options?: CherrypickOptions | undefined | null): void
  /**
   * Applies a cherrypick of `cherrypick_commit` against `our_commit` and returns the resulting Index,
   * without modifying the working directory or repository state.
   * This method does not write any changes to disk or update HEAD.
   * it is useful for computing what the cherrypick result would look like without actually applying it.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   cherrypickCommit(
   *     cherrypickCommit: Commit,
   *     ourCommit: Commit,
   *     mainline: number,
   *     mergeOptions?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Commit} cherrypickCommit - The commit to cherrypick.
   * @param {Commit} ourCommit - The commit to cherrypick against (usually HEAD).
   * @param {number} mainline - The parent of the cherrypick commit, if it is a merge (1-based).
   * @param {MergeOptions} [mergeOptions] - Options for merge conflict resolution.
   * @returns The index result.
   * @throws {Error} If the cherrypick commit is a merge and mainline is 0.
   * @throws {Error} If there are conflicts and failOnConflict is true (default).
   *
   * @example
   * ```ts
   * // This is an example for cherrypick_commit
   * import { openRepository } from "es-git";
   *
   * const repo = await openRepository("./path/to/repo");
   * const cherry = repo.getCommit("cherrypick-commit");
   * const target = repo.getCommit("onto-commit");
   *
   * // Returns the Index resulting from the cherrypick in memory,
   * // without affecting HEAD or the working tree.
   * // The mainline parameter indicates which parent to use as the baseline,
   * // For merge commits, mainline specifies which parent to use as baseline (1 or 2).
   * // For normal (non-merge) commits, use mainline 0.
   * const idx = repo.cherrypickCommit(cherry, target, 0);
   *
   * // You can check for conflicts with idx.hasConflicts()
   * ```
   */
  cherrypickCommit(cherrypickCommit: Commit, ourCommit: Commit, mainline: number, mergeOptions?: MergeOptions | undefined | null): Index
  /**
   * Lookup a reference to one of the commits in a repository.
   *
   * Returns `null` if the commit does not exist.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   findCommit(oid: string): Commit | null;
   * }
   * ```
   * @param {string} oid - Commit ID(SHA1) to lookup.
   * @returns Commit instance found by oid. Returns `null` if the commit does not exist.
   */
  findCommit(oid: string): Commit | null
  /**
   * Lookup a reference to one of the commits in a repository.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   getCommit(oid: string): Commit;
   * }
   * ```
   *
   * @param {string} oid - Commit ID(SHA1) to lookup.
   * @returns Commit instance found by oid.
   * @throws Throws error if the commit does not exist.
   */
  getCommit(oid: string): Commit
  /**
   * Create new commit in the repository.
   *
   * If the `updateRef` is not `null`, name of the reference that will be
   * updated to point to this commit. If the reference is not direct, it will
   * be resolved to a direct reference. Use "HEAD" to update the HEAD of the
   * current branch and make it point to this commit. If the reference
   * doesn't exist yet, it will be created. If it does exist, the first
   * parent must be the tip of this branch.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   commit(tree: Tree, message: string, options?: CommitOptions | null | undefined): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of created commit.
   */
  commit(tree: Tree, message: string, options?: CommitOptions | undefined | null): string
  /**
   * Get the configuration file for this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   config(): Config;
   * }
   * ```
   *
   * @returns If a configuration file has not been set, the default config set for the
   * repository will be returned, including global and system configurations
   * (if they are available).
   */
  config(): Config
  /**
   * Describes a commit
   *
   * Performs a describe operation on the current commit and the worktree.
   * After performing a describe on `HEAD`, a status is run and description is
   * considered to be dirty if there are.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   describe(options?: DescribeOptions | null | undefined): Describe;
   * }
   * ```
   *
   * @param {DescribeOptions} [options] - Options for describe operation.
   * @returns Instance of describe.
   */
  describe(options?: DescribeOptions | undefined | null): Describe
  /**
   * Create a diff with the difference between two tree objects.
   *
   * This is equivalent to `git diff <old-tree> <new-tree>`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToTree(
   *     oldTree?: Tree | null | undefined,
   *     newTree?: Tree | null | undefined,
   *     options?: DiffOptions | null | undefined,
   *   ): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   * @param {Tree} [newTree] - Tree used for the "newFile" side of the delta. If you not pass,
   * then an empty tree is used.
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between two tree objects.
   * @throws Throws error if the `oldTree` and `newTree` is `null`.
   */
  diffTreeToTree(oldTree?: Tree | undefined | null, newTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between two index objects.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffIndexToIndex(
   *     oldIndex: Index,
   *     newIndex: Index,
   *     options?: DiffOptions | null | undefined,
   *   ): Diff;
   * }
   * ```
   *
   * @param {Index} [oldIndex] - Index used for the "oldFile" side of the delta.
   * @param {Index} [newIndex] - Index used for the "newFile" side of the delta.
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between two index objects.
   */
  diffIndexToIndex(oldIndex: Index, newIndex: Index, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between the repository index and the workdir directory.
   *
   * This matches the `git diff` command.  See the note below on
   * `diffTreeToWorkdir` for a discussion of the difference between
   * `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
   * using libgit2.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffIndexToWorkdir(index?: Index | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Index} [index] - Index used for the "oldFile" side of the delta. The working directory
   * will be used for the "newFile" side of the delta.
   *
   * If not you pass, then the existing index of the repository  will be used. In this case,
   * the index will be refreshed from disk (if it has changed) before the diff is generated.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between the repository index and the workdir directory.
   */
  diffIndexToWorkdir(index?: Index | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory.
   *
   * The tree you provide will be used for the "oldFile" side of the delta,
   * and the working directory will be used for the "newFile" side.
   *
   * This is not the same as `git diff <treeish>` or `git diff-index <treeish>`.
   * Those commands use information from the index, whereas this
   * function strictly returns the differences between the tree and the files
   * in the working directory, regardless of the state of the index. Use
   * `diffTreeToWorkdirWithIndex` to emulate those commands.
   *
   * To see difference between this and `diffTreeToWorkdirWithIndex`,
   * consider the example of a staged file deletion where the file has then
   * been put back into the working dir and further modified. The
   * tree-to-workdir diff for that file is 'modified', but `git diff` would
   * show status 'deleted' since there is a staged delete.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToWorkdir(oldTree?: Tree | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between a tree and the working directory.
   */
  diffTreeToWorkdir(oldTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory using index data
   * to account for staged deletes, tracked files, etc.
   *
   * This emulates `git diff <tree>` by diffing the tree to the index and
   * the index to the working directory and blending the results into a
   * single diff that includes staged deleted, etc.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToWorkdirWithIndex(oldTree?: Tree | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between a tree and the working directory using index data to account for
   * staged deletes, tracked files, etc.
   */
  diffTreeToWorkdirWithIndex(oldTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Add ignore rules for a repository.
   *
   * This adds ignore rules to the repository. The rules will be used
   * in addition to any existing ignore rules (such as .gitignore files).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   addIgnoreRule(rules: string): void;
   * }
   * ```
   *
   * @param {string} rules - Rules to add, separated by newlines.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * repo.addIgnoreRule("node_modules/");
   * ```
   */
  addIgnoreRule(rules: string): void
  /**
   * Clear ignore rules that were explicitly added.
   *
   * Resets to the default internal ignore rules.
   * This will not turn off rules in .gitignore files that actually exist in the filesystem.
   * The default internal ignores ignore ".", ".." and ".git" entries.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   clearIgnoreRules(): void;
   * }
   * ```
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * repo.addIgnoreRule("*.log");
   * // Later, clear all added rules
   * repo.clearIgnoreRules();
   * ```
   */
  clearIgnoreRules(): void
  /**
   * Test if the ignore rules apply to a given path.
   *
   * This function checks the ignore rules to see if they would apply to the given file.
   * This indicates if the file would be ignored regardless of whether the file is already in the index or committed to the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isPathIgnored(path: string): boolean;
   * }
   * ```
   *
   * @param {string} path - The path to check.
   * @returns {boolean} - True if the path is ignored, false otherwise.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const isIgnored = repo.isPathIgnored("node_modules/some-package");
   * console.log(`Path is ${isIgnored ? "ignored" : "not ignored"}`);
   * ```
   */
  isPathIgnored(path: string): boolean
  /**
   * Get the Index file for this repository.
   *
   * If a custom index has not been set, the default index for the repository
   * will be returned (the one located in `.git/index`).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   index(): Index;
   * }
   * ```
   *
   * @returns The index file for this repository.
   */
  index(): Index
  /**
   * Gets this repository's mailmap.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   mailmap(): Mailmap | null;
   * }
   * ```
   *
   * @returns The mailmap object if it exists, null otherwise
   */
  mailmap(): Mailmap | null
  /**
   * Find a merge base between two commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeBase(one: string, two: string): string;
   * }
   * ```
   *
   * @param {string} one - One of the commits OID.
   * @param {string} two - The other commit OID.
   * @returns The OID of a merge base between 'one' and 'two'.
   */
  getMergeBase(one: string, two: string): string
  /**
   * Find a merge base given a list of commits
   *
   * This behaves similar to [`git merge-base`](https://git-scm.com/docs/git-merge-base#_discussion).
   * Given three commits `a`, `b`, and `c`, `getMergeBaseMany([a, b, c])`
   * will compute a hypothetical commit `m`, which is a merge between `b`
   * and `c`.
   *
   * For example, with the following topology:
   * ```text
   *        o---o---o---o---C
   *       /
   *      /   o---o---o---B
   *     /   /
   * ---2---1---o---o---o---A
   * ```
   *
   * the result of `getMergeBaseMany([a, b, c])` is 1. This is because the
   * equivalent topology with a merge commit `m` between `b` and `c` would
   * is:
   * ```text
   *        o---o---o---o---o
   *       /                 \
   *      /   o---o---o---o---M
   *     /   /
   * ---2---1---o---o---o---A
   * ```
   *
   * and the result of `getMergeBaseMany([a, m])` is 1.
   *
   * ---
   *
   * If you're looking to recieve the common merge base between all the
   * given commits, use `getMergeBaseOctopus`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBaseMany(oids: string[]): string;
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns The OID of a merge base considering all the commits.
   */
  getMergeBaseMany(oids: Array<string>): string
  /**
   * Find a merge base in preparation for an octopus merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBaseOctopus(oids: string[]): string;
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns The OID of a merge base considering all the commits.
   */
  getMergeBaseOctopus(oids: Array<string>): string
  /**
   * Find all merge bases between two commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBases(one: string, two: string): string[];
   * }
   * ```
   *
   * @param {string} one - One of the commits OID.
   * @param {string} two - The other commit OID.
   * @returns Array in which to store the resulting OIDs.
   */
  getMergeBases(one: string, two: string): Array<string>
  /**
   * Find all merge bases given a list of commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBasesMany(oids: string[]): string[];
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns Array in which to store the resulting OIDs.
   */
  getMergeBasesMany(oids: Array<string>): Array<string>
  /**
   * Merges the given commit(s) into HEAD, writing the results into the
   * working directory. Any changes are staged for commit and any conflicts
   * are written to the index. Callers should inspect the repository's index
   * after this completes, resolve any conflicts and prepare a commit.
   *
   * For compatibility with git, the repository is put into a merging state.
   * Once the commit is done (or if the user wishes to abort), you should
   * clear this state by calling `cleanupState()`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   merge(
   *     annotatedCommits: AnnotatedCommit[],
   *     mergeOptions?: MergeOptions | undefined | null,
   *     checkoutOptions?: CheckoutOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {AnnotatedCommit[]} annotatedCommits - Commits to merge.
   * @param {MergeOptions} [mergeOptions] - Merge options.
   * @param {CheckoutOptions} [checkoutOptions] - Checkout options.
   */
  merge(annotatedCommits: Array<AnnotatedCommit>, mergeOptions?: MergeOptions | undefined | null, checkoutOptions?: CheckoutOptions | undefined | null): void
  /**
   * Merge two commits, producing an index that reflects the result of
   * the merge. The index may be written as-is to the working directory or
   * checked out. If the index is to be converted to a tree, the caller
   * should resolve any conflicts that arose as part of the merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeCommits(
   *     ourCommit: Commit,
   *     theirCommit: Commit,
   *     options?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Commit} ourCommit - The commit that reflects the destination tree.
   * @param {Commit} theirCommit - The commit to merge in to `ourCommit`.
   * @param {MergeOptions} [options] - Merge options.
   * @returns The index result.
   */
  mergeCommits(ourCommit: Commit, theirCommit: Commit, options?: MergeOptions | undefined | null): Index
  /**
   * Merge two trees, producing an index that reflects the result of
   * the merge. The index may be written as-is to the working directory or
   * checked out. If the index is to be converted to a tree, the caller
   * should resolve any conflicts that arose as part of the merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeTrees(
   *     ancestorTree: Tree,
   *     ourTree: Tree,
   *     theirTree: Tree,
   *     options?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Tree} ancestorTree - The common ancestor between.
   * @param {Tree} ourTree - The tree that reflects the destination tree.
   * @param {Tree} theirTree - The tree to merge in to `ourTree`.
   * @param {MergeOptions} [options] - Merge options.
   * @returns The index result.
   */
  mergeTrees(ancestorTree: Tree, ourTree: Tree, theirTree: Tree, options?: MergeOptions | undefined | null): Index
  /**
   * Analyzes the given branch(es) and determines the opportunities for
   * merging them into the HEAD of the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   analyzeMergeFor(theirHeads: AnnotatedCommit[]): MergeAnalysisResult;
   * }
   * ```
   *
   * @param {AnnotatedCommit[]} theirHeads - The heads to merge into.
   * @returns Merge analysis result.
   */
  analyzeMerge(theirHeads: Array<AnnotatedCommit>): MergeAnalysisResult
  /**
   * Analyzes the given branch(es) and determines the opportunities for
   * merging them into a reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   analyzeMergeForRef(ourRef: Reference, theirHeads: AnnotatedCommit[]): MergeAnalysisResult;
   * }
   * ```
   *
   * @param {Reference} ourRef - The reference to perform the analysis from.
   * @param {AnnotatedCommit[]} theirHeads - The heads to merge into.
   * @returns Merge analysis result.
   */
  analyzeMergeForRef(ourRef: Reference, theirHeads: Array<AnnotatedCommit>): MergeAnalysisResult
  /**
   * Add a note for an object
   *
   * The `notesRef` argument is the canonical name of the reference to use,
   * defaulting to "refs/notes/commits". If `force` is specified then
   * previous notes are overwritten.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   note(oid: string, note: string, options?: CreateNoteOptions | null | undefined): string;
   * }
   * ```
   *
   * @param {string} oid - OID of the git object to decorate.
   * @param {string} note - Content of the note to add for object oid.
   * @param {CreateNoteOptions} [options] - Options for creating note.
   * @returns OID for the note.
   */
  note(oid: string, note: string, options?: CreateNoteOptions | undefined | null): string
  /**
   * Get the default notes reference for this repository
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   noteDefaultRef(): string;
   * }
   * ```
   *
   * @returns The default notes reference.
   */
  noteDefaultRef(): string
  /**
   * Creates a new iterator for notes in this repository.
   *
   * The `notesRef` argument is the canonical name of the reference to use,
   * defaulting to "refs/notes/commits".
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   notes(notesRef?: string | null | undefined): Notes;
   * }
   * ```
   *
   * @param {string} [notesRef] - The canonical name of the reference to use.
   * @returns Iterator of all notes. The iterator returned yields pairs of `[string, string]`
   * where first element is the id of the note and the second id is the id the note is annotating.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * for (const { noteId, annotatedId } of repo.notes()) {
   *   const note = repo.getNote(noteId);
   *   const commit = repo.getCommit(annotatedId);
   * }
   * ```
   */
  notes(notesRef?: string | undefined | null): Notes
  /**
   * Read the note for an object.
   *
   * The `notesRef` argument is the canonical name of the reference to use,
   * defaulting to "refs/notes/commits".
   *
   * The id specified is the Oid of the git object to read the note from.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getNote(id: string, options?: FindNoteOptions | null | undefined): Note;
   * }
   * ```
   *
   * @param {string} id - OID of the git object to read the note from.
   * @param {FindNoteOptions} [options] - Options for finding note.
   * @returns Instance of the note.
   * @throws Throws error if note does not exists.
   */
  getNote(id: string, options?: FindNoteOptions | undefined | null): Note
  /**
   * Read the note for an object.
   *
   * The `notesRef` argument is the canonical name of the reference to use,
   * defaulting to "refs/notes/commits".
   *
   * The id specified is the Oid of the git object to read the note from.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findNote(id: string, options?: FindNoteOptions | null | undefined): Note | null;
   * }
   * ```
   *
   * @param {string} id - OID of the git object to read the note from.
   * @param {FindNoteOptions} [options] - Options for finding note.
   * @returns Instance of the note. If does not exists, returns `null`.
   */
  findNote(id: string, options?: FindNoteOptions | undefined | null): Note | null
  /**
   * Remove the note for an object.
   *
   * The `notesRef` argument is the canonical name of the reference to use,
   * defaulting to "refs/notes/commits".
   *
   * The id specified is the Oid of the git object to remove the note from.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   deleteNote(id: string, options?: DeleteNoteOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string} id - OID of the git object to remove the note from.
   * @param {DeleteNoteOptions} [options] - Options for deleting note.
   */
  deleteNote(id: string, options?: DeleteNoteOptions | undefined | null): void
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findObject(oid: string): GitObject | null;
   * }
   * ```
   *
   * @param {string} oid - Git object ID(SHA1) to lookup.
   * @returns Git object. Returns `null` if the object does not exist.
   */
  findObject(oid: string): GitObject | null
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getObject(oid: string): GitObject;
   * }
   * ```
   *
   * @param {string} oid - Git object ID(SHA1) to lookup.
   * @returns Git object.
   * @throws Throws error if the object does not exist.
   */
  getObject(oid: string): GitObject
  /**
   * Initializes a rebase operation to rebase the changes in `branch`
   * relative to `upstream` onto another branch. To begin the rebase process,
   * call iterator.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   rebase(
   *     branch?: AnnotatedCommit | undefined | null,
   *     upstream?: AnnotatedCommit | undefined | null,
   *     onto?: AnnotatedCommit | undefined | null,
   *     options?: RebaseOptions | undefined | null,
   *   ): Rebase;
   * }
   * ```
   *
   * @param {AnnotatedCommit | undefined | null} [branch] - Annotated commit representing the
   * branch to rebase. Typically, the branch's head commit. If omitted, the currently checked-out
   * branch is used.
   * @param {AnnotatedCommit | undefined | null} [upstream] - Annotated commit that defines the
   * "original base" of the commits to be rebased. If omitted, the repository will typically try
   * to use the branch's configured upstream.
   * @param {AnnotatedCommit | undefined | null} [onto] - Specified the "new base" onto which the
   * selected commits will be reapplied.
   * @param {RebaseOptions | undefined | null} [options] - Fine-grained control of the rebase
   * behavior, such as checkout options, merge options, and in-memory rebase.
   * @returns The initialized rebase handle to iterate and apply steps.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const branchRef = repo.getReference('refs/heads/other');
   * const upstreamRef = repo.getReference('refs/heads/main');
   * const branch = repo.getAnnotatedCommitFromReference(branchRef);
   * const upstream = repo.getAnnotatedCommitFromReference(upstreamRef);
   *
   * const sig = { name: 'Seokju Na', email: 'seokju.me@toss.im' };
   *
   * const rebase = repo.rebase(branch, upstream);
   * for (const op of rebase) {
   *   rebase.commit({ committer: sig });
   * }
   * rebase.finish(sig);
   * ```
   */
  rebase(branch?: AnnotatedCommit | undefined | null, upstream?: AnnotatedCommit | undefined | null, onto?: AnnotatedCommit | undefined | null, options?: RebaseOptions | undefined | null): Rebase
  /**
   * Opens an existing rebase that was previously started by either an
   * invocation of `rebase()` or by another client.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   openRebase(options?: RebaseOptions | undefined | null): Rebase;
   * }
   * ```
   *
   * @param {RebaseOptions | undefined | null} [options] - Fine-grained control of the rebase
   * behavior, such as checkout options, merge options, and in-memory rebase.
   * @returns The initialized rebase handle to iterate and apply steps.
   * @throws Throws if the existing rebase was not found.
   */
  openRebase(options?: RebaseOptions | undefined | null): Rebase
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findReference(name: string): Reference | null;
   * }
   * ```
   *
   * @param {string} name - Reference name to lookup.
   * @returns Returns `null` if the reference does not exist.
   *
   * @example
   *
   * Get `HEAD` reference from the repository.
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const reference = repo.findReference('HEAD');
   * ```
   */
  findReference(name: string): Reference | null
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getReference(name: string): Reference;
   * }
   * ```
   *
   * @param {string} name - Reference name to lookup.
   * @returns Git reference.
   * @throws Throws error if the reference does not exist.
   *
   * @example
   *
   * Get `HEAD` reference from the repository.
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const reference = repo.getReference('HEAD');
   * ```
   */
  getReference(name: string): Reference
  /**
   * List all remotes for a given repository
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   remoteNames(): string[];
   * }
   * ```
   *
   * @returns All remote names for this repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * console.log(repo.remoteNames()); // ["origin"]
   * ```
   */
  remoteNames(): Array<string>
  /**
   * Get remote from repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getRemote(name: string): Remote;
   * }
   * ```
   *
   * @returns Remote instance.
   * @throws Throws error if remote does not exist.
   */
  getRemote(name: string): Remote
  /**
   * Find remote from repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findRemote(name: string): Remote | null;
   * }
   * ```
   *
   * @returns Returns `null` if remote does not exist.
   */
  findRemote(name: string): Remote | null
  /**
   * Add a remote with the default fetch refspec to the repositorys configuration.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createRemote(name: string, url: string, options?: CreateRemoteOptions | null | undefined): Remote;
   * }
   * ```
   *
   * @param {string} name - The name of the remote.
   * @param {string} url - Remote url.
   * @param {CreateRemoteOptions} [options] - Options for creating remote.
   * @returns Created remote.
   */
  createRemote(name: string, url: string, options?: CreateRemoteOptions | undefined | null): Remote
  /**
   * Tests whether this repository is a bare repository or not.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isBare(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a bare.
   */
  isBare(): boolean
  /**
   * Tests whether this repository is a shallow clone.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isShallow(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a shallow clone.
   */
  isShallow(): boolean
  /**
   * Tests whether this repository is a worktree.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isWorktree(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a worktree.
   */
  isWorktree(): boolean
  /**
   * Tests whether this repository is empty.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is empty.
   */
  isEmpty(): boolean
  /**
   * Returns the path to the `.git` folder for normal repositories or the
   * repository itself for bare repositories.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   path(): string;
   * }
   * ```
   *
   * @returns The path to the `.git` folder for normal repositories or the repository itself
   * for bare repositories.
   */
  path(): string
  /**
   * Returns the current state of this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   state(): RepositoryState;
   * }
   * ```
   *
   * @returns The current state of this repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./repo');
   * console.log(repo.state()); // e.g., 'Clean'
   * // After a revert/merge/cherry-pick, state can be 'Revert'/'Merge' etc.
   * // Use repo.cleanupState() to return to 'Clean' when done handling.
   * ```
   */
  state(): RepositoryState
  /**
   * Get the path of the working directory for this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   workdir(): string | null;
   * }
   * ```
   *
   * @returns The path of the working directory for this repository.
   * If this repository is bare, then `null` is returned.
   * ```
   */
  workdir(): string | null
  /**
   * Retrieve and resolve the reference pointed at by `HEAD`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   head(): Reference;
   * }
   * ```
   *
   * @returns Reference pointed at by `HEAD`.
   */
  head(): Reference
  /**
   * Make the repository `HEAD` point to the specified reference.
   *
   * If the provided reference points to a tree or a blob, the `HEAD` is
   * unaltered and an error is returned.
   *
   * If the provided reference points to a branch, the `HEAD` will point to
   * that branch, staying attached, or become attached if it isn't yet. If
   * the branch doesn't exist yet, no error will be returned. The `HEAD` will
   * then be attached to an unborn branch.
   *
   * Otherwise, the `HEAD` will be detached and will directly point to the
   * commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHead(refname: string): void;
   * }
   * ```
   *
   * @param {string} refname - Specified reference to point into `HEAD`.
   */
  setHead(refname: string): void
  /**
   * Determines whether the repository `HEAD` is detached.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   headDetached(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the repository `HEAD` is detached.
   */
  headDetached(): boolean
  /**
   * Make the repository HEAD directly point to the commit.
   *
   * If the provided commitish cannot be found in the repository, the HEAD
   * is unaltered and an error is returned.
   *
   * If the provided commitish cannot be peeled into a commit, the HEAD is
   * unaltered and an error is returned.
   *
   * Otherwise, the HEAD will eventually be detached and will directly point
   * to the peeled commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHeadDetached(commitish: Commit): void;
   * }
   * ```
   *
   * @param {Commit} commit - A Commit which the HEAD should point to.
   */
  setHeadDetached(commit: Commit): void
  /**
   * Make the repository HEAD directly point to the commit.
   *
   * If the provided commitish cannot be found in the repository, the HEAD
   * is unaltered and an error is returned.
   * If the provided commitish cannot be peeled into a commit, the HEAD is
   * unaltered and an error is returned.
   * Otherwise, the HEAD will eventually be detached and will directly point
   * to the peeled commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHeadDetachedFromAnnotated(commitish: AnnotatedCommit): void;
   * }
   * ```
   *
   * @param {AnnotatedCommit} commitish - An Annotated Commit which the HEAD should point to.
   */
  setHeadDetachedFromAnnotated(commitish: AnnotatedCommit): void
  /**
   * Extract a signature from an object identified by its ID.
   *
   * This method can be used for any object that may be signed, such as commits or tags.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   extractSignature(oid: string): ExtractedSignature | null;
   * }
   * ```
   *
   * @param {string} oid - Object ID (SHA1) of the signed object to extract the signature from.
   * @returns An ExtractedSignature object containing the signature and signed data if the object is signed,
   *          or null if the object is not signed.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const commit = repo.getCommit('a01e9888e46729ef4aa68953ba19b02a7a64eb82');
   *
   * // Extract the signature from a commit
   * const signatureInfo = repo.extractSignature(commit.id());
   *
   * if (signatureInfo) {
   *   console.log('Object is signed!');
   *   console.log('Signature:', signatureInfo.signature);
   *   console.log('Signed data:', signatureInfo.signedData);
   * } else {
   *   console.log('Object is not signed');
   * }
   * ```
   */
  extractSignature(oid: string): ExtractedSignature | null
  /**
   * Remove all the metadata associated with an ongoing command like merge,
   * revert, cherry-pick, etc. For example: `MERGE_HEAD`, `MERGE_MSG`, etc.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   cleanupState(): void;
   * }
   * ```
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./repo');
   * // After revert or merge operations:
   * if (repo.state() !== 'Clean') {
   *   repo.cleanupState();
   * }
   * ```
   */
  cleanupState(): void
  /**
   * Reverts the given commit, applying the inverse of its changes to the
   * HEAD commit and the working directory.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revert(
   *     commit: Commit,
   *     options?: RevertOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {Commit} commit - The commit to revert.
   * @param {RevertOptions} [options] - Options for the revert operation.
   * @throws {Error} If the commit is a merge commit and no mainline is specified.
   * @throws {Error} If there are conflicts during the revert operation.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const last = repo.head().target()!;
   * const commit = repo.getCommit(last);
   *
   * // Revert and update working tree
   * repo.revert(commit);
   * repo.cleanupState();
   *
   * // Revert a merge commit: specify the mainline parent
   * // repo.revert(mergeCommit, { mainline: 1 });
   * // repo.cleanupState();
   * ```
   */
  revert(commit: Commit, options?: RevertOptions | undefined | null): void
  /**
   * Reverts the given commit against the given "our" commit, producing an
   * index that reflects the result of the revert.
   *
   * The returned index must be written to disk for the changes to take effect.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revertCommit(
   *     revertCommit: Commit,
   *     ourCommit: Commit,
   *     mainline: number,
   *     mergeOptions?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Commit} revertCommit - The commit to revert.
   * @param {Commit} ourCommit - The commit to revert against (usually HEAD).
   * @param {number} mainline - The parent of the revert commit, if it is a merge (1-based).
   * @param {MergeOptions} [mergeOptions] - Options for merge conflict resolution.
   * @returns The index result.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const head = repo.head().target()!;
   * const our = repo.getCommit(head);
   * const target = repo.getCommit(head);
   *
   * // Compute a revert index and apply to working tree
   * const idx = repo.revertCommit(target, our, 0);
   * repo.checkoutIndex(idx);
   * ```
   */
  revertCommit(revertCommit: Commit, ourCommit: Commit, mainline: number, mergeOptions?: MergeOptions | undefined | null): Index
  /**
   * Execute a rev-parse operation against the `spec` listed.
   *
   * The resulting revision specification is returned, or an error is
   * returned if one occurs.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revparse(spec: string): Revspec;
   * }
   * ```
   *
   * @param {string} spec - Revision string.
   * @returns
   */
  revparse(spec: string): Revspec
  /**
   * Find a single object, as specified by a revision string.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revparseSingle(spec: string): string;
   * }
   * ```
   *
   * @param {string} spec - Revision string.
   * @returns OID of single object.
   * @throws Throws error if the object does not exist.
   */
  revparseSingle(spec: string): string
  /**
   * Create a revwalk that can be used to traverse the commit graph.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revwalk(): Revwalk;
   * }
   * ```
   *
   * @returns Revwalk to traverse the commit graph in this repository.
   */
  revwalk(): Revwalk
  /**
   * Save the local modifications to a new stash.
   *
   * This method saves your current working directory and index state to a new stash entry,
   * allowing you to temporarily store changes and work on something else. The working directory
   * is reverted to match the HEAD commit after stashing.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashSave(options?: StashSaveOptions): string;
   * }
   * ```
   *
   * @param {StashSaveOptions} [options] - Options for saving the stash.
   * @returns {string} The object ID (40-character SHA1) of the commit containing the stashed state.
   * @throws {Error} If there are no local changes to stash or if the stash operation fails.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Simple stash
   * const stashId = repo.stashSave({
   *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
   *   message: 'WIP: implementing new feature'
   * });
   *
   * // Stash including untracked files
   * repo.stashSave({
   *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
   *   includeUntracked: true
   * });
   * ```
   */
  stashSave(options?: StashSaveOptions | undefined | null): string
  /**
   * Apply a single stashed state from the stash list.
   *
   * This method applies the changes from a stash entry to your working directory.
   * Unlike `stashPop`, this does not remove the stash from the list after applying.
   * Conflicts may occur if the stashed changes conflict with the current working directory.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashApply(index: number, options?: StashApplyOptions): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to apply (0 is the most recent).
   * @param {StashApplyOptions} [options] - Options for applying the stash.
   * @throws {Error} If the stash index is invalid or if there are conflicts during application.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Apply the most recent stash
   * repo.stashApply(0);
   *
   * // Apply with options
   * repo.stashApply(0, { reinstantiateIndex: true });
   * ```
   */
  stashApply(index: number, options?: StashApplyOptions | undefined | null): void
  /**
   * Remove a single stashed state from the stash list.
   *
   * This permanently deletes a stash entry. The stash is removed from the list and
   * cannot be recovered. All subsequent stashes will be reindexed (e.g., stash@{2}
   * becomes stash@{1} after dropping stash@{1}).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashDrop(index: number): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to drop (0 is the most recent).
   * @throws {Error} If the stash index is invalid.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Drop the most recent stash
   * repo.stashDrop(0);
   *
   * // Drop the third stash
   * repo.stashDrop(2);
   * ```
   */
  stashDrop(index: number): void
  /**
   * Apply a single stashed state from the stash list and remove it from the list if successful.
   *
   * This method combines `stashApply` and `stashDrop` into a single operation. It applies
   * the stash to your working directory and, if successful, removes it from the stash list.
   * If the application fails (e.g., due to conflicts), the stash remains in the list.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashPop(index: number, options?: StashApplyOptions): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to pop (0 is the most recent).
   * @param {StashApplyOptions} [options] - Options for applying the stash.
   * @throws {Error} If the stash index is invalid or if there are conflicts during application.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Pop the most recent stash
   * repo.stashPop(0);
   *
   * // Pop with options
   * repo.stashPop(0, { reinstantiateIndex: true });
   * ```
   */
  stashPop(index: number, options?: StashApplyOptions | undefined | null): void
  /**
   * Get the list of stash states in the repository.
   *
   * Returns a StashList object that provides access to all stashes in the repository.
   * The list is ordered with the most recent stash at index 0.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashList(): StashList;
   * }
   * ```
   *
   * @returns {StashList} A container providing access to all stash entries in the repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * if (!stashList.isEmpty()) {
   *   console.log(`Found ${stashList.len()} stashes`);
   *   for (const stash of stashList.iter()) {
   *     console.log(`${stash.index()}: ${stash.message()}`);
   *   }
   * }
   * ```
   */
  stashList(): StashList
  /**
   * Test if the ignore rules apply to a given file.
   *
   * This function checks the ignore rules to see if they would apply to the
   * given file. This indicates if the file would be ignored regardless of
   * whether the file is already in the index or committed to the repository.
   *
   * One way to think of this is if you were to do "git add ." on the
   * directory containing the file, would it be added or not?
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   statusShouldIgnore(path: string): boolean;
   * }
   * ```
   *
   * @param {string} path - A given file path.
   * @returns Returns `true` if the ignore rules apply to a given file.
   */
  statusShouldIgnore(path: string): boolean
  /**
   * Get file status for a single file.
   *
   * This tries to get status for the filename that you give. If no files
   * match that name (in either the HEAD, index, or working directory), this
   * returns NotFound.
   *
   * If the name matches multiple files (for example, if the path names a
   * directory or if running on a case- insensitive filesystem and yet the
   * HEAD has two entries that both match the path), then this returns
   * Ambiguous because it cannot give correct results.
   *
   * This does not do any sort of rename detection. Renames require a set of
   * targets and because of the path filtering, there is not enough
   * information to check renames correctly. To check file status with rename
   * detection, there is no choice but to do a full `statuses` and scan
   * through looking for the path that you are interested in.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getStatusFile(path: string): Status;
   * }
   * ```
   *
   * @param {string} path - A single file path.
   * @returns The `Status` of this single file.
   * @throws Throws error if the status file does not exist.
   */
  getStatusFile(path: string): Status
  /**
   * Get file status for a single file.
   *
   * This tries to get status for the filename that you give. If no files
   * match that name (in either the HEAD, index, or working directory), this
   * returns NotFound.
   *
   * If the name matches multiple files (for example, if the path names a
   * directory or if running on a case- insensitive filesystem and yet the
   * HEAD has two entries that both match the path), then this returns
   * Ambiguous because it cannot give correct results.
   *
   * This does not do any sort of rename detection. Renames require a set of
   * targets and because of the path filtering, there is not enough
   * information to check renames correctly. To check file status with rename
   * detection, there is no choice but to do a full `statuses` and scan
   * through looking for the path that you are interested in.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findStatusFile(path: string): Status | null;
   * }
   * ```
   *
   * @param {string} path - A single file path.
   * @returns The `Status` of this single file. If the status file does not exists, returns `null`.
   */
  findStatusFile(path: string): Status | null
  /**
   * Gather file status information and populate the returned structure.
   *
   * Note that if a pathspec is given in the options to filter the
   * status, then the results from rename detection (if you enable it) may
   * not be accurate. To do rename detection properly, this must be called
   * with no pathspec so that all files can be considered.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   statuses(): Statuses;
   * }
   * ```
   *
   * @returns A container for a list of status information about a repository.
   */
  statuses(): Statuses
  /**
   * Set up a new git submodule for checkout.
   *
   * This does "git submodule add" up to the fetch and checkout of the
   * submodule contents. It preps a new submodule, creates an entry in
   * `.gitmodules` and creates an empty initialized repository either at the
   * given path in the working directory or in `.git/modules` with a gitlink
   * from the working directory to the new repo.
   *
   * To fully emulate "git submodule add" call this function, then `open()`
   * the submodule repo and perform the clone step as needed. Lastly, call
   * `addFinalize()` to wrap up adding the new submodule and `.gitmodules`
   * to the index to be ready to commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submodule(
   *     url: string,
   *     path: string,
   *     useGitlink?: boolean | null | undefined,
   *   ): Submodule;
   * }
   * ```
   *
   * @param {string} url - URL for the submodule's remote.
   * @param {string} path - Path at which the submodule should be created.
   * @param {boolean} [useGitlink] - Should workdir contain a gitlink to the repo in
   * `.git/modules` vs. repo directly in workdir.
   *
   * @returns The submodule.
   */
  submodule(url: string, path: string, useGitlink?: boolean | undefined | null): Submodule
  submodules(): Array<Submodule>
  /**
   * Lookup submodule information by name or path.
   *
   * Given either the submodule name or path (they are usually the same),
   * this returns a structure describing the submodule.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getSubmodule(name: string): Submodule;
   * }
   * ```
   *
   * @param {string} name - The name of or path to the submodule; trailing slashes okay.
   * @returns The submodule.
   * @throws If the submodule not found.
   */
  getSubmodule(name: string): Submodule
  /**
   * Lookup submodule information by name or path.
   *
   * Given either the submodule name or path (they are usually the same),
   * this returns a structure describing the submodule.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findSubmodule(name: string): Submodule | null;
   * }
   * ```
   *
   * @param {string} name - The name of or path to the submodule; trailing slashes okay.
   * @returns The submodule. Returns `null` if the submodule is not found.
   */
  findSubmodule(name: string): Submodule | null
  /**
   * Get the status for a submodule.
   *
   * This looks at a submodule and tries to determine the status.  It
   * will return a combination of the `SubmoduleStatus` values.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submoduleStatus(name: string, ignore: SubmoduleIgnore): number;
   * }
   * ```
   *
   * @param {string} name - The name of the submodule.
   * @param {SubmoduleIgnore} ignore - The ignore rules to follow.
   * @returns The combination of the `SubmoduleStatus` values.
   *
   * @example
   * ```ts
   * import { openRepository, submoduleStatusContains, SubmoduleStatus } from 'es-git';
   *
   * const repo = await openRepository('...');
   * const status = repo.submoduleStatus('mysubmodule', 'None');
   *
   * console.log(
   *   submoduleStatusContains(status, SubmoduleStatus.InHead | SubmoduleStatus.InIndex)
   * ); // true
   * ```
   */
  submoduleStatus(name: string, ignore: SubmoduleIgnore): number
  /**
   * Set the ignore rule for the submodule in the configuration
   *
   * This does not affect any currently-loaded instances.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submoduleSetIgnore(name: string, ignore: SubmoduleIgnore): void;
   * }
   * ```
   *
   * @param {string} name - The name of the submodule.
   * @param {SubmoduleIgnore} ignore - The new value for the ignore rule.
   */
  submoduleSetIgnore(name: string, ignore: SubmoduleIgnore): void
  /**
   * Set the update rule for the submodule in the configuration
   *
   * This setting won't affect any existing instances.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submoduleSetUpdate(name: string, update: SubmoduleUpdate): void;
   * }
   * ```
   *
   * @param {string} name - The name of the submodule.
   * @param {SubmoduleUpdate} update - The new value to use.
   */
  submoduleSetUpdate(name: string, update: SubmoduleUpdate): void
  /**
   * Set the URL for the submodule in the configuration
   *
   * After calling this, you may wish to call `Submodule#sync()` to write
   * the changes to the checked out submodule repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submoduleSetUrl(name: string, url: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of the submodule to configure.
   * @param {string} url - URL that should be used for the submodule.
   */
  submoduleSetUrl(name: string, url: string): void
  /**
   * Set the branch for the submodule in the configuration
   *
   * After calling this, you may wish to call `Submodule#sync()` to write
   * the changes to the checked out submodule repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   submoduleSetBranch(name: string, branchName: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of the submodule to configure.
   * @param {string} branchName - Branch that should be used for the submodule
   */
  submoduleSetBranch(name: string, branchName: string): void
  /**
   * Lookup a tag object by prefix hash from the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findTag(oid: string): Tag | null;
   * }
   * ```
   *
   * @param {string} oid - Prefix hash.
   * @returns Returns `null` if tag does not exist.
   */
  findTag(oid: string): Tag | null
  /**
   * Lookup a tag object by prefix hash from the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getTag(oid: string): Tag;
   * }
   * ```
   *
   * @param {string} oid - Prefix hash.
   * @throws Throws error if tag does not exist.
   */
  getTag(oid: string): Tag
  /**
   * Get a list with all the tags in the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   tagNames(pattern?: string | null | undefined): string[];
   * }
   * ```
   *
   * @param {string} [pattern] - An optional fnmatch pattern can also be specified.
   */
  tagNames(pattern?: string | undefined | null): Array<string>
  /**
   * Iterate over all tags calling `callback` on each.
   * The callback is provided the tag id and name.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   tagForeach(callback: (oid: string, name: string) => boolean): void;
   * }
   * ```
   *
   * @param {(oid: string, name: string) => boolean} callback - If you wish to stop iteration,
   * return `false` in the callback.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const tags = [];
   * repo.tagForeach((sha, name) => {
   *   tags.push([name, sha]);
   *   return true;
   * });
   *
   * console.log(tags);
   * // [['aa0040546ed22b8bb33f3bd621e8d10ed849b02c', 'refs/tags/v0'],
   * //  ['674e3327707fcf32a348ecfc0cb6b93e57398b8c', 'refs/tags/v1'],
   * //  ['567aa5c6b219312dc7758ab88ebb7a1e5d36d26b', 'refs/tags/v2']]
   * ```
   */
  tagForeach(callback: (oid: string, name: string) => boolean): void
  /**
   * Delete an existing tag reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   deleteTag(name: string): void;
   * }
   * ```
   *
   * @param {string} name - The tag name will be checked for validity, see `isValidTagName`
   * for some rules about valid names.
   */
  deleteTag(name: string): void
  /**
   * Create a new tag in the repository from an object.
   *
   * A new reference will also be created pointing to this tag object.
   *
   * The message will not be cleaned up.
   *
   * The tag name will be checked for validity. You must avoid the characters
   * '~', '^', ':', ' \ ', '?', '[', and '*', and the sequences ".." and " @
   * {" which have special meaning to revparse.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createTag(
   *     name: string,
   *     target: GitObject,
   *     message: string,
   *     options?: CreateTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {string} message - The message of tag.
   * @param {CreateTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const commit = repo.getCommit('828954df9f08dc8e172447cdacf0ddea1adf9e63');
   *
   * const sha = repo.createTag(
   *   'mytag',
   *   commit.asObject(),
   *   'this is my tag message',
   *   {
   *     tagger: {
   *       name: 'Seokju Na',
   *       email: 'seokju.me@toss.im',
   *     },
   *   },
   * );
   * const tag = repo.getTag(sha);
   * console.log(tag.name()); // "mytag"
   * console.log(tag.target().id()); // "828954df9f08dc8e172447cdacf0ddea1adf9e63"
   * ```
   */
  createTag(name: string, target: GitObject, message: string, options?: CreateTagOptions | undefined | null): string
  /**
   * Create a new tag in the repository from an object without creating a reference.
   *
   * The message will not be cleaned up.
   *
   * The tag name will be checked for validity. You must avoid the characters
   * '~', '^', ':', ' \ ', '?', '[', and '*', and the sequences ".." and " @
   * {" which have special meaning to revparse.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createAnnotationTag(
   *     name: string,
   *     target: GitObject,
   *     message: string,
   *     options?: CreateAnnotationTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {string} message - The message of tag.
   * @param {CreateAnnotationTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   */
  createAnnotationTag(name: string, target: GitObject, message: string, options?: CreateAnnotationTagOptions | undefined | null): string
  /**
   * Create a new lightweight tag pointing at a target object.
   *
   * A new direct reference will be created pointing to this target object.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createLightweightTag(
   *     name: string,
   *     target: GitObject,
   *     options?: CreateLightweightTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {CreateLightweightTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   */
  createLightweightTag(name: string, target: GitObject, options?: CreateLightweightTagOptions | undefined | null): string
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getTree(oid: string): Tree;
   * }
   * ```
   *
   * @param {string} oid - ID(SHA1) to lookup.
   * @returns Git tree.
   * @throws Throws error if tree does not exist.
   */
  getTree(oid: string): Tree
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findTree(oid: string): Tree | null;
   * }
   * ```
   *
   * @param {string} oid - ID(SHA1) to lookup.
   * @returns If it does not exist, returns `null`.
   */
  findTree(oid: string): Tree | null
}

/**
 * A revwalk allows traversal of the commit graph defined by including one or
 * more leaves and excluding one or more roots.
 */
export declare class Revwalk {
  next(): string | null
  /**
   * Reset a revwalk to allow re-configuring it.
   *
   * The revwalk is automatically reset when iteration of its commits
   * completes.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   reset(): this;
   * }
   * ```
   */
  reset(): this
  /**
   * Set the order in which commits are visited.
   *
   * @category Revwalk/Methods
   *
   * @signature
   * ```ts
   * class Revwalk {
   *   setSorting(sort: number): this;
   * }
   * ```
   *
   * @param {number} sort - Orderings that may be specified for Revwalk iteration.
   * - `RevwalkSort.None` : Sort the repository contents in no particular ordering.
   * This sorting is arbitrary, implementation-specific, and subject to
   * change at any time. This is the default sorting for new walkers.
   * - `RevwalkSort.Topological` : Sort the repository contents in topological order
   * (children before parents).
   * This sorting mode can be combined with time sorting.
   * - `RevwalkSort.Time` : Sort the repository contents by commit time.
   * This sorting mode can be combined with topological sorting.
   * - `RevwalkSort.Reverse` : Iterate through the repository contents in reverse order.
   * This sorting mode can be combined with any others.
   *
   * @example
   * ```ts
   * import { openRepository, RevwalkSort } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const revwalk = repo.revwalk();
   * revwalk.setSorting(RevwalkSort.Time | RevwalkSort.Reverse);
   * ```
   */
  setSorting(sort: number): this
  /**
   * Simplify the history by first-parent.
   *
   * No parents other than the first for each commit will be enqueued.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   simplifyFirstParent(): this;
   * }
   * ```
   */
  simplifyFirstParent(): this
  /**
   * Mark a commit to start traversal from.
   *
   * The given OID must belong to a commitish on the walked repository.
   *
   * The given commit will be used as one of the roots when starting the
   * revision walk. At least one commit must be pushed onto the walker before
   * a walk can be started.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   push(oid: string): this;
   * }
   * ```
   *
   * @param {string} oid - OID which belong to a commitish on the walked repository.
   */
  push(oid: string): this
  /**
   * Push the repository's HEAD.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushHead(): this;
   * }
   * ```
   */
  pushHead(): this
  /**
   * Push matching references.
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * will be pushed to the revision walker.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushGlob(glob: string): this;
   * }
   * ```
   *
   * @param {string} glob - A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  pushGlob(glob: string): this
  /**
   * Push and hide the respective endpoints of the given range.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushRange(range: string): this;
   * }
   * ```
   *
   * @param {string} range - The range should be of the form `<commit>..<commit>` where each
   * `<commit>` is in the form accepted by `revparseSingle`. The left-hand
   * commit will be hidden and the right-hand commit pushed.
   */
  pushRange(range: string): this
  /**
   * Push the OID pointed to by a reference.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushRef(reference: string): this;
   * }
   * ```
   *
   * @param {string} reference - The reference must point to a commitish.
   */
  pushRef(reference: string): this
  /**
   * Mark a commit as not of interest to this revwalk.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hide(oid: string): this;
   * }
   * ```
   *
   * @param {string} oid - Marked commit OID as not of interest of this revwalk.
   */
  hide(oid: string): this
  /**
   * Hide the repository's HEAD.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideHead(): this;
   * }
   * ```
   */
  hideHead(): this
  /**
   * Hide matching references.
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * and their ancestors will be hidden from the output on the revision walk.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideGlob(glob: string): this;
   * }
   * ```
   *
   * @param {string} glob - A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  hideGlob(glob: string): this
  /**
   * Hide the OID pointed to by a reference.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideRef(reference: string): this;
   * }
   * ```
   *
   * @param {string} reference - The reference must point to a commitish.
   */
  hideRef(reference: string): this
}

/**
 * A class to represent a git stash entry.
 *
 * A stash entry represents a snapshot of the working directory and index that has been saved
 * temporarily. Each stash entry has an index (position in the stash stack), an ID (commit SHA),
 * and an optional message describing the changes.
 */
export declare class StashEntry {
  /**
   * Get the index of this stash entry.
   *
   * The index represents the position of this stash in the stash stack, where 0 is the most recent stash.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   index(): number;
   * }
   * ```
   *
   * @returns {number} Index of this stash entry (0-based, with 0 being the most recent).
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.index()); // 0
   * ```
   */
  index(): number
  /**
   * Get the id (SHA1) of this stash entry.
   *
   * Each stash is stored as a commit object, and this returns the commit SHA.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   id(): string;
   * }
   * ```
   *
   * @returns {string} The 40-character hexadecimal SHA1 hash of the stash commit.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.id()); // e.g., "a1b2c3d4e5f6..."
   * ```
   */
  id(): string
  /**
   * Get the message of this stash entry.
   *
   * Returns the message associated with the stash when it was created. If no custom message
   * was provided, it returns the default message generated by Git.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   message(): string | null;
   * }
   * ```
   *
   * @returns {string | null} The stash message, or null if not available.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.message()); // e.g., "WIP on main: abc1234 fix: typo"
   * ```
   */
  message(): string | null
}

/**
 * A container for a list of stash entries about a repository.
 *
 * The stash list provides access to all stashes in the repository. Stashes are indexed
 * from 0 (most recent) to n-1 (oldest). This class provides methods to access individual
 * stashes, check the count, and iterate over all stashes.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 * const stashList = repo.stashList();
 * console.log(`Total stashes: ${stashList.len()}`);
 *
 * // Iterate over all stashes
 * for (const stash of stashList.iter()) {
 *   console.log(`${stash.index()}: ${stash.message()}`);
 * }
 * ```
 */
export declare class StashList {
  /**
   * Gets a stash entry from this list at the specified index.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   get(index: number): StashEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of the stash entry to get (0-based, where 0 is the most recent).
   * @returns {StashEntry | null} A stash entry from this list at the specified index, or `null` if the index is out of bounds.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * // Get the most recent stash
   * const stash = stashList.get(0);
   * if (stash) {
   *   console.log(stash.message());
   * }
   * ```
   */
  get(index: number): StashEntry | null
  /**
   * Gets the count of stash entries in this list.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   len(): number;
   * }
   * ```
   *
   * @returns If there are no stashes in the repository, this should return 0.
   */
  len(): number
  /**
   * Check if the stash list is empty.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns {boolean} Returns `true` if there are no stash entries in this repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * if (stashList.isEmpty()) {
   *   console.log('No stashes found');
   * } else {
   *   console.log(`Found ${stashList.len()} stashes`);
   * }
   * ```
   */
  isEmpty(): boolean
  /**
   * Returns an iterator over the stash entries in this list.
   *
   * The iterator yields stash entries in order from newest (index 0) to oldest.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   iter(): StashListIter;
   * }
   * ```
   *
   * @returns {StashListIter} An iterator that yields StashEntry objects.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * // Iterate over stashes
   * for (const stash of stashList.iter()) {
   *   console.log(`${stash.index()}: ${stash.message()}`);
   * }
   * ```
   */
  iter(): StashListIter
}

/**
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class StashListIter extends Iterator<StashEntry, void, void> {

  next(value?: void): IteratorResult<StashEntry, void>
}

/** A structure representing an entry in the `Statuses` structure. */
export declare class StatusEntry {
  /**
   * Access this entry's path name as a string.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   path(): string;
   * }
   * ```
   *
   * @returns The path of this entry.
   */
  path(): string
  /**
   * Access the status for this file.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   status(): Status;
   * }
   * ```
   *
   * @returns Status data for this entry.
   */
  status(): Status
  /**
   * Access detailed information about the differences between the file in
   * `HEAD` and the file in the index.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   headToIndex(): DiffDelta | null;
   * }
   * ```
   *
   * @returns The differences between the file in `HEAD` and the file in the index.
   */
  headToIndex(): DiffDelta | null
  /**
   * Access detailed information about the differences between the file in
   * the index and the file in the working directory.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   indexToWorkdir(): DiffDelta | null;
   * }
   * ```
   *
   * @returns Differences between the file in the index and the file in the working directory.
   */
  indexToWorkdir(): DiffDelta | null
}

/**
 * A container for a list of status information about a repository.
 *
 * Each instance appears as if it were a collection, having a length and
 * allowing indexing, as well as providing an iterator.
 */
export declare class Statuses {
  /**
   * Gets a status entry from this list at the specified index.
   *
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   get(index: number): StatusEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of the status entry to get.
   * @returns A status entry from this list at the specified index. Returns `null` if the status
   * entry does not exist.
   */
  get(index: number): StatusEntry | null
  /**
   * Gets the count of status entries in this list.
   *
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   len(): number;
   * }
   * ```
   *
   * @returns If there are no changes in status (according to the options given
   * when the status list was created), this should return 0.
   */
  len(): bigint
  /**
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` if there is no status entry in this list.
   */
  isEmpty(): boolean
  /** Returns an iterator over the statuses in this list. */
  iter(): StatusesIter
}

/**
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class StatusesIter extends Iterator<StatusEntry, void, void> {

  next(value?: void): IteratorResult<StatusEntry, void>
}

export declare class Submodule {
  /**
   * Get the name for the submodule.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   name(): string;
   * }
   * ```
   */
  name(): string
  /**
   *  Get the submodule's branch.
   * ule/Methods
   *  @signature
   *  ```ts
   *  class Submodule {
   *    branch(): string | null;
   *  }
   *  ```
   *  @returns The branch name of the submodule. Returns `null` if the branch if the branch is
   *  not yet available.
   */
  branch(): string | null
  /**
   * Get the submodule's URL.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   url(): string | null;
   * }
   * ```
   *
   * @returns The URL of the submodule. Returns `null` if the URL isn't present.
   */
  url(): string | null
  /**
   * Get the path for the submodule.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   path(): string;
   * }
   * ```
   *
   * @returns The path for the submodule.
   */
  path(): string
  /**
   * Get the OID for the submodule in the current `HEAD` tree.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   headId(): string | null;
   * }
   * ```
   *
   * @returns The OID for the submodule in the current `HEAD` tree.
   */
  headId(): string | null
  /**
   * Get the OID for the submodule in the index.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   indexId(): string | null;
   * }
   * ```
   *
   * @returns The OID for the submodule in the index.
   */
  indexId(): string | null
  /**
   * Get the OID for the submodule in the current working directory.
   *
   * This returns the OID that corresponds to looking up `HEAD` in the
   * checked out submodule. If there are pending changes in the index or
   * anything else, this won't notice that.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   workdirId(): string | null;
   * }
   * ```
   *
   * @returns The OID for the submodule in the current working directory.
   */
  workdirId(): string | null
  /**
   * Get the ignore rule that will be used for the submodule.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   ignoreRule(): SubmoduleIgnore;
   * }
   * ```
   *
   * @returns The ignore rule that will be used for the submodule.
   */
  ignoreRule(): SubmoduleIgnore
  /**
   * Get the update rule that will be used for the submodule.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   updateStrategy(): SubmoduleUpdate;
   * }
   * ```
   *
   * @returns The update rule that will be used for the submodule.
   */
  updateStrategy(): SubmoduleUpdate
  /**
   * Copy submodule info into ".git/config" file.
   *
   * Just like "git submodule init", this copies information about the
   * submodule into ".git/config". You can use the accessor functions above
   * to alter the in-memory git_submodule object and control what is written
   * to the config, overriding what is in .gitmodules.
   *
   * By default, existing entries will not be overwritten, but passing `true`
   * for `overwrite` forces them to be updated.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   init(
   *     overwrite?: boolean | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {boolean} [overwrite] - By default, existing entries will not be overwritten, but
   * setting this to true forces them to be updated.
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   */
  init(overwrite?: boolean | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Set up the subrepository for a submodule in preparation for clone.
   *
   * This function can be called to init and set up a submodule repository
   * from a submodule in preparation to clone it from its remote.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   repoInit(
   *     useGitlink?: boolean | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<Repository>;
   * }
   * ```
   *
   * @param {boolean} [useGitlink] - Should the workdir contain a gitlink to the repo in
   * `.git/modules` vs. repo directly in workdir.
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   *
   * @returns The repository.
   */
  repoInit(useGitlink?: boolean | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>
  /**
   * Open the repository for a submodule.
   *
   * This will only work if the submodule is checked out into the working
   * directory.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   open(signal?: AbortSignal | null | undefined): Promise<Repository>;
   * }
   * ```
   *
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   * @returns The repository.
   */
  open(signal?: AbortSignal | undefined | null): Promise<Repository>
  /**
   * Reread submodule info from config, index, and `HEAD`.
   *
   * Call this to reread cached submodule information for this submodule if
   * you have reason to believe that it has changed.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   reload(
   *     force?: boolean | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {boolean} [force] - If this is `true`, then data will be reloaded even if it
   * doesn't seem out of date.
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   */
  reload(force?: boolean | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Copy submodule remote info into submodule repo.
   *
   * This copies the information about the submodules URL into the checked
   * out submodule config, acting like "git submodule sync". This is useful
   * if you have altered the URL for the submodule (or it has been altered
   * by a fetch of upstream changes) and you need to update your local repo.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   sync(signal?: AbortSignal | null | undefined): Promise<void>;
   * }
   * ```
   *
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   */
  sync(signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Add current submodule HEAD commit to index of superproject.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   addToIndex(writeIndex?: boolean | null | undefined): void;
   * }
   * ```
   *
   * @param {boolean} [writeIndex] - If is true, then the index file will be immediately written.
   * Otherwise, you must explicitly call `write()` on an `Index` later on.
   */
  addToIndex(writeIndex?: boolean | undefined | null): void
  /**
   * Resolve the setup of a new git submodule.
   *
   * This should be called on a submodule once you have called add setup and
   * done the clone of the submodule. This adds the `.gitmodules` file and the
   * newly cloned submodule to the index to be ready to be committed (but
   * doesn't actually do the commit).
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   addFinalize(): void;
   * }
   * ```
   */
  addFinalize(): void
  /**
   * Update submodule.
   *
   * This will clone a missing submodule and check out the subrepository to
   * the commit specified in the index of the containing repository. If
   * the submodule repository doesn't contain the target commit, then the
   * submodule is fetched using the fetch options supplied in options.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   update(
   *     init?: boolean | null | undefined,
   *     options?: SubmoduleUpdateOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {boolean} [init] - Indicates if the submodule should be initialized first if it has
   * not been initialized yet.
   * @param {SubmoduleUpdateOptions} [options] - Configuration options for the update.
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   */
  update(init?: boolean | undefined | null, options?: SubmoduleUpdateOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Perform the clone step for a newly created submodule.
   *
   * This performs the necessary `git clone` to setup a newly-created submodule.
   *
   * @category Submodule/Methods
   * @signature
   * ```ts
   * class Submodule {
   *   clone(
   *     options?: SubmoduleUpdateOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<Repository>;
   * }
   * ```
   *
   * @param {SubmoduleUpdateOptions} [options] - The options to use.
   * @param {AbortSignal} [signal] - Optional AbortSignal to cancel the operation.
   * @returns The newly created repository object.
   */
  clone(options?: SubmoduleUpdateOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>
}

/**
 * A class to represent a git [tag][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Basics-Tagging
 */
export declare class Tag {
  /**
   * Get the id (SHA1) of a repository tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of this tag.
   */
  id(): string
  /**
   * Get the message of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   message(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if there is no message or if it is not valid utf8.
   */
  message(): string | null
  /**
   * Get the name of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   name(): string;
   * }
   * ```
   *
   * @returns Name of tag.
   * @throws Throws error if it is not valid utf8.
   */
  name(): string
  /**
   * Recursively peel a tag until a non tag Git object is found.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   peel(): GitObject;
   * }
   * ```
   *
   * @returns Git object for this tag.
   */
  peel(): GitObject
  /**
   * Get the tagger (author) of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   tagger(): Signature | null;
   * }
   * ```
   *
   * @returns If the author is unspecified, then `null` is returned.
   */
  tagger(): Signature | null
  /**
   * Get the tagged object of a tag.
   *
   * This method performs a repository lookup for the given object and
   * returns it.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   target(): GitObject;
   * }
   * ```
   *
   * @returns Tagged git object of a tag.
   */
  target(): GitObject
  /**
   * Get the OID of the tagged object of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   targetId(): string;
   * }
   * ```
   *
   * @returns OID of the tagged object of a tag.
   */
  targetId(): string
  /**
   * Get the ObjectType of the tagged object of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   targetType(): ObjectType | null;
   * }
   * ```
   *
   * @returns ObjectType of the tagged object of a tag.
   */
  targetType(): ObjectType | null
}

/**
 * A class to represent a git [tree][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Tree {
  /**
   * Get the id (SHA1) of a repository object.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository object.
   */
  id(): string
  /**
   * Get the number of entries listed in this tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   len(): bigint;
   * }
   * ```
   *
   * @returns The number of entries listed in this tree.
   */
  len(): bigint
  /**
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` if there is no entry.
   */
  isEmpty(): boolean
  /**
   * Returns an iterator over the entries in this tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   iter(): TreeIter;
   * }
   * ```
   *
   * @returns An iterator over the entries in this tree.
   */
  iter(): TreeIter
  /**
   * Traverse the entries in a tree and its subtrees in post or pre-order.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   walk(mode: TreeWalkMode, callback: (entry: TreeEntry) => number): void;
   * }
   * ```
   *
   * @param {TreeWalkMode} mode - A indicator of whether a tree walk should be performed
   * in pre-order or post-order.
   *
   * @param {(entry: TreeEntry) => number} callback - The callback function will be run on
   * each node of the tree that's walked. The return code of this function will determine
   * how the walk continues.
   * `libgit2` requires that the callback be an integer, where 0 indicates a successful visit,
   * 1 skips the node, and -1 aborts the traversal completely.
   */
  walk(mode: TreeWalkMode, callback: (entry: TreeEntry) => number): void
  /**
   * Lookup a tree entry by SHA value.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getId(id: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} id - SHA value.
   *
   * @returns Tree entry with the given ID(SHA1).
   */
  getId(id: string): TreeEntry | null
  /**
   * Lookup a tree entry by its position in the tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   get(index: number): TreeEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of tree entry.
   *
   * @returns Tree entry.
   */
  get(index: number): TreeEntry | null
  /**
   * Lookup a tree entry by its filename.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getName(filename: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} filename - Filename of tree entry.
   *
   * @returns Tree entry.
   */
  getName(filename: string): TreeEntry | null
  /**
   * Retrieve a tree entry contained in a tree or in any of its subtrees,
   * given its relative path.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getPath(path: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} path - Relative path to tree entry.
   *
   * @returns Tree entry.
   */
  getPath(path: string): TreeEntry | null
  /**
   * Casts this Tree to be usable as an `GitObject`.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   asObject(): GitObject;
   * }
   * ```
   *
   * @returns Git object.
   */
  asObject(): GitObject
}

/**
 * A class representing an entry inside of a tree. An entry is borrowed
 * from a tree.
 */
export declare class TreeEntry {
  /**
   * Get the id of the object pointed by the entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID of the object pointed by the entry.
   */
  id(): string
  /**
   * Get the filename of a tree entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   name(): string;
   * }
   * ```
   *
   * @returns The filename of a tree entry.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string
  /**
   * Get the type of the object pointed by the entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   type(): ObjectType | null;
   * }
   * ```
   *
   * @returns The type of the object pointed by the entry.
   */
  type(): ObjectType | null
  /**
   * Get the UNIX file attributes of a tree entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   filemode(): number;
   * }
   * ```
   *
   * @returns UNIX file attributes of a tree entry.
   */
  filemode(): number
  /**
   * Convert a tree entry to the object it points to.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   toObject(repo: Repository): GitObject;
   * }
   * ```
   *
   * @param {Repository} repo - Repository which this tree entry belongs to.
   * @returns Git object that pointed by the entry.
   */
  toObject(repo: Repository): GitObject
}

/**
 * An iterator over the entries in a tree.
 *
 * This type extends JavaScript's `Iterator`, and so has the iterator helper
 * methods. It may extend the upcoming TypeScript `Iterator` class in the future.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator#iterator_helper_methods
 * @see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-6.html#iterator-helper-methods
 */
export declare class TreeIter extends Iterator<TreeEntry, void, void> {

  next(value?: void): IteratorResult<TreeEntry, void>
}

export interface AddMailmapEntryData {
  realName?: string
  realEmail?: string
  replaceName?: string
  replaceEmail: string
}

export interface AmendOptions {
  /**
   * If not NULL, name of the reference that will be updated to point to this commit.
   * If the reference is not direct, it will be resolved to a direct reference.
   * Use "HEAD" to update the HEAD of the current branch and make it point to this commit.
   *
   * If the reference doesn't exist yet, it will be created.
   * If it does exist, the first parent must be the tip of this branch.
   */
  updateRef?: string
  /** Signature for author. */
  author?: SignaturePayload
  /** Signature for committer. */
  committer?: SignaturePayload
  /** Full message for this commit */
  message?: string
  /**
   * The encoding for the message in the commit, represented with a standard encoding name.
   * E.g. "UTF-8".
   * If NULL, no encoding header is written and UTF-8 is assumed.
   */
  messageEncoding?: string
}

/**
 * Possible application locations for git_apply
 * see <https://libgit2.org/libgit2/#HEAD/type/git_apply_options>
 */
export type ApplyLocation = /** Apply the patch to the workdir */
'WorkDir'|
/** Apply the patch to the index */
'Index'|
/** Apply the patch to both the working directory and the index */
'Both';

/** Options to specify when applying a diff */
export interface ApplyOptions {
  /** Don't actually make changes, just test that the patch applies. */
  check?: boolean
}

export interface AttrOptions {
  /** Check the working directory, then the index. */
  checkFileThenIndex?: boolean
  /** Check the index, then the working directory. */
  checkIndexThenFile?: boolean
  /** Check the index only. */
  checkIndexOnly?: boolean
  /** Do not use the system gitattributes file. */
  checkNoSystem?: boolean
}

/**
 * - `Unspecified` : Use the setting from the remote's configuration
 * - `Auto` : Ask the server for tags pointing to objects we're already downloading
 * - `None` : Don't ask for any tags beyond the refspecs
 * - `All` : Ask for all the tags
 */
export type AutotagOption =  'Unspecified'|
'Auto'|
'None'|
'All';

/**
 * Represents a hunk of a blame operation, which is a range of lines
 * and information about who last modified them.
 */
export interface BlameHunk {
  /** The oid of the commit where this line was last changed. */
  finalCommitId: string
  /** The 1-based line number in the final file where this hunk starts. */
  finalStartLineNumber: number
  /** The number of lines in this hunk. */
  linesInHunk: number
  /** The signature of the commit where this line was last changed. */
  finalSignature?: Signature
  /** The path to the file where this line was originally written. */
  path?: string
  /** The 1-based line number in the original file where this hunk starts. */
  origStartLineNumber: number
  /** The oid of the commit where this line was originally written. */
  origCommitId: string
  /** The signature of the commit where this line was originally written. */
  origSignature?: Signature
  /**
   * True if the hunk has been determined to be a boundary commit (the commit
   * when the file was first introduced to the repository).
   */
  isBoundary: boolean
}

/** Options for controlling blame behavior */
export interface BlameOptions {
  /** The minimum line number to blame (1-based index) */
  minLine?: number
  /** The maximum line number to blame (1-based index) */
  maxLine?: number
  /**
   * The oid of the newest commit to consider. The blame algorithm will stop
   * when this commit is reached.
   */
  newestCommit?: string
  /**
   * The oid of the oldest commit to consider. The blame algorithm will
   * stop when this commit is reached.
   */
  oldestCommit?: string
  /**
   * The path to the file being worked on. Path has to be relative to the
   * repo root.
   */
  path?: string
  /**
   * Track lines that have moved within a file. This is the git-blame -M
   * option.
   */
  trackLinesMovement?: boolean
  /** Restrict search to commits reachable following only first parents. */
  firstParent?: boolean
  /** Ignore whitespace differences. */
  ignoreWhitespace?: boolean
  /** Track lines that have been copied from another file that exists in any commit. */
  trackCopiesAnyCommitCopies?: boolean
  /** Track lines that have been copied from another file that exists in the same commit. */
  trackCopiesSameCommitCopies?: boolean
  /** Track lines that have moved across files in the same commit. */
  trackCopiesSameCommitMoves?: boolean
  /** Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. */
  useMailmap?: boolean
}

export interface BranchesFilter {
  /** Branch type to filter. */
  type?: BranchType
}

export interface BranchesItem {
  type: BranchType
  name: string
}

export interface BranchRenameOptions {
  /**
   * If the force flag is not enabled, and there's already a branch with
   * the given name, the renaming will fail.
   */
  force?: boolean
}

/**
 * - `Local` : A local branch not on a remote.
 * - `Remote` : A branch for a remote.
 */
export type BranchType =  'Local'|
'Remote';

export interface CheckoutOptions {
  /**
   * Indicate that this checkout should perform a dry run by checking for
   * conflicts but not make any actual changes.
   */
  dryRun?: boolean
  /**
   * Take any action necessary to get the working directory to match the
   * target including potentially discarding modified files.
   */
  force?: boolean
  /**
   * Indicate that the checkout should be performed safely, allowing new
   * files to be created but not overwriting existing files or changes.
   *
   * This is the default.
   */
  safe?: boolean
  /**
   * In safe mode, create files that don't exist.
   *
   * Defaults to false.
   */
  recreateMissing?: boolean
  /**
   * In safe mode, apply safe file updates even when there are conflicts
   * instead of canceling the checkout.
   *
   * Defaults to false.
   */
  allowConflicts?: boolean
  /**
   * Remove untracked files from the working dir.
   *
   * Defaults to false.
   */
  removeUntracked?: boolean
  /**
   * Remove ignored files from the working dir.
   *
   * Defaults to false.
   */
  removeIgnored?: boolean
  /**
   * Only update the contents of files that already exist.
   *
   * If set, files will not be created or deleted.
   *
   * Defaults to false.
   */
  updateOnly?: boolean
  /**
   * Prevents checkout from writing the updated files' information to the
   * index.
   *
   * Defaults to true.
   */
  updateIndex?: boolean
  /**
   * Indicate whether the index and git attributes should be refreshed from
   * disk before any operations.
   *
   * Defaults to true,
   */
  refresh?: boolean
  /**
   * Skip files with unmerged index entries.
   *
   * Defaults to false.
   */
  skipUnmerged?: boolean
  /**
   * Indicate whether the checkout should proceed on conflicts by using the
   * stage 2 version of the file ("ours").
   *
   * Defaults to false.
   */
  useOurs?: boolean
  /**
   * Indicate whether the checkout should proceed on conflicts by using the
   * stage 3 version of the file ("theirs").
   *
   * Defaults to false.
   */
  useTheirs?: boolean
  /**
   * Indicate whether ignored files should be overwritten during the checkout.
   *
   * Defaults to true.
   */
  overwriteIgnored?: boolean
  /**
   * Indicate whether a normal merge file should be written for conflicts.
   *
   * Defaults to false.
   */
  conflictStyleMerge?: boolean
  /**
   * Indicates whether to include common ancestor data in diff3 format files
   * for conflicts.
   *
   * Defaults to false.
   */
  conflictStyleDiff3?: boolean
  /**
   * Treat paths specified in `path` as exact file paths
   * instead of as pathspecs.
   */
  disablePathspecMatch?: boolean
  /** Indicate whether to apply filters like CRLF conversion. */
  disableFilters?: boolean
  /**
   * Set the mode with which new directories are created.
   *
   * Default is 0755
   */
  dirPerm?: number
  /**
   * Set the mode with which new files are created.
   *
   * The default is 0644 or 0755 as dictated by the blob.
   */
  filePerm?: number
  /**
   * Add a path to be checked out.
   *
   * The path is a [pathspec](https://git-scm.com/docs/gitglossary.html#Documentation/gitglossary.txt-aiddefpathspecapathspec) pattern, unless
   * `disablePathspecMatch` is set.
   *
   * If no paths are specified, then all files are checked out. Otherwise
   * only these specified paths are checked out.
   */
  path?: string
  /** Set the directory to check out to */
  targetDir?: string
  /** The name of the common ancestor side of conflicts */
  ancestorLabel?: string
  /** The name of the common our side of conflicts */
  ourLabel?: string
  /** The name of the common their side of conflicts */
  theirLabel?: string
}

/** Options for cherrypick behavior. */
export interface CherrypickOptions {
  /**
   * Parent number for merge commits (1-based).
   *
   * When cherrypicking a merge commit, the mainline parent is the one you want to
   * cherrypick from. The mainline is the branch from which the merge was made.
   */
  mainline?: number
  /** Options for merge resolution when cherrypicking a merge commit. */
  mergeOptions?: MergeOptions
  /** Options for checkout behavior when updating working directory. */
  checkoutOptions?: CheckoutOptions
}

/**
 * Clone a remote repository.
 *
 * This will use the options configured so far to clone the specified URL
 * into the specified local path.
 *
 * @category Repository
 *
 * @signature
 * ```ts
 * function cloneRepository(
 *   url: string,
 *   path: string,
 *   options?: RepositoryCloneOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} url - Remote URL for repository.
 * @param {string} path - Local path to clone repository.
 * @param {RepositoryCloneOptions|undefined|null} [options] - Clone options for repository.
 * @param {AbortSignal|undefined|null} [signal] - Abort signal.
 * @returns Repository instance
 *
 * @example
 *
 * Clone repository using `https://` protocol.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * const repo = await cloneRepository(
 *   'https://github.com/toss/es-git',
 *   '/path/to/clone',
 * );
 * ```
 *
 * Clone repository using `git://` protocol.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * const repo = await cloneRepository(
 *   'git@github.com:toss/es-git',
 *   '/path/to/clone',
 * );
 * ```
 *
 * Clone repository with authentication.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * // Authenticate using ssh-agent
 * const repo = await cloneRepository('git@github.com:toss/es-git', '.', {
 *   fetch: {
 *     credential: {
 *       type: 'SSHKeyFromAgent',
 *     },
 *   },
 * });
 * ```
 */
export declare function cloneRepository(url: string, path: string, options?: RepositoryCloneOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>

export interface CommitOptions {
  updateRef?: string
  /**
   * Signature for author.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  author?: SignaturePayload
  /**
   * Signature for commiter.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  committer?: SignaturePayload
  parents?: Array<string>
  /**
   * GPG signature string for signed commits.
   *
   * If provided, this will create a signed commit.
   */
  signature?: string
  /**
   * Custom signature field name.
   *
   * If not provided, the default signature field (gpgsig) will be used.
   */
  signatureField?: string
}

export interface ConfigEntry {
  /** The name of this entry. */
  name: string
  /** The value of this entry. If no value is defined, the value will be `null`. */
  value?: string
  /** The configuration level of this entry. */
  level: ConfigLevel
  /** Depth of includes where this variable was found */
  includeDepth: number
}

/**
 * - `ProgramData` : System-wide on Windows, for compatibility with portable git.
 * - `System` : System-wide configuration file. (e.g. `/etc/gitconfig`)
 * - `XDG` : XDG-compatible configuration file. (e.g. `~/.config/git/config`)
 * - `Global` : User-specific configuration. (e.g. `~/.gitconfig`)
 * - `Local` : Repository specific config. (e.g. `$PWD/.git/config`)
 * - `Worktree` : Worktree specific configuration file. (e.g. `$GIT_DIR/config.worktree`)
 * - `App` : Application specific configuration file.
 * - `Highest` : Highest level available.
 */
export type ConfigLevel =  'ProgramData'|
'System'|
'XDG'|
'Global'|
'Local'|
'Worktree'|
'App'|
'Highest';

export interface CreateAnnotationTagOptions {
  /**
   * Signature for tagger.
   *
   * If not provided, default signature of repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  tagger?: SignaturePayload
}

export interface CreateBranchOptions {
  /**
   * If `force` is true and a reference already exists with the given name,
   * it'll be replaced.
   */
  force?: boolean
}

export interface CreateLightweightTagOptions {
  /** If `force` is true and a reference already exists with the given name, it'll be replaced. */
  force?: boolean
}

/**
 * Create a mailmap from the contents of a string.
 *
 * The format of the string should follow the rules of the mailmap file:
 * ```
 * # Comment line (ignored)
 * Seokju Me <seokju.me@toss.im> Seokju Na <seokju.me@gmail.com>
 * ```
 *
 * @param {string} content - Content of the mailmap file
 * @returns A new mailmap object
 * @throws An error if operation failed
 *
 * @category Mailmap
 *
 * @signature
 * ```ts
 * function createMailmapFromBuffer(content: string): Mailmap;
 * ```
 */
export declare function createMailmapFromBuffer(content: string): Mailmap

export interface CreateNoteOptions {
  /**
   * Signature of the notes commit author.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  author?: SignaturePayload
  /**
   * Signature of the notes commit commiter.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  committer?: SignaturePayload
  /**
   * canonical name of the reference to use.
   *
   * Defaults to "refs/notes/commits".
   */
  notesRef?: string
  /** Overwrite existing note. */
  force?: boolean
}

export interface CreateRemoteOptions {
  fetchRefspec?: string
}

/**
 * Create a new action signature.
 *
 * @category Signature
 * @signature
 * ```ts
 * function createSignature(
 *   name: string,
 *   email: string,
 *   timeOptions?: SignatureTimeOptions | null | undefined,
 * ): Signature;
 * ```
 *
 * @param {string} name - Name on the signature.
 * @param {string} email - Email on the signature.
 * @param {SignatureTimeOptions} [timeOptions] - Time options for signature.
 *
 * @returns
 *
 * @example
 * ```ts
 * import { createSignature } from 'es-git';
 *
 * const author = createSignature(
 *   'Seokju Na',
 *   'seokju.me@toss.im',
 * );
 * ```
 */
export declare function createSignature(name: string, email: string, timeOptions?: SignatureTimeOptions | undefined | null): Signature

export interface CreateTagOptions {
  /**
   * Signature for tagger.
   *
   * If not provided, default signature of repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  tagger?: SignaturePayload
  /** If `force` is true and a reference already exists with the given name, it'll be replaced. */
  force?: boolean
}

/** A interface to represent git credentials in libgit2. */
export type Credential = {
 type: 'Default';
} | {
 type: 'SSHKeyFromAgent';
 username?: string;
} | {
 type: 'SSHKeyFromPath';
 username?: string;
 publicKeyPath?: string;
 privateKeyPath: string;
 passphrase?: string;
} | {
 type: 'SSHKey';
 username?: string;
 publicKey?: string;
 privateKey: string;
 passphrase?: string;
} | {
 type: 'Plain';
 username?: string;
 password: string;
};

export type CredentialType =  'Default'|
'SSHKeyFromAgent'|
'SSHKeyFromPath'|
'SSHKey'|
'Plain';

export interface DeleteNoteOptions {
  /**
   * Signature of the notes commit author.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  author?: SignaturePayload
  /**
   * Signature of the notes commit commiter.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  committer?: SignaturePayload
  /**
   * canonical name of the reference to use.
   *
   * Defaults to "refs/notes/commits".
   */
  notesRef?: string
}

/**
 * - `Unmodified` : No changes.
 * - `Added` : Entry does not exist in an old version.
 * - `Deleted` : Entry does not exist in a new version.
 * - `Modified` : Entry content changed between old and new.
 * - `Renamed` : Entry was renamed between old and new.
 * - `Copied` : Entry was copied from another old entry.
 * - `Ignored` : Entry is ignored item in workdir.
 * - `Untracked` : Entry is untracked item in workdir.
 * - `Typechange` : Type of entry changed between old and new.
 * - `Unreadable` : Entry is unreadable.
 * - `Conflicted` : Entry in the index is conflicted.
 */
export type DeltaType =  'Unmodified'|
'Added'|
'Deleted'|
'Modified'|
'Renamed'|
'Copied'|
'Ignored'|
'Untracked'|
'Typechange'|
'Unreadable'|
'Conflicted';

export interface DescribeFormatOptions {
  /**
   * Sets the size of the abbreviated commit id to use.
   *
   * The value is the lower bound for the length of the abbreviated string,
   * and the default is 7.
   */
  abbreviatedSize?: number
  /**
   * Sets whether or not the long format is used even when a shorter name
   * could be used.
   */
  alwaysUseLongFormat?: boolean
  /**
   * If the workdir is dirty and this is set, this string will be appended to
   * the description string.
   */
  dirtySuffix?: string
}

export interface DescribeOptions {
  maxCandidatesTags?: number
  /**
   * Sets the reference lookup strategy
   *
   * This behaves like the `--tags` option to git-describe.
   */
  describeTags?: boolean
  /**
   * Sets the reference lookup strategy
   *
   * This behaves like the `--all` option to git-describe.
   */
  describeAll?: boolean
  /**
   * Indicates when calculating the distance from the matching tag or
   * reference whether to only walk down the first-parent ancestry.
   */
  onlyFollowFirstParent?: boolean
  /**
   * If no matching tag or reference is found whether a describe option would
   * normally fail. This option indicates, however, that it will instead fall
   * back to showing the full id of the commit.
   */
  showCommitOidAsFallback?: boolean
  pattern?: string
}

export interface DiffFindOptions {
  /** Look for renames? */
  renames?: boolean
  /** Consider old side of modified for renames? */
  renamesFromRewrites?: boolean
  /** Look for copies? */
  copies?: boolean
  /**
   * Consider unmodified as copy sources?
   *
   * For this to work correctly, use `includeUnmodified` when the initial
   * diff is being generated.
   */
  copiesFromUnmodified?: boolean
  /** Mark significant rewrites for split. */
  rewrites?: boolean
  /** Actually split large rewrites into delete/add pairs */
  breakRewrites?: boolean
  /**
   * Find renames/copies for untracked items in working directory.
   *
   * For this to work correctly use the `includeUntracked` option when the
   * initial diff is being generated.
   */
  forUntracked?: boolean
  /** Turn on all finding features. */
  all?: boolean
  /** Measure similarity ignoring leading whitespace (default) */
  ignoreLeadingWhitespace?: boolean
  /** Measure similarity ignoring all whitespace */
  ignoreWhitespace?: boolean
  /** Measure similarity including all data */
  dontIgnoreWhitespace?: boolean
  /** Measure similarity only by comparing SHAs (fast and cheap) */
  exactMatchOnly?: boolean
  /**
   * Do not break rewrites unless they contribute to a rename.
   *
   * Normally, `breakRewrites` and `rewrites` will measure the
   * self-similarity of modified files and split the ones that have changed a
   * lot into a delete/add pair. Then the sides of that pair will be
   * considered candidates for rename and copy detection
   *
   * If you add this flag in and the split pair is not used for an actual
   * rename or copy, then the modified record will be restored to a regular
   * modified record instead of being split.
   */
  breakRewritesForRenamesOnly?: boolean
  /**
   * Remove any unmodified deltas after find_similar is done.
   *
   * Using `copiesFromUnmodified` to emulate the `--find-copies-harder`
   * behavior requires building a diff with the `includeUnmodified` flag. If
   * you do not want unmodified records in the final result, pas this flag to
   * have them removed.
   */
  removeUnmodified?: boolean
  /** Similarity to consider a file renamed (default 50) */
  renameThreshold?: number
  /** Similarity of modified to be eligible rename source (default 50) */
  renameFromRewriteThreshold?: number
  /** Similarity to consider a file copy (default 50) */
  copyThreshold?: number
  /** Similarity to split modify into delete/add pair (default 60) */
  breakRewriteThreshold?: number
  /**
   * Maximum similarity sources to examine for a file (somewhat like
   * git-diff's `-l` option or `diff.renameLimit` config)
   *
   * Defaults to 200
   */
  renameLimit?: number
}

/**
 * - `DiffFlags.Binary` : File(s) treated as binary data.
 * - `DiffFlags.NotBinary` : File(s) treated as text data.
 * - `DiffFlags.ValidId` : `id` value is known correct.
 * - `DiffFlags.Exists` : File exists at this side of the delta.
 */
export declare enum DiffFlags {
  Binary = 1,
  NotBinary = 2,
  ValidId = 4,
  Exists = 8
}

/**
 * Check diff flags contains given flags.
 *
 * @category Diff
 * @signature
 * ```ts
 * function diffFlagsContains(source: number, target: number): boolean;
 * ```
 *
 * @param {number} source - Source flags.
 * @param {number} target - Target flags.
 * @returns Returns `true` is source flags contains target flags.
 *
 * @example
 * ```ts
 * import { DiffDelta, DiffFlags, diffFlagsContains } from 'es-git';
 *
 * const delta: DiffDelta;
 * console.assert(diffFlagsContains(delta.flags(), DiffFlags.Binary | DiffFlags.ValidId));
 * ```
 */
export declare function diffFlagsContains(source: number, target: number): boolean

/**
 * Possible output formats for diff data.
 *
 * - `Patch`: Full `git diff` (default)
 * - `PatchHeader` : Just the headers of the patch
 * - `Raw` : Like `git diff --raw` the headers of the patch
 * - `NameOnly` : Like `git diff --name-only`
 * - `NameStatus` : Like `git diff --name-status`
 * - `PatchId` : `git diff` as used by `git patch-id`
 */
export type DiffFormat =  'Patch'|
'PatchHeader'|
'Raw'|
'NameOnly'|
'NameStatus'|
'PatchId';

export interface DiffOptions {
  /** Flag indicating whether the sides of the diff will be reversed. */
  reverse?: boolean
  /** Flag indicating whether ignored files are included. */
  includeIgnored?: boolean
  /** Flag indicating whether ignored directories are traversed deeply or not. */
  recurseIgnoredDirs?: boolean
  /** Flag indicating whether untracked files are in the diff */
  includeUntracked?: boolean
  /**
   * Flag indicating whether untracked directories are traversed deeply or
   * not.
   */
  recurseUntrackedDirs?: boolean
  /** Flag indicating whether unmodified files are in the diff. */
  includeUnmodified?: boolean
  /** If enabled, then Typechange delta records are generated. */
  includeTypechange?: boolean
  /**
   * Event with `includeTypechange`, the tree returned generally shows a
   * deleted blob. This flag correctly labels the tree transitions as a
   * typechange record with the `newFile`'s mode set to tree.
   *
   * Note that the tree SHA will not be available.
   */
  includeTypechangeTrees?: boolean
  /** Flag indicating whether file mode changes are ignored. */
  ignoreFilemode?: boolean
  /** Flag indicating whether all submodules should be treated as unmodified. */
  ignoreSubmodules?: boolean
  /** Flag indicating whether case insensitive filenames should be used. */
  ignoreCase?: boolean
  /**
   * If pathspecs are specified, this flag means that they should be applied
   * as an exact match instead of a fnmatch pattern.
   */
  disablePathspecMatch?: boolean
  /**
   * Disable updating the `binary` flag in delta records. This is useful when
   * iterating over a diff if you don't need hunk and data callbacks and want
   * to avoid having to load a file completely.
   */
  skipBinaryCheck?: boolean
  /**
   * When diff finds an untracked directory, to match the behavior of core
   * Git, it scans the contents for ignored and untracked files. If all
   * contents are ignored, then the directory is ignored; if any contents are
   * not ignored, then the directory is untracked. This is extra work that
   * may not matter in many cases.
   *
   * This flag turns off that scan and immediately labels an untracked
   * directory as untracked (changing the behavior to not match core git).
   */
  enableFastUntrackedDirs?: boolean
  /**
   * When diff finds a file in the working directory with stat information
   * different from the index, but the OID ends up being the same, write the
   * correct stat information into the index. Note: without this flag, diff
   * will always leave the index untouched.
   */
  updateIndex?: boolean
  /** Include unreadable files in the diff */
  includeUnreadable?: boolean
  /** Include unreadable files in the diff as untracked files */
  includeUnreadableAsUntracked?: boolean
  /** Treat all files as text, disabling binary attributes and detection. */
  forceText?: boolean
  /** Treat all files as binary, disabling text diffs */
  forceBinary?: boolean
  /** Ignore all whitespace */
  ignoreWhitespace?: boolean
  /** Ignore changes in the amount of whitespace */
  ignoreWhitespaceChange?: boolean
  /** Ignore whitespace at the end of line */
  ignoreWhitespaceEol?: boolean
  /** Ignore blank lines */
  ignoreBlankLines?: boolean
  /**
   * When generating patch text, include the content of untracked files.
   *
   * This automatically turns on `includeUntracked` but it does not turn on
   * `recurseUntrackedDirs`. Add that flag if you want the content of every
   * single untracked file.
   */
  showUntrackedContent?: boolean
  /**
   * When generating output, include the names of unmodified files if they
   * are included in the `Diff`. Normally these are skipped in the formats
   * that list files (e.g. name-only, name-status, raw). Even with this these
   * will not be included in the patch format.
   */
  showUnmodified?: boolean
  /** Use the "patience diff" algorithm */
  patience?: boolean
  /** Take extra time to find the minimal diff */
  minimal?: boolean
  /**
   * Include the necessary deflate/delta information so that `git-apply` can
   * apply given diff information to binary files.
   */
  showBinary?: boolean
  /**
   * Use a heuristic that takes indentation and whitespace into account
   * which generally can produce better diffs when dealing with ambiguous
   * diff hunks.
   */
  indentHeuristic?: boolean
  /**
   * Set the number of unchanged lines that define the boundary of a hunk
   * (and to display before and after).
   *
   * The default value for this is 3.
   */
  contextLines?: number
  /**
   * Set the maximum number of unchanged lines between hunk boundaries before
   * the hunks will be merged into one.
   *
   * The default value for this is 0.
   */
  interhunkLines?: number
  /** The default value for this is `core.abbrev` or 7 if unset. */
  idAbbrev?: number
  /**
   * Maximum size (in bytes) above which a blob will be marked as binary
   * automatically.
   *
   * A negative value will disable this entirely.
   *
   * The default value for this is 512MB.
   */
  maxSize?: number
  /**
   * The virtual "directory" to prefix old file names with in hunk headers.
   *
   * The default value for this is "a".
   */
  oldPrefix?: string
  /**
   * The virtual "directory" to prefix new file names with in hunk headers.
   *
   * The default value for this is "b".
   */
  newPrefix?: string
  /** Add to the array of paths/fnmatch patterns to constrain the diff. */
  pathspecs?: Array<string>
}

export interface DiffPrintOptions {
  format?: DiffFormat
}

/**
 * - `Fetch` : Fetch direction.
 * - `Push` : Push direction.
 */
export type Direction =  'Fetch'|
'Push';

/**
 * Attempt to open an already-existing repository at or above `path`.
 *
 * This starts at `path` and looks up the filesystem hierarchy
 * until it finds a repository.
 *
 * @category Repository
 * @signature
 * ```ts
 * function discoverRepository(path: string, signal?: AbortSignal | null | undefined): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to discover repository.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns Git repository.
 */
export declare function discoverRepository(path: string, signal?: AbortSignal | undefined | null): Promise<Repository>

export interface ExtractedSignature {
  /** GPG signature of the commit, or null if the commit is not signed. */
  signature: string
  /** Signed data of the commit. */
  signedData: string
}

export interface FetchOptions {
  credential?: Credential
  /** Set the proxy options to use for the fetch operation. */
  proxy?: ProxyOptions
  /** Set whether to perform a prune after the fetch. */
  prune?: FetchPrune
  /**
   * Set fetch depth, a value less or equal to 0 is interpreted as pull
   * everything (effectively the same as not declaring a limit depth).
   */
  depth?: number
  /**
   * Set how to behave regarding tags on the remote, such as auto-downloading
   * tags for objects we're downloading or downloading all of them.
   *
   * The default is to auto-follow tags.
   */
  downloadTags?: AutotagOption
  /**
   * Set remote redirection settings; whether redirects to another host are
   * permitted.
   *
   * By default, git will follow a redirect on the initial request
   * (`/info/refs`), but not subsequent requests.
   */
  followRedirects?: RemoteRedirect
  /** Set extra headers for this fetch operation. */
  customHeaders?: Array<string>
}

/**
 * - `Unspecified` : Use the setting from the configuration.
 * - `On` : Force pruning on.
 * - `Off` : Force pruning off
 */
export type FetchPrune =  'Unspecified'|
'On'|
'Off';

export interface FetchRemoteOptions {
  /** Options which can be specified to various fetch operations. */
  fetch?: FetchOptions
  reflogMsg?: string
}

export type FileFavor = /**
 * When a region of a file is changed in both branches| a conflict will be
 * recorded in the index so that git_checkout can produce a merge file with
 * conflict markers in the working directory. This is the default.
 */
'Normal'|
/**
 * When a region of a file is changed in both branches| the file created
 * in the index will contain the "ours" side of any conflicting region.
 * The index will not record a conflict.
 */
'Ours'|
/**
 * When a region of a file is changed in both branches| the file created
 * in the index will contain the "theirs" side of any conflicting region.
 * The index will not record a conflict.
 */
'Theirs'|
/**
 * When a region of a file is changed in both branches| the file created
 * in the index will contain each unique line from each side| which has
 * the result of combining both files. The index will not record a conflict.
 */
'Union';

/** Valid modes for index and tree entries. */
export type FileMode =  'Unreadable'|
'Tree'|
'Blob'|
'BlobGroupWritable'|
'BlobExecutable'|
'Link'|
'Commit';

/**
 * Locate the path to the global configuration file.
 *
 * The user or global configuration file is usually located in
 * `$HOME/.gitconfig`.
 *
 * This method will try to guess the full path to that file, if the file
 * exists. The returned path may be used on any method call to load
 * the global configuration file.
 *
 * This method will not guess the path to the XDG compatible config file
 * (`.config/git/config`).
 *
 * @category Config
 * @signature
 * ```ts
 * function findGlobalConfigPath(): string | null;
 * ```
 *
 * @returns The path to the global configuration file.
 */
export declare function findGlobalConfigPath(): string | null

export interface FindNoteOptions {
  notesRef?: string
}

/**
 * Locate the path to the system configuration file.
 *
 * If `/etc/gitconfig` doesn't exist, it will look for `%PROGRAMFILES%`.
 *
 * @category Config
 * @signature
 * ```ts
 * function findSystemConfigPath(): string | null;
 * ```
 *
 * @returns The path to the system configuration file.
 */
export declare function findSystemConfigPath(): string | null

/**
 * Locate the path to the global XDG compatible configuration file.
 *
 * The XDG compatible configuration file is usually located in
 * `$HOME/.config/git/config`.
 *
 * @category Config
 * @signature
 * ```ts
 * function findXdgConfigPath(): string | null;
 * ```
 *
 * @returns The path to the XDG compatible configuration file.
 */
export declare function findXdgConfigPath(): string | null

/**
 * Hashes the content of the provided file as an object of the provided type,
 * and returns an Oid corresponding to the result. This does not store the object
 * inside any object database or repository.
 *
 * @category Oid
 * @signature
 * ```ts
 * function hashFileOid(objType: ObjectType, path: string): string;
 * ```
 *
 * @param {ObjectType} objType - Git object type.
 * @param {string} path - File path to make hash.
 * @returns Hashed string.
 */
export declare function hashFileOid(objType: ObjectType, path: string): string

/**
 * Hashes the provided data as an object of the provided type, and returns
 * an Oid corresponding to the result. This does not store the object
 * inside any object database or repository.
 *
 * @category Oid
 * @signature
 * ```ts
 * function hashObjectOid(objType: ObjectType, bytes: Buffer): string;
 * ```
 *
 * @param {ObjectType} objType - Git object type.
 * @param {Buffer} bytes - Data to hashed.
 * @returns Hashed string.
 */
export declare function hashObjectOid(objType: ObjectType, bytes: Buffer): string

export interface IndexAddAllOptions {
  /**
   * Files that are ignored will be skipped (unlike `addPath`). If a file is
   * already tracked in the index, then it will be updated even if it is
   * ignored. Pass the `force` flag to skip the checking of ignore rules.
   */
  force?: boolean
  /**
   * The `pathspecs` are a list of file names or shell glob patterns that
   * will matched against files in the repository's working directory. Each
   * file that matches will be added to the index (either updating an
   * existing entry or adding a new entry). You can disable glob expansion
   * and force exact matching with the `disablePathspecMatch` flag.
   */
  disablePathspecMatch?: boolean
  /**
   * To emulate `git add -A` and generate an error if the pathspec contains
   * the exact path of an ignored file (when not using `force`), add the
   * `checkPathspec` flag. This checks that each entry in `pathspecs`
   * that is an exact match to a filename on disk is either not ignored or
   * already in the index. If this check fails, the function will return
   * an error.
   */
  checkPathspec?: boolean
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the working directory immediately before it is added to /
   * updated in the index. Returning zero will add the item to the index,
   * greater than zero will skip the item, and less than zero will abort the
   * scan an return an error to the caller.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}

export interface IndexEntry {
  ctime: Date
  mtime: Date
  dev: number
  ino: number
  mode: number
  uid: number
  gid: number
  fileSize: number
  id: string
  flags: number
  flagsExtended: number
  /**
   * The path of this index entry as a byte vector. Regardless of the
   * current platform, the directory separator is an ASCII forward slash
   * (`0x2F`). There are no terminating or internal NUL characters, and no
   * trailing slashes. Most of the time, paths will be valid utf-8  but
   * not always. For more information on the path storage format, see
   * [these git docs](https://github.com/git/git/blob/a08a83db2bf27f015bec9a435f6d73e223c21c5e/Documentation/technical/index-format.txt#L107-L124).
   * Note that libgit2 will take care of handling the prefix compression mentioned there.
   */
  path: Buffer
}

export interface IndexOnMatchCallbackArgs {
  /** The path of entry. */
  path: string
  /** The patchspec that matched it. */
  pathspec: string
}

export interface IndexRemoveAllOptions {
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the index immediately before it is removed. Return 0 to remove
   * the item, > 0 to skip the item, and < 0 to abort the scan.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}

export interface IndexRemoveOptions {
  stage?: IndexStage
}

/**
 * - `Any` : Match any index stage.
 * - `Normal` : A normal staged file in the index.
 * - `Ancestor` : The ancestor side of a conflict.
 * - `Ours` : The "ours" side of a conflict.
 * - `Theirs` : The "theirs" side of a conflict.
 */
export type IndexStage =  'Any'|
'Normal'|
'Ancestor'|
'Ours'|
'Theirs';

export interface IndexUpdateAllOptions {
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the index immediately before it is updated (either refreshed or
   * removed depending on working directory state). Return 0 to proceed with
   * updating the item, > 0 to skip the item, and < 0 to abort the scan.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}

/**
 * Creates a new repository in the specified folder.
 *
 * @category Repository
 * @signature
 * ```ts
 * function initRepository(
 *   path: string,
 *   options?: RepositoryInitOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined,
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to create new repository.
 * @param {RepositoryInitOptions} [options] - Options which can be used to configure
 * how a repository is initialized.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns A new repository.
 *
 * @example
 *
 * Basic example.
 *
 * ```ts
 * import { initRepository } from 'es-git';
 *
 * const repo = await initRepository('/path/to/repo');
 * ```
 *
 * Create bare repository.
 *
 * ```ts
 * import { initRepository } from 'es-git';
 *
 * const repo = await initRepository('/path/to/repo.git', {
 *   bare: true,
 * });
 * ```
 */
export declare function initRepository(path: string, options?: RepositoryInitOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>

/**
 * Ensure the branch name is well-formed.
 *
 * @category Branch
 * @signature
 * ```ts
 * function isValidBranchName(name: string): boolean;
 * ```
 *
 * @param {string} name - Branch name to check is valid.
 * @returns Returns `true` if the given branch name is well-formed.
 */
export declare function isValidBranchName(name: string): boolean

/**
 * Check if given string is valid Oid.
 *
 * @category Oid
 * @signature
 * ```ts
 * function isValidOid(value: string): boolean;
 * ```
 *
 * @param {string} value - String to check if is valid Oid.
 * @returns Returns `false` if the string is empty, is longer than 40 hex
 * characters, or contains any non-hex characters.
 */
export declare function isValidOid(value: string): boolean

/**
 * Ensure the reference name is well-formed.
 *
 * Validation is performed as if `ReferenceFormat.AllowOnelevel`
 * was given to `normalizeReferenceName`  No normalization is performed, however.
 *
 * @category Reference
 * @signature
 * ```ts
 * function isValidReferenceName(refname: string): boolean;
 * ```
 *
 * @param {string} refname - Reference name to check if it is valid.
 * @returns Returns `true` if reference name is valid.
 *
 * @example
 * ```ts
 * import { isValidReferenceName } from 'es-git';
 *
 * console.assert(isValidReferenceName("HEAD"));
 * console.assert(isValidReferenceName("refs/heads/main"));
 *
 * // But:
 * console.assert(!isValidReferenceName("main"));
 * console.assert(!isValidReferenceName("refs/heads/*"));
 * console.assert(!isValidReferenceName("foo//bar"));
 * ```
 */
export declare function isValidReferenceName(refname: string): boolean

/**
 * Determine whether a tag name is valid, meaning that (when prefixed with refs/tags/) that
 * it is a valid reference name, and that any additional tag name restrictions are imposed
 * (eg, it cannot start with a -).
 *
 * @category Tag
 * @signature
 * ```ts
 * function isValidTagName(tagName: string): boolean;
 * ```
 *
 * @param {string} tagName - Tag name to check if it is valid.
 * @returns Returns `true` if tag name is valid.
 */
export declare function isValidTagName(tagName: string): boolean

/**
 * Test if this Oid is all zeros.
 *
 * @category Oid
 * @signature
 * ```ts
 * function isZeroOid(value: string): boolean;
 * ```
 *
 * @param {string} value - String to check if is zero Oid.
 * @returns Returns `true` if the string is zero Oid.
 * @example
 * ```ts
 * import { zeroOid, isZeroOid } from 'es-git';
 *
 * console.assert(isZeroOid(zeroOid());
 * ```
 */
export declare function isZeroOid(value: string): boolean

export interface MergeAnalysis {
  /** No merge is possible. */
  none: boolean
  /**
   * A "normal" merge; both HEAD and the given merge input have diverged
   * from their common ancestor. The divergent commits must be merged.
   */
  normal: boolean
  /**
   * All given merge inputs are reachable from HEAD, meaning the
   * repository is up-to-date and no merge needs to be performed.
   */
  upToDate: boolean
  /**
   * The given merge input is a fast-forward from HEAD and no merge
   * needs to be performed.  Instead, the client can check out the
   * given merge input.
   */
  fastForward: boolean
  /**
   * The HEAD of the current repository is "unborn" and does not point to
   * a valid commit.  No merge can be performed, but the caller may wish
   * to simply set HEAD to the target commit(s).
   */
  unborn: boolean
}

export interface MergeAnalysisResult {
  analysis: MergeAnalysis
  preference: MergePreference
}

export interface MergeOptions {
  /** Detect file renames */
  findRenames?: boolean
  /**
   * If a conflict occurs, exit immediately instead of attempting to continue
   * resolving conflicts
   */
  failOnConflict?: boolean
  /** Do not write the REUC extension on the generated index */
  skipReuc?: boolean
  /**
   * If the commits being merged have multiple merge bases, do not build a
   * recursive merge base (by merging the multiple merge bases), instead
   * simply use the first base.
   */
  noRecursive?: boolean
  /** Similarity to consider a file renamed (default 50) */
  renameThreshold?: number
  /**
   *  Maximum similarity sources to examine for renames (default 200).
   * If the number of rename candidates (add / delete pairs) is greater
   * than this value, inexact rename detection is aborted. This setting
   * overrides the `merge.renameLimit` configuration value.
   */
  targetLimit?: number
  /**
   * Maximum number of times to merge common ancestors to build a
   * virtual merge base when faced with criss-cross merges.  When
   * this limit is reached, the next ancestor will simply be used
   * instead of attempting to merge it.  The default is unlimited.
   */
  recursionLimit?: number
  /** Specify a side to favor for resolving conflicts */
  filFavor?: FileFavor
  /** Create standard conflicted merge files */
  standardStyle?: boolean
  /** Create diff3-style file */
  diff3Style?: boolean
  /** Condense non-alphanumeric regions for simplified diff file */
  simplifyAlnum?: boolean
  /** Ignore all whitespace */
  ignoreWhitespace?: boolean
  /** Ignore changes in amount of whitespace */
  ignoreWhitespaceChange?: boolean
  /** Ignore whitespace at end of line */
  ignoreWhitespaceEol?: boolean
  /** Use the "patience diff" algorithm */
  patience?: boolean
  /** Take extra time to find minimal diff */
  minimal?: boolean
}

export interface MergePreference {
  /**
   * No configuration was found that suggests a preferred behavior for
   * merge.
   */
  none: boolean
  /**
   * There is a `merge.ff=false` configuration setting, suggesting that
   * the user does not want to allow a fast-forward merge.
   */
  noFastForward: boolean
  /**
   * There is a `merge.ff=only` configuration setting, suggesting that
   * the user only wants fast-forward merges.
   */
  fastForwardOnly: boolean
}

/**
 * Normalize reference name and check validity.
 *
 * This will normalize the reference name by collapsing runs of adjacent
 * slashes between name components into a single slash. It also validates
 * the name according to the following rules:
 *
 * 1. If `ReferenceFormat.AllowOnelevel` is given, the name may
 *    contain only capital letters and underscores, and must begin and end
 *    with a letter. (e.g. "HEAD", "ORIG_HEAD").
 * 2. The flag `ReferenceFormat.RefspecShorthand` has an effect
 *    only when combined with `ReferenceFormat.AllowOnelevel`. If
 *    it is given, "shorthand" branch names (i.e. those not prefixed by
 *    `refs/`, but consisting of a single word without `/` separators)
 *    become valid. For example, "main" would be accepted.
 * 3. If `ReferenceFormat.RefspecPattern` is given, the name may
 *    contain a single `*` in place of a full pathname component (e.g.
 *    `foo/*\/bar`, `foo/bar*`).
 * 4. Names prefixed with "refs/" can be almost anything. You must avoid
 *    the characters '~', '^', ':', '\\', '?', '[', and '*', and the
 *    sequences ".." and "@{" which have special meaning to revparse.
 *
 * @category Reference
 * @signature
 * ```ts
 * function normalizeReferenceName(refname: string, format?: number | null | undefined): string | null;
 * ```
 *
 * @param {string} refname - Reference name to normalize.
 * @param {number} [format] - Reference format flags which used for normalize.
 *
 * @returns If the reference passes validation, it is returned in normalized form,
 * otherwise an `null` is returned.
 *
 * @example
 * ```ts
 * import { normalizeReferenceName, ReferenceFormat } from 'es-git';
 *
 * console.assert(
 *   normalizeReferenceName('foo//bar'),
 *   'foo/bar'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'HEAD',
 *     ReferenceFormat.AllowOnelevel
 *   ),
 *   'HEAD'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'refs/heads/*',
 *     ReferenceFormat.RefspecPattern
 *   ),
 *   'refs/heads/*'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'main',
 *     ReferenceFormat.AllowOnelevel | ReferenceFormat.RefspecShorthand
 *   ),
 *   'main'
 * );
 * ```
 */
export declare function normalizeReferenceName(refname: string, format?: number | undefined | null): string | null

export interface NoteIterItem {
  noteId: string
  annotatedId: string
}

/**
 * - `Any` : Any kind of git object
 * - `Commit` : An object which corresponds to a git commit
 * - `Tree` : An object which corresponds to a git tree
 * - `Blob` : An object which corresponds to a git blob
 * - `Tag` : An object which corresponds to a git tag
 */
export type ObjectType =  'Any'|
'Commit'|
'Tree'|
'Blob'|
'Tag';

/**
 * Create a new config instance containing a single on-disk file
 *
 * @category Config
 * @signature
 * ```ts
 * function openConfig(path: string): Config;
 * ```
 *
 * @param {string} path - Path to config file.
 * @returns Config instance representing a git configuration key/value store.
 */
export declare function openConfig(path: string): Config

/**
 * Open the global, XDG and system configuration files
 *
 * Utility wrapper that finds the global, XDG and system configuration
 * files and opens them into a single prioritized config object that can
 * be used when accessing default config data outside a repository.
 *
 * @category Config
 * @signature
 * ```ts
 * function openDefaultConfig(): Config;
 * ```
 *
 * @returns Config instance representing a git configuration key/value store.
 */
export declare function openDefaultConfig(): Config

/**
 * Attempt to open an already-existing repository at `path`.
 *
 * @category Repository
 * @signature
 * ```ts
 * function openRepository(
 *   path: string,
 *   options?: RepositoryOpenOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined,
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to repository already-existing.
 * @param {RepositoryOpenOptions} [options] - Options which can be used to configure
 * how a repository is initialized.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns Opened repository.
 *
 * @example
 *
 * Basic example.
 *
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('/path/to/repo');
 * ```
 *
 * Open bare repository.
 *
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('/path/to/repo.git', {
 *   bare: true,
 * });
 * ```
 */
export declare function openRepository(path: string, options?: RepositoryOpenOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>

/**
 * Parse a string as a bool.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigBool(value: string): boolean;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Interprets "true", "yes", "on", 1, or any non-zero number as `true`.
 * Interprets "false", "no", "off", 0, or an empty string as `false`.
 */
export declare function parseConfigBool(value: string): boolean

/**
 * Parse a string as an i32; handles suffixes like k, M, or G, and
 * multiplies by the appropriate power of 1024.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigI32(value: string): number;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Parsed i32 value.
 */
export declare function parseConfigI32(value: string): number

/**
 * Parse a string as an i64; handles suffixes like k, M, or G, and
 * multiplies by the appropriate power of 1024.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigI64(value: string): number;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Parsed i64 value.
 */
export declare function parseConfigI64(value: string): number

export interface ProxyOptions {
  /**
   * Try to auto-detect the proxy from the git configuration.
   *
   * Note that this will override `url` specified before.
   */
  auto?: boolean
  /**
   * Specify the exact URL of the proxy to use.
   *
   * Note that this will override `auto` specified before.
   */
  url?: string
}

export interface PruneOptions {
  credential?: Credential
}

/** Options to control the behavior of a git push. */
export interface PushOptions {
  credential?: Credential
  /** Set the proxy options to use for the push operation. */
  proxy?: ProxyOptions
  /**
   * If the transport being used to push to the remote requires the creation
   * of a pack file, this controls the number of worker threads used by the
   * packbuilder when creating that pack file to be sent to the remote.
   *
   * If set to 0, the packbuilder will auto-detect the number of threads to
   * create, and the default value is 1.
   */
  pbParallelism?: number
  /**
   * Set remote redirection settings; whether redirects to another host are
   * permitted.
   *
   * By default, git will follow a redirect on the initial request
   * (`/info/refs`), but not subsequent requests.
   */
  followRedirects?: RemoteRedirect
  /** Set extra headers for this push operation. */
  customHeaders?: Array<string>
  /** Set "push options" to deliver to the remote. */
  remoteOptions?: Array<string>
}

export interface RebaseCommitOptions {
  /**
   * Signature for author.
   * To keep the author from the original commit leave this as empty.
   */
  author?: SignaturePayload
  /** Signature for commiter. */
  committer: SignaturePayload
  /** To keep the message from the original commit leave this as empty. */
  message?: string
}

/**
 * A rebase operation
 *
 * Describes a single instruction/operation to be performed during the
 * rebase.
 */
export interface RebaseOperation {
  /** The type of rebase operation */
  type?: RebaseOperationType
  /**
   * The commit ID being cherry-picked. This will be populated for all
   * operations except those of type `GIT_REBASE_OPERATION_EXEC`.
   */
  id: string
  /**
   * The executable the user has requested be run.  This will only
   *  be populated for operations of type `Exec`.
   */
  exec?: string
}

/**
 * A rebase operation.
 * Describes a single instruction/operation to be performed during the
 * rebase.
 *
 * - `Pick` : The given commit is to be cherry-picked. The client should commit the
 * changes and continue if there are no conflicts.
 * - `Reword` : The given commit is to be cherry-picked, but the client should prompt
 * the user to provide an updated commit message.
 * - `Edit` : The given commit is to be cherry-picked, but the client should stop to
 * allow the user to edit the changes before committing them.
 * - `Squash` : The given commit is to be squashed into the previous commit. The commit
 * message will be merged with the previous message.
 * - `Fixup` : The given commit is to be squashed into the previous commit. The commit
 * message from this commit will be discarded.
 * - `Exec` : No commit will be cherry-picked. The client should run the given command
 * and (if successful) continue.
 */
export type RebaseOperationType =  'Pick'|
'Reword'|
'Edit'|
'Squash'|
'Fixup'|
'Exec';

export interface RebaseOptions {
  /**
   * This will instruct other clients working on this
   * rebase that you want a quiet rebase experience, which they may choose to
   * provide in an application-specific manner. This has no effect upon
   * libgit2 directly, but is provided for interoperability between Git
   * tools.
   */
  quiet?: boolean
  /**
   * This will begin an in-memory rebase,
   * which will allow callers to step through the rebase operations and
   * commit the rebased changes, but will not rewind HEAD or update the
   * repository to be in a rebasing state.  This will not interfere with
   * the working directory (if there is one).
   */
  inmemory?: boolean
  /**
   * Used by `finish()`, this is the name of the notes reference
   * used to rewrite notes for rebased commits when finishing the rebase;
   * if NULL, the contents of the configuration option `notes.rewriteRef`
   * is examined, unless the configuration option `notes.rewrite.rebase`
   * is set to false.
   * If `notes.rewriteRef` is also NULL, notes will not be rewritten.
   */
  rewriteNotesRef?: string
  /** Options to control how trees are merged during `next()`. */
  mergeOptions?: MergeOptions
  /**
   * Options to control how files are written during `Repository::rebase`,
   * `next()` and `abort()`. Note that a minimum strategy of
   * `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`, and a minimum
   * strategy of `GIT_CHECKOUT_FORCE` is defaulted in `abort` to match git
   * semantics.
   */
  checkoutOptions?: CheckoutOptions
}

/**
 * - `ReferenceFormat.Normal` : No particular normalization.
 * - `ReferenceFormat.AllowOnelevel` : Control whether one-level refname are accepted
 * (i.e., refnames that do not contain multiple `/`-separated components). Those are
 * expected to be written only using uppercase letters and underscore
 * (e.g. `HEAD`, `FETCH_HEAD`).
 * - `ReferenceFormat.RefspecPattern` : Interpret the provided name as a reference pattern
 * for a refspec (as used with remote repositories). If this option is enabled, the name
 * is allowed to contain a single `*` in place of a full pathname
 * components (e.g., `foo/*\/bar` but not `foo/bar*`).
 * - `ReferenceFormat.RefspecShorthand` : Interpret the name as part of a refspec in shorthand
 * form so the `AllowOnelevel` naming rules aren't enforced and `main` becomes a valid name.
 */
export declare enum ReferenceFormat {
  Normal = 0,
  AllowOnelevel = 1,
  RefspecPattern = 2,
  RefspecShorthand = 4
}

/**
 * - `Direct` : A reference which points at an object id.
 * - `Symbolic` : A reference which points at another reference.
 */
export type ReferenceType =  'Direct'|
'Symbolic';

/**
 * A data object to represent a git [refspec][1].
 *
 * Refspecs are currently mainly accessed/created through a `Remote`.
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-The-Refspec
 */
export interface Refspec {
  direction: Direction
  /** The source specifier. */
  src: string
  /** The destination specifier. */
  dst: string
  /** Force update setting. */
  force: boolean
}

/**
 * - `None` : Do not follow any off-site redirects at any stage of the fetch or push.
 * - `Initial` : Allow off-site redirects only upon the initial request. This is the default.
 * - `All` : Allow redirects at any stage in the fetch or push.
 */
export type RemoteRedirect =  'None'|
'Initial'|
'All';

export interface RenameReferenceOptions {
  /**
   * If the force flag is not enabled, and there's already a reference with
   * the given name, the renaming will fail.
   */
  force?: boolean
  logMessage?: string
}

export interface RepositoryCloneOptions {
  /**
   * Indicate whether the repository will be cloned as a bare repository or
   * not.
   */
  bare?: boolean
  /**
   * Specify the name of the branch to check out after the clone.
   *
   * If not specified, the remote's default branch will be used.
   */
  branch?: string
  /**
   * Clone a remote repository, initialize and update its submodules
   * recursively.
   *
   * This is similar to `git clone --recursive`.
   */
  recursive?: boolean
  /** Options which can be specified to various fetch operations. */
  fetch?: FetchOptions
}

/** Mode options for `RepositoryInitOptions`. */
export declare enum RepositoryInitMode {
  /** Use permissions configured by umask (default) */
  SharedUnmask = 0,
  /**
   * Use `--shared=group` behavior, chmod'ing the new repo to be
   * group writable and "g+sx" for sticky group assignment.
   */
  SharedGroup = 1533,
  /** Use `--shared=all` behavior, adding world readability. */
  SharedAll = 1535
}

export interface RepositoryInitOptions {
  /**
   * Create a bare repository with no working directory.
   *
   * Defaults to `false`.
   */
  bare?: boolean
  /**
   * Return an error if the repository path appears to already be a git
   * repository.
   *
   * Defaults to `false`.
   */
  noReinit?: boolean
  /**
   * Normally a '/.git/' will be appended to the repo path for non-bare repos
   * (if it is not already there), but passing this flag prevents that
   * behavior.
   *
   * Defaults to `false`.
   */
  noDotgitDir?: boolean
  /**
   * Make the repo path (and workdir path) as needed. The ".git" directory
   * will always be created regardless of this flag.
   *
   * Defaults to `true`.
   */
  mkdir?: boolean
  /**
   * Make the repo path (and workdir path) as needed. The ".git" directory
   * will always be created regardless of this flag.
   *
   * Defaults to `true`.
   */
  mkpath?: boolean
  /** Set to one of the `RepositoryInit` constants, or a custom value. */
  mode?: number
  /**
   * Enable or disable using external templates.
   *
   * If enabled, then the `template_path` option will be queried first, then
   * `init.templatedir` from the global config, and finally
   * `/usr/share/git-core-templates` will be used (if it exists).
   *
   * Defaults to `true`.
   */
  externalTemplate?: boolean
  /**
   * When the `externalTemplate` option is set, this is the first location
   * to check for the template directory.
   *
   * If this is not configured, then the default locations will be searched
   * instead.
   */
  templatePath?: string
  /**
   * The path to the working directory.
   *
   * If this is a relative path it will be evaluated relative to the repo
   * path. If this is not the "natural" working directory, a .git gitlink
   * file will be created here linking to the repo path.
   */
  workdirPath?: string
  /**
   * If set, this will be used to initialize the "description" file in the
   * repository instead of using the template content.
   */
  description?: string
  /**
   * The name of the head to point HEAD at.
   *
   * If not configured, this will be taken from your git configuration.
   * If this begins with `refs/` it will be used verbatim;
   * otherwise `refs/heads/` will be prefixed.
   */
  initialHead?: string
  /**
   * If set, then after the rest of the repository initialization is
   * completed an `origin` remote will be added pointing to this URL.
   */
  originUrl?: string
}

export interface RepositoryOpenOptions {
  /**
   * If this option is `true`, the path must point directly to a repository; otherwise,
   * this may point to a subdirectory of a repository, and `open` will search up through parent
   * directories.
   */
  noSearch?: boolean
  /**
   * If this option is `true`, the search through parent directories will not cross
   * a filesystem boundary (detected when the stat st_dev field changes).
   */
  crossFs?: boolean
  /**
   * If this option is `true`, force opening the repository as bare event if it isn't, ignoring
   * any working directory, and defer loading the repository configuration for performance.
   */
  bare?: boolean
  /** If this options is `true`, don't try appending `/.git` to `path`. */
  noDotgit?: boolean
  /**
   * If this option is `true`, `open` will ignore other options and `ceilingDirs`, and respect
   * the same environment variables git does.
   * Note, however, that `path` overrides `$GIT_DIR`.
   */
  fromEnv?: boolean
  /**
   * ceiling_dirs specifies a list of paths that the search through parent
   * directories will stop before entering.
   */
  ceilingDirs?: Array<string>
}

/**
 * Available states are `Clean`, `Merge`, `Revert`, `RevertSequence`, `CherryPick`,
 * `CherryPickSequence`, `Bisect`, `Rebase`, `RebaseInteractive`, `RebaseMerge`,
 * `ApplyMailbox`, `ApplyMailboxOrRebase`.
 */
export type RepositoryState =  'Clean'|
'Merge'|
'Revert'|
'RevertSequence'|
'CherryPick'|
'CherryPickSequence'|
'Bisect'|
'Rebase'|
'RebaseInteractive'|
'RebaseMerge'|
'ApplyMailbox'|
'ApplyMailboxOrRebase';

/**
 * Options for revert behavior.
 *
 * Controls how a revert is performed when applying the inverse of a commit.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 * const head = repo.head().target()!;
 * const commit = repo.getCommit(head);
 *
 * // Simple revert
 * repo.revert(commit);
 * repo.cleanupState();
 *
 * // Revert a merge commit selecting the first parent as mainline
 * repo.revert(commit, { mainline: 1 });
 * repo.cleanupState();
 *
 * // Prevent working tree changes (dry run) but compute conflicts
 * repo.revert(commit, { checkoutOptions: { dryRun: true } });
 * repo.cleanupState();
 * ```
 */
export interface RevertOptions {
  /**
   * Parent number for merge commits (1-based).
   *
   * When reverting a merge commit, the mainline parent is the one you want to
   * revert to. The mainline is the branch into which the merge was made.
   */
  mainline?: number
  /** Options for merge conflict resolution. */
  mergeOptions?: MergeOptions
  /** Options for checkout behavior when updating working directory. */
  checkoutOptions?: CheckoutOptions
}

/**
 * Flags for the revparse.
 * - `Single` : The spec targeted a single object.
 * - `Range` : The spec targeted a range of commits.
 * - `MergeBase` : The spec used the `...` operator, which invokes special semantics.
 */
export declare enum RevparseMode {
  Single = 1,
  Range = 2,
  MergeBase = 4
}

/**
 * Check revparse mode contains specific flags.
 *
 * @category Revparse
 * @signature
 * ```ts
 * function revparseModeContains(source: number, target: number): boolean;
 * ```
 *
 * @param {number} source - Source flags.
 * @param {number} target - Target flags.
 * @returns Returns `true` is source flags contains target flags.
 *
 * @example
 * ```ts
 * import { openRepository, revparseModeContains, RevparseMode } from 'es-git';
 *
 * const repo = await openRepository('.');
 * const spec = repo.revparse('main..other');
 *
 * console.assert(revparseModeContains(spec.mode, RevparseMode.Range));
 * ```
 */
export declare function revparseModeContains(source: number, target: number): boolean

/** A revspec represents a range of revisions within a repository. */
export interface Revspec {
  /** Access the `from` range of this revspec. */
  from?: string
  /** Access the `to` range of this revspec. */
  to?: string
  /** Returns the intent of the revspec. */
  mode: number
}

export declare enum RevwalkSort {
  None = 0,
  Topological = 1,
  Time = 2,
  Reverse = 4
}

/**
 * A Signature is used to indicate authorship of various actions throughout the
 * library.
 * Signatures contain a name, email, and timestamp.
 */
export interface Signature {
  /** Name on the signature. */
  name: string
  /** Email on the signature. */
  email: string
  /** Time in seconds, from epoch */
  timestamp: number
}

export interface SignaturePayload {
  /** Name on the signature. */
  name: string
  /** Email on the signature. */
  email: string
  timeOptions?: SignatureTimeOptions
}

export interface SignatureTimeOptions {
  /** Time in seconds, from epoch */
  timestamp: number
  /** Timezone offset, in minutes */
  offset?: number
}

/**
 * Options for applying a stash.
 *
 * Controls how a stash is applied to the working directory.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 *
 * // Default apply
 * repo.stashApply(0);
 *
 * // With options
 * repo.stashApply(0, { reinstantiateIndex: true });
 * ```
 */
export interface StashApplyOptions {
  /**
   * Whether to reinstall the index from the stash.
   * If true, the index state recorded in the stash is also restored.
   * Default: false
   */
  reinstantiateIndex?: boolean
}

/**
 * Options for saving a stash.
 *
 * All fields are optional. If not provided, sensible defaults will be used.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 *
 * // Basic usage
 * repo.stashSave({
 *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' }
 * });
 *
 * // With options
 * repo.stashSave({
 *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
 *   message: 'WIP: feature implementation',
 *   includeUntracked: true
 * });
 * ```
 */
export interface StashSaveOptions {
  /**
   * The identity of the person performing the stashing.
   * If not provided, uses the repository's default signature.
   */
  stasher?: SignaturePayload
  /**
   * Description along with the stashed state.
   * If not provided, a default message will be generated.
   */
  message?: string
  /**
   * Whether to stash untracked files.
   * Default: false
   */
  includeUntracked?: boolean
  /**
   * Whether to stash ignored files.
   * Default: false
   */
  includeIgnored?: boolean
  /**
   * Whether to retain the index after stashing.
   * If true, staged changes remain in the index after stashing.
   * Default: false
   */
  keepIndex?: boolean
}

export interface Status {
  current: boolean
  indexNew: boolean
  indexModified: boolean
  indexDeleted: boolean
  indexRenamed: boolean
  indexTypechange: boolean
  wtNew: boolean
  wtModified: boolean
  wtDeleted: boolean
  wtTypechange: boolean
  wtRenamed: boolean
  wtUnreadable: boolean
  ignored: boolean
  conflicted: boolean
}

export interface StatusOptions {
  /**
   * Select the files on which to report status.
   * The default, if unspecified, is to show the index and the working directory.
   */
  show?: StatusShow
  /**
   * Path patterns to match (using fnmatch-style matching).
   * If the `disablePathspecMatch` option is given, then this is a literal
   * path to match. If this is not called, then there will be no patterns to
   * match and the entire directory will be used.
   */
  pathspecs?: Array<string>
  /**
   * Flag whether untracked files will be included.
   * Untracked files will only be included if the workdir files are included
   * in the status "show" option.
   */
  includeUntracked?: boolean
  includeIgnored?: boolean
  includeUnmodified?: boolean
  excludeSubmodules?: boolean
  recurseUntrackedDirs?: boolean
  disablePathspecMatch?: boolean
  recurseIgnoredDirs?: boolean
  renamesHeadToIndex?: boolean
  renamesIndexToWorkdir?: boolean
  sortCaseSensitively?: boolean
  sortCaseInsensitively?: boolean
  renamesFromRewrites?: boolean
  noRefresh?: boolean
  updateIndex?: boolean
  includeUnreadable?: boolean
  includeUnreadableAsUntracked?: boolean
  renameThreshold?: number
}

/**
 * - `Index` : Only gives status based on HEAD to index comparison, not looking at
 * working directory changes.
 * - `Workdir` : Only gives status based on index to working directory comparison, not
 * comparing the index to the HEAD.
 * - `IndexAndWorkdi` : The default, this roughly matches `git status --porcelain` regarding
 * which files are included and in what order.
 */
export type StatusShow =  'Index'|
'Workdir'|
'IndexAndWorkdir';

/**
 * Submodule ignore values
 *
 * These values represent settings for the `submodule.$name.ignore`
 * configuration value which says how deeply to look at the working
 * directory when getting the submodule status.
 */
export type SubmoduleIgnore = /** Use the submodule's configuration */
'Unspecified'|
/** Any change or untracked file is considered dirty */
'None'|
/** Only dirty if tracked files have changed */
'Untracked'|
/** Only dirty if HEAD has moved */
'Dirty'|
/** Never dirty */
'All';

/**
 * Return codes for submodule status.
 *
 * A combination of these flags will be returned to describe the status of a
 * submodule.  Depending on the "ignore" property of the submodule, some of
 * the flags may never be returned because they indicate changes that are
 * supposed to be ignored.
 *
 * Submodule info is contained in 4 places: the HEAD tree, the index, config
 * files (both .git/config and .gitmodules), and the working directory.  Any
 * or all of those places might be missing information about the submodule
 * depending on what state the repo is in.  We consider all four places to
 * build the combination of status flags.
 *
 * There are four values that are not really status, but give basic info
 * about what sources of submodule data are available.  These will be
 * returned even if ignore is set to "ALL".
 *
 * * IN_HEAD   - superproject head contains submodule
 * * IN_INDEX  - superproject index contains submodule
 * * IN_CONFIG - superproject gitmodules has submodule
 * * IN_WD     - superproject workdir has submodule
 *
 * The following values will be returned so long as ignore is not "ALL".
 *
 * * INDEX_ADDED       - in index, not in head
 * * INDEX_DELETED     - in head, not in index
 * * INDEX_MODIFIED    - index and head don't match
 * * WD_UNINITIALIZED  - workdir contains empty directory
 * * WD_ADDED          - in workdir, not index
 * * WD_DELETED        - in index, not workdir
 * * WD_MODIFIED       - index and workdir head don't match
 *
 * The following can only be returned if ignore is "NONE" or "UNTRACKED".
 *
 * * WD_INDEX_MODIFIED - submodule workdir index is dirty
 * * WD_WD_MODIFIED    - submodule workdir has modified files
 *
 * Lastly, the following will only be returned for ignore "NONE".
 *
 * * WD_UNTRACKED      - workdir contains untracked files
 */
export declare enum SubmoduleStatus {
  InHead = 1,
  InIndex = 2,
  InConfig = 4,
  InWD = 8,
  IndexAdded = 16,
  IndexDeleted = 32,
  IndexModified = 64,
  WDUninitialized = 128,
  WDAdded = 256,
  WDDeleted = 512,
  WDModified = 1024,
  WDIndexModified = 2048,
  WDWDModified = 4096,
  WDUntracked = 8192
}

/**
 * Check submodule status contains given value.
 *
 * @category Submodule
 * @signature
 * ```ts
 * function submoduleStatusContains(source: number, target: number): boolean;
 * ```
 *
 * @param {number} source - Source status.
 * @param {number} target - Target status.
 * @returns Returns `true` is source status contains target status.
 */
export declare function submoduleStatusContains(source: number, target: number): boolean

/**
 * Submodule update values
 *
 * These values represent settings for the `submodule.$name.update`
 * configuration value which says how to handle `git submodule update`
 * for this submodule. The value is usually set in the ".gitmodules"
 * file and copied to ".git/config" when the submodule is initialized.
 */
export type SubmoduleUpdate = /**
 * The default; when a submodule is updated| checkout the new detached
 * HEAD to the submodule directory.
 */
'Checkout'|
/**
 * Update by rebasing the current checked out branch onto the commit from
 * the superproject.
 */
'Rebase'|
/**
 * Update by merging the commit in the superproject into the current
 * checkout out branch of the submodule.
 */
'Merge'|
/**
 * Do not update this submodule even when the commit in the superproject
 * is updated.
 */
'None'|
/**
 * Not used except as static initializer when we don't want any particular
 * update rule to be specified.
 */
'Default';

/** Options to update a submodule. */
export interface SubmoduleUpdateOptions {
  /** These options are passed to the checkout step. */
  checkout?: CheckoutOptions
  /** Options which control the fetch, including callbacks. */
  fetch?: FetchOptions
  /**
   * Allow fetching from the submodule's default remote if the target commit isn't found.
   * Default: `true`.
   */
  allowFetch?: boolean
}

/**
 * Clear the global subscriber
 *
 * @category Tracing
 * @signature
 * ```ts
 * function traceClear(): void;
 * ```
 */
export declare function traceClear(): void

/**
 * Available tracing levels.  When tracing is set to a particular level,
 * callers will be provided tracing at the given level and all lower levels.
 */
export type TraceLevel =  'None'|
'Fatal'|
'Error'|
'Warn'|
'Info'|
'Debug'|
'Trace';

/**
 * Set the global subscriber called when libgit2 produces a tracing message.
 *
 * @category Tracing
 * @signature
 * ```ts
 * function traceSet(
 *   level: TraceLevel,
 *   callback: (level: TraceLevel, message: string) => void,
 * ): void;
 * ```
 *
 * @param {TraceLevel} level - Level to set tracing to
 * @param {(level: TraceLevel, message: string) => void} callback - Callback to call with trace data
 */
export declare function traceSet(level: TraceLevel, callback: (level: TraceLevel, message: string) => void): void

/**
 * - `PreOrder` : Runs the traversal in pre-order.
 * - `PostOrder` : Runs the traversal in post-order.
 */
export type TreeWalkMode =  'PreOrder'|
'PostOrder';

/**
 * Creates an all zero Oid structure.
 *
 * @category Oid
 * @signature
 * ```ts
 * function zeroOid(): string;
 * ```
 *
 * @returns Zero Oid string.
 */
export declare function zeroOid(): string

/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Represents a hunk of a blame operation, which is a range of lines
 * and information about who last modified them.
 */
export interface BlameHunk {
  /** The oid of the commit where this line was last changed. */
  finalCommitId: string
  /** The 1-based line number in the final file where this hunk starts. */
  finalStartLineNumber: number
  /** The number of lines in this hunk. */
  linesInHunk: number
  /** The signature of the commit where this line was last changed. */
  finalSignature?: Signature
  /** The path to the file where this line was originally written. */
  path?: string
  /** The 1-based line number in the original file where this hunk starts. */
  origStartLineNumber: number
  /** The oid of the commit where this line was originally written. */
  origCommitId: string
  /** The signature of the commit where this line was originally written. */
  origSignature?: Signature
  /**
   * True if the hunk has been determined to be a boundary commit (the commit
   * when the file was first introduced to the repository).
   */
  isBoundary: boolean
}
/** Options for controlling blame behavior */
export interface BlameOptions {
  /** The minimum line number to blame (1-based index) */
  minLine?: number
  /** The maximum line number to blame (1-based index) */
  maxLine?: number
  /**
   * The oid of the newest commit to consider. The blame algorithm will stop
   * when this commit is reached.
   */
  newestCommit?: string
  /**
   * The oid of the oldest commit to consider. The blame algorithm will
   * stop when this commit is reached.
   */
  oldestCommit?: string
  /**
   * The path to the file being worked on. Path has to be relative to the
   * repo root.
   */
  path?: string
  /**
   * Track lines that have moved within a file. This is the git-blame -M
   * option.
   */
  trackLinesMovement?: boolean
  /** Restrict search to commits reachable following only first parents. */
  firstParent?: boolean
  /** Ignore whitespace differences. */
  ignoreWhitespace?: boolean
  /** Track lines that have been copied from another file that exists in any commit. */
  trackCopiesAnyCommitCopies?: boolean
  /** Track lines that have been copied from another file that exists in the same commit. */
  trackCopiesSameCommitCopies?: boolean
  /** Track lines that have moved across files in the same commit. */
  trackCopiesSameCommitMoves?: boolean
  /** Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. */
  useMailmap?: boolean
}
/**
 * Ensure the branch name is well-formed.
 *
 * @category Branch
 * @signature
 * ```ts
 * function isValidBranchName(name: string): boolean;
 * ```
 *
 * @param {string} name - Branch name to check is valid.
 * @returns Returns `true` if the given branch name is well-formed.
 */
export declare function isValidBranchName(name: string): boolean
export interface BranchesItem {
  type: BranchType
  name: string
}
/**
 * - `Local` : A local branch not on a remote.
 * - `Remote` : A branch for a remote.
 */
export type BranchType = 'Local' | 'Remote';
export interface BranchRenameOptions {
  /**
   * If the force flag is not enabled, and there's already a branch with
   * the given name, the renaming will fail.
   */
  force?: boolean
}
export interface CreateBranchOptions {
  /**
   * If `force` is true and a reference already exists with the given name,
   * it'll be replaced.
   */
  force?: boolean
}
export interface BranchesFilter {
  /** Branch type to filter. */
  type?: BranchType
}
export interface CheckoutOptions {
  /**
   * Indicate that this checkout should perform a dry run by checking for
   * conflicts but not make any actual changes.
   */
  dryRun?: boolean
  /**
   * Take any action necessary to get the working directory to match the
   * target including potentially discarding modified files.
   */
  force?: boolean
  /**
   * Indicate that the checkout should be performed safely, allowing new
   * files to be created but not overwriting existing files or changes.
   *
   * This is the default.
   */
  safe?: boolean
  /**
   * In safe mode, create files that don't exist.
   *
   * Defaults to false.
   */
  recreateMissing?: boolean
  /**
   * In safe mode, apply safe file updates even when there are conflicts
   * instead of canceling the checkout.
   *
   * Defaults to false.
   */
  allowConflicts?: boolean
  /**
   * Remove untracked files from the working dir.
   *
   * Defaults to false.
   */
  removeUntracked?: boolean
  /**
   * Remove ignored files from the working dir.
   *
   * Defaults to false.
   */
  removeIgnored?: boolean
  /**
   * Only update the contents of files that already exist.
   *
   * If set, files will not be created or deleted.
   *
   * Defaults to false.
   */
  updateOnly?: boolean
  /**
   * Prevents checkout from writing the updated files' information to the
   * index.
   *
   * Defaults to true.
   */
  updateIndex?: boolean
  /**
   * Indicate whether the index and git attributes should be refreshed from
   * disk before any operations.
   *
   * Defaults to true,
   */
  refresh?: boolean
  /**
   * Skip files with unmerged index entries.
   *
   * Defaults to false.
   */
  skipUnmerged?: boolean
  /**
   * Indicate whether the checkout should proceed on conflicts by using the
   * stage 2 version of the file ("ours").
   *
   * Defaults to false.
   */
  useOurs?: boolean
  /**
   * Indicate whether the checkout should proceed on conflicts by using the
   * stage 3 version of the file ("theirs").
   *
   * Defaults to false.
   */
  useTheirs?: boolean
  /**
   * Indicate whether ignored files should be overwritten during the checkout.
   *
   * Defaults to true.
   */
  overwriteIgnored?: boolean
  /**
   * Indicate whether a normal merge file should be written for conflicts.
   *
   * Defaults to false.
   */
  conflictStyleMerge?: boolean
  /**
   * Indicates whether to include common ancestor data in diff3 format files
   * for conflicts.
   *
   * Defaults to false.
   */
  conflictStyleDiff3?: boolean
  /**
   * Treat paths specified in `path` as exact file paths
   * instead of as pathspecs.
   */
  disablePathspecMatch?: boolean
  /** Indicate whether to apply filters like CRLF conversion. */
  disableFilters?: boolean
  /**
   * Set the mode with which new directories are created.
   *
   * Default is 0755
   */
  dirPerm?: number
  /**
   * Set the mode with which new files are created.
   *
   * The default is 0644 or 0755 as dictated by the blob.
   */
  filePerm?: number
  /**
   * Add a path to be checked out.
   *
   * The path is a [pathspec](https://git-scm.com/docs/gitglossary.html#Documentation/gitglossary.txt-aiddefpathspecapathspec) pattern, unless
   * `disablePathspecMatch` is set.
   *
   * If no paths are specified, then all files are checked out. Otherwise
   * only these specified paths are checked out.
   */
  path?: string
  /** Set the directory to check out to */
  targetDir?: string
  /** The name of the common ancestor side of conflicts */
  ancestorLabel?: string
  /** The name of the common our side of conflicts */
  ourLabel?: string
  /** The name of the common their side of conflicts */
  theirLabel?: string
}
export interface CommitOptions {
  updateRef?: string
  /**
   * Signature for author.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  author?: SignaturePayload
  /**
   * Signature for commiter.
   *
   * If not provided, the default signature of the repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  committer?: SignaturePayload
  parents?: Array<string>
  /**
   * GPG signature string for signed commits.
   *
   * If provided, this will create a signed commit.
   */
  signature?: string
  /**
   * Custom signature field name.
   *
   * If not provided, the default signature field (gpgsig) will be used.
   */
  signatureField?: string
}
/**
 * - `ProgramData` : System-wide on Windows, for compatibility with portable git.
 * - `System` : System-wide configuration file. (e.g. `/etc/gitconfig`)
 * - `XDG` : XDG-compatible configuration file. (e.g. `~/.config/git/config`)
 * - `Global` : User-specific configuration. (e.g. `~/.gitconfig`)
 * - `Local` : Repository specific config. (e.g. `$PWD/.git/config`)
 * - `Worktree` : Worktree specific configuration file. (e.g. `$GIT_DIR/config.worktree`)
 * - `App` : Application specific configuration file.
 * - `Highest` : Highest level available.
 */
export type ConfigLevel = 'ProgramData' | 'System' | 'XDG' | 'Global' | 'Local' | 'Worktree' | 'App' | 'Highest';
export interface ConfigEntry {
  /** The name of this entry. */
  name: string
  /** The value of this entry. If no value is defined, the value will be `null`. */
  value?: string
  /** The configuration level of this entry. */
  level: ConfigLevel
  /** Depth of includes where this variable was found */
  includeDepth: number
}
/**
 * Create a new config instance containing a single on-disk file
 *
 * @category Config
 * @signature
 * ```ts
 * function openConfig(path: string): Config;
 * ```
 *
 * @param {string} path - Path to config file.
 * @returns Config instance representing a git configuration key/value store.
 */
export declare function openConfig(path: string): Config
/**
 * Open the global, XDG and system configuration files
 *
 * Utility wrapper that finds the global, XDG and system configuration
 * files and opens them into a single prioritized config object that can
 * be used when accessing default config data outside a repository.
 *
 * @category Config
 * @signature
 * ```ts
 * function openDefaultConfig(): Config;
 * ```
 *
 * @returns Config instance representing a git configuration key/value store.
 */
export declare function openDefaultConfig(): Config
/**
 * Locate the path to the global configuration file.
 *
 * The user or global configuration file is usually located in
 * `$HOME/.gitconfig`.
 *
 * This method will try to guess the full path to that file, if the file
 * exists. The returned path may be used on any method call to load
 * the global configuration file.
 *
 * This method will not guess the path to the XDG compatible config file
 * (`.config/git/config`).
 *
 * @category Config
 * @signature
 * ```ts
 * function findGlobalConfigPath(): string | null;
 * ```
 *
 * @returns The path to the global configuration file.
 */
export declare function findGlobalConfigPath(): string | null
/**
 * Locate the path to the system configuration file.
 *
 * If `/etc/gitconfig` doesn't exist, it will look for `%PROGRAMFILES%`.
 *
 * @category Config
 * @signature
 * ```ts
 * function findSystemConfigPath(): string | null;
 * ```
 *
 * @returns The path to the system configuration file.
 */
export declare function findSystemConfigPath(): string | null
/**
 * Locate the path to the global XDG compatible configuration file.
 *
 * The XDG compatible configuration file is usually located in
 * `$HOME/.config/git/config`.
 *
 * @category Config
 * @signature
 * ```ts
 * function findXdgConfigPath(): string | null;
 * ```
 *
 * @returns The path to the XDG compatible configuration file.
 */
export declare function findXdgConfigPath(): string | null
/**
 * Parse a string as a bool.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigBool(value: string): boolean;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Interprets "true", "yes", "on", 1, or any non-zero number as `true`.
 * Interprets "false", "no", "off", 0, or an empty string as `false`.
 */
export declare function parseConfigBool(value: string): boolean
/**
 * Parse a string as an i32; handles suffixes like k, M, or G, and
 * multiplies by the appropriate power of 1024.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigI32(value: string): number;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Parsed i32 value.
 */
export declare function parseConfigI32(value: string): number
/**
 * Parse a string as an i64; handles suffixes like k, M, or G, and
 * multiplies by the appropriate power of 1024.
 *
 * @category Config
 * @signature
 * ```ts
 * function parseConfigI64(value: string): number;
 * ```
 *
 * @param {string} value - Input value.
 * @returns Parsed i64 value.
 */
export declare function parseConfigI64(value: string): number
/**
 * - `DiffFlags.Binary` : File(s) treated as binary data.
 * - `DiffFlags.NotBinary` : File(s) treated as text data.
 * - `DiffFlags.ValidId` : `id` value is known correct.
 * - `DiffFlags.Exists` : File exists at this side of the delta.
 */
export enum DiffFlags {
  Binary = 1,
  NotBinary = 2,
  ValidId = 4,
  Exists = 8
}
/**
 * Check diff flags contains given flags.
 *
 * @category Diff
 * @signature
 * ```ts
 * function diffFlagsContains(source: number, target: number): boolean;
 * ```
 *
 * @param {number} source - Source flags.
 * @param {number} target - Target flags.
 * @returns Returns `true` is source flags contains target flags.
 *
 * @example
 * ```ts
 * import { DiffDelta, DiffFlags, diffFlagsContains } from 'es-git';
 *
 * const delta: DiffDelta;
 * console.assert(diffFlagsContains(delta.flags(), DiffFlags.Binary | DiffFlags.ValidId));
 * ```
 */
export declare function diffFlagsContains(source: number, target: number): boolean
/**
 * - `Unmodified` : No changes.
 * - `Added` : Entry does not exist in an old version.
 * - `Deleted` : Entry does not exist in a new version.
 * - `Modified` : Entry content changed between old and new.
 * - `Renamed` : Entry was renamed between old and new.
 * - `Copied` : Entry was copied from another old entry.
 * - `Ignored` : Entry is ignored item in workdir.
 * - `Untracked` : Entry is untracked item in workdir.
 * - `Typechange` : Type of entry changed between old and new.
 * - `Unreadable` : Entry is unreadable.
 * - `Conflicted` : Entry in the index is conflicted.
 */
export type DeltaType = 'Unmodified' | 'Added' | 'Deleted' | 'Modified' | 'Renamed' | 'Copied' | 'Ignored' | 'Untracked' | 'Typechange' | 'Unreadable' | 'Conflicted';
/**
 * Possible output formats for diff data.
 *
 * - `Patch`: Full `git diff` (default)
 * - `PatchHeader` : Just the headers of the patch
 * - `Raw` : Like `git diff --raw` the headers of the patch
 * - `NameOnly` : Like `git diff --name-only`
 * - `NameStatus` : Like `git diff --name-status`
 * - `PatchId` : `git diff` as used by `git patch-id`
 */
export type DiffFormat = 'Patch' | 'PatchHeader' | 'Raw' | 'NameOnly' | 'NameStatus' | 'PatchId';
export interface DiffPrintOptions {
  format?: DiffFormat
}
export interface DiffFindOptions {
  /** Look for renames? */
  renames?: boolean
  /** Consider old side of modified for renames? */
  renamesFromRewrites?: boolean
  /** Look for copies? */
  copies?: boolean
  /**
   * Consider unmodified as copy sources?
   *
   * For this to work correctly, use `includeUnmodified` when the initial
   * diff is being generated.
   */
  copiesFromUnmodified?: boolean
  /** Mark significant rewrites for split. */
  rewrites?: boolean
  /** Actually split large rewrites into delete/add pairs */
  breakRewrites?: boolean
  /**
   * Find renames/copies for untracked items in working directory.
   *
   * For this to work correctly use the `includeUntracked` option when the
   * initial diff is being generated.
   */
  forUntracked?: boolean
  /** Turn on all finding features. */
  all?: boolean
  /** Measure similarity ignoring leading whitespace (default) */
  ignoreLeadingWhitespace?: boolean
  /** Measure similarity ignoring all whitespace */
  ignoreWhitespace?: boolean
  /** Measure similarity including all data */
  dontIgnoreWhitespace?: boolean
  /** Measure similarity only by comparing SHAs (fast and cheap) */
  exactMatchOnly?: boolean
  /**
   * Do not break rewrites unless they contribute to a rename.
   *
   * Normally, `breakRewrites` and `rewrites` will measure the
   * self-similarity of modified files and split the ones that have changed a
   * lot into a delete/add pair. Then the sides of that pair will be
   * considered candidates for rename and copy detection
   *
   * If you add this flag in and the split pair is not used for an actual
   * rename or copy, then the modified record will be restored to a regular
   * modified record instead of being split.
   */
  breakRewritesForRenamesOnly?: boolean
  /**
   * Remove any unmodified deltas after find_similar is done.
   *
   * Using `copiesFromUnmodified` to emulate the `--find-copies-harder`
   * behavior requires building a diff with the `includeUnmodified` flag. If
   * you do not want unmodified records in the final result, pas this flag to
   * have them removed.
   */
  removeUnmodified?: boolean
  /** Similarity to consider a file renamed (default 50) */
  renameThreshold?: number
  /** Similarity of modified to be eligible rename source (default 50) */
  renameFromRewriteThreshold?: number
  /** Similarity to consider a file copy (default 50) */
  copyThreshold?: number
  /** Similarity to split modify into delete/add pair (default 60) */
  breakRewriteThreshold?: number
  /**
   * Maximum similarity sources to examine for a file (somewhat like
   * git-diff's `-l` option or `diff.renameLimit` config)
   *
   * Defaults to 200
   */
  renameLimit?: number
}
/** Valid modes for index and tree entries. */
export type FileMode = 'Unreadable' | 'Tree' | 'Blob' | 'BlobGroupWritable' | 'BlobExecutable' | 'Link' | 'Commit';
export interface DiffOptions {
  /** Flag indicating whether the sides of the diff will be reversed. */
  reverse?: boolean
  /** Flag indicating whether ignored files are included. */
  includeIgnored?: boolean
  /** Flag indicating whether ignored directories are traversed deeply or not. */
  recurseIgnoredDirs?: boolean
  /** Flag indicating whether untracked files are in the diff */
  includeUntracked?: boolean
  /**
   * Flag indicating whether untracked directories are traversed deeply or
   * not.
   */
  recurseUntrackedDirs?: boolean
  /** Flag indicating whether unmodified files are in the diff. */
  includeUnmodified?: boolean
  /** If enabled, then Typechange delta records are generated. */
  includeTypechange?: boolean
  /**
   * Event with `includeTypechange`, the tree returned generally shows a
   * deleted blob. This flag correctly labels the tree transitions as a
   * typechange record with the `newFile`'s mode set to tree.
   *
   * Note that the tree SHA will not be available.
   */
  includeTypechangeTrees?: boolean
  /** Flag indicating whether file mode changes are ignored. */
  ignoreFilemode?: boolean
  /** Flag indicating whether all submodules should be treated as unmodified. */
  ignoreSubmodules?: boolean
  /** Flag indicating whether case insensitive filenames should be used. */
  ignoreCase?: boolean
  /**
   * If pathspecs are specified, this flag means that they should be applied
   * as an exact match instead of a fnmatch pattern.
   */
  disablePathspecMatch?: boolean
  /**
   * Disable updating the `binary` flag in delta records. This is useful when
   * iterating over a diff if you don't need hunk and data callbacks and want
   * to avoid having to load a file completely.
   */
  skipBinaryCheck?: boolean
  /**
   * When diff finds an untracked directory, to match the behavior of core
   * Git, it scans the contents for ignored and untracked files. If all
   * contents are ignored, then the directory is ignored; if any contents are
   * not ignored, then the directory is untracked. This is extra work that
   * may not matter in many cases.
   *
   * This flag turns off that scan and immediately labels an untracked
   * directory as untracked (changing the behavior to not match core git).
   */
  enableFastUntrackedDirs?: boolean
  /**
   * When diff finds a file in the working directory with stat information
   * different from the index, but the OID ends up being the same, write the
   * correct stat information into the index. Note: without this flag, diff
   * will always leave the index untouched.
   */
  updateIndex?: boolean
  /** Include unreadable files in the diff */
  includeUnreadable?: boolean
  /** Include unreadable files in the diff as untracked files */
  includeUnreadableAsUntracked?: boolean
  /** Treat all files as text, disabling binary attributes and detection. */
  forceText?: boolean
  /** Treat all files as binary, disabling text diffs */
  forceBinary?: boolean
  /** Ignore all whitespace */
  ignoreWhitespace?: boolean
  /** Ignore changes in the amount of whitespace */
  ignoreWhitespaceChange?: boolean
  /** Ignore whitespace at the end of line */
  ignoreWhitespaceEol?: boolean
  /** Ignore blank lines */
  ignoreBlankLines?: boolean
  /**
   * When generating patch text, include the content of untracked files.
   *
   * This automatically turns on `includeUntracked` but it does not turn on
   * `recurseUntrackedDirs`. Add that flag if you want the content of every
   * single untracked file.
   */
  showUntrackedContent?: boolean
  /**
   * When generating output, include the names of unmodified files if they
   * are included in the `Diff`. Normally these are skipped in the formats
   * that list files (e.g. name-only, name-status, raw). Even with this these
   * will not be included in the patch format.
   */
  showUnmodified?: boolean
  /** Use the "patience diff" algorithm */
  patience?: boolean
  /** Take extra time to find the minimal diff */
  minimal?: boolean
  /**
   * Include the necessary deflate/delta information so that `git-apply` can
   * apply given diff information to binary files.
   */
  showBinary?: boolean
  /**
   * Use a heuristic that takes indentation and whitespace into account
   * which generally can produce better diffs when dealing with ambiguous
   * diff hunks.
   */
  indentHeuristic?: boolean
  /**
   * Set the number of unchanged lines that define the boundary of a hunk
   * (and to display before and after).
   *
   * The default value for this is 3.
   */
  contextLines?: number
  /**
   * Set the maximum number of unchanged lines between hunk boundaries before
   * the hunks will be merged into one.
   *
   * The default value for this is 0.
   */
  interhunkLines?: number
  /** The default value for this is `core.abbrev` or 7 if unset. */
  idAbbrev?: number
  /**
   * Maximum size (in bytes) above which a blob will be marked as binary
   * automatically.
   *
   * A negative value will disable this entirely.
   *
   * The default value for this is 512MB.
   */
  maxSize?: number
  /**
   * The virtual "directory" to prefix old file names with in hunk headers.
   *
   * The default value for this is "a".
   */
  oldPrefix?: string
  /**
   * The virtual "directory" to prefix new file names with in hunk headers.
   *
   * The default value for this is "b".
   */
  newPrefix?: string
  /** Add to the array of paths/fnmatch patterns to constrain the diff. */
  pathspecs?: Array<string>
}
export interface IndexEntry {
  ctime: Date
  mtime: Date
  dev: number
  ino: number
  mode: number
  uid: number
  gid: number
  fileSize: number
  id: string
  flags: number
  flagsExtended: number
  /**
   * The path of this index entry as a byte vector. Regardless of the
   * current platform, the directory separator is an ASCII forward slash
   * (`0x2F`). There are no terminating or internal NUL characters, and no
   * trailing slashes. Most of the time, paths will be valid utf-8 — but
   * not always. For more information on the path storage format, see
   * [these git docs](https://github.com/git/git/blob/a08a83db2bf27f015bec9a435f6d73e223c21c5e/Documentation/technical/index-format.txt#L107-L124).
   * Note that libgit2 will take care of handling the prefix compression mentioned there.
   */
  path: Buffer
}
export interface IndexOnMatchCallbackArgs {
  /** The path of entry. */
  path: string
  /** The patchspec that matched it. */
  pathspec: string
}
export interface IndexAddAllOptions {
  /**
   * Files that are ignored will be skipped (unlike `addPath`). If a file is
   * already tracked in the index, then it will be updated even if it is
   * ignored. Pass the `force` flag to skip the checking of ignore rules.
   */
  force?: boolean
  /**
   * The `pathspecs` are a list of file names or shell glob patterns that
   * will matched against files in the repository's working directory. Each
   * file that matches will be added to the index (either updating an
   * existing entry or adding a new entry). You can disable glob expansion
   * and force exact matching with the `disablePathspecMatch` flag.
   */
  disablePathspecMatch?: boolean
  /**
   * To emulate `git add -A` and generate an error if the pathspec contains
   * the exact path of an ignored file (when not using `force`), add the
   * `checkPathspec` flag. This checks that each entry in `pathspecs`
   * that is an exact match to a filename on disk is either not ignored or
   * already in the index. If this check fails, the function will return
   * an error.
   */
  checkPathspec?: boolean
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the working directory immediately before it is added to /
   * updated in the index. Returning zero will add the item to the index,
   * greater than zero will skip the item, and less than zero will abort the
   * scan an return an error to the caller.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}
/**
 * - `Any` : Match any index stage.
 * - `Normal` : A normal staged file in the index.
 * - `Ancestor` : The ancestor side of a conflict.
 * - `Ours` : The "ours" side of a conflict.
 * - `Theirs` : The "theirs" side of a conflict.
 */
export type IndexStage = 'Any' | 'Normal' | 'Ancestor' | 'Ours' | 'Theirs';
export interface IndexRemoveOptions {
  stage?: IndexStage
}
export interface IndexRemoveAllOptions {
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the index immediately before it is removed. Return 0 to remove
   * the item, > 0 to skip the item, and < 0 to abort the scan.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}
export interface IndexUpdateAllOptions {
  /**
   * If you provide a callback function, it will be invoked on each matching
   * item in the index immediately before it is updated (either refreshed or
   * removed depending on working directory state). Return 0 to proceed with
   * updating the item, > 0 to skip the item, and < 0 to abort the scan.
   */
  onMatch?: (args: IndexOnMatchCallbackArgs) => number
}
export interface AddMailmapEntryData {
  realName?: string
  realEmail?: string
  replaceName?: string
  replaceEmail: string
}
/**
 * Create a mailmap from the contents of a string.
 *
 * The format of the string should follow the rules of the mailmap file:
 * ```
 * # Comment line (ignored)
 * Seokju Me <seokju.me@toss.im> Seokju Na <seokju.me@gmail.com>
 * ```
 *
 * @param {string} content - Content of the mailmap file
 * @returns A new mailmap object
 * @throws An error if operation failed
 *
 * @category Mailmap
 *
 * @signature
 * ```ts
 * function createMailmapFromBuffer(content: string): Mailmap;
 * ```
 */
export declare function createMailmapFromBuffer(content: string): Mailmap
export type FileFavor = /**
 * When a region of a file is changed in both branches, a conflict will be
 * recorded in the index so that git_checkout can produce a merge file with
 * conflict markers in the working directory. This is the default.
 */
'Normal' | /**
 * When a region of a file is changed in both branches, the file created
 * in the index will contain the "ours" side of any conflicting region.
 * The index will not record a conflict.
 */
'Ours' | /**
 * When a region of a file is changed in both branches, the file created
 * in the index will contain the "theirs" side of any conflicting region.
 * The index will not record a conflict.
 */
'Theirs' | /**
 * When a region of a file is changed in both branches, the file created
 * in the index will contain each unique line from each side, which has
 * the result of combining both files. The index will not record a conflict.
 */
'Union';
export interface MergeOptions {
  /** Detect file renames */
  findRenames?: boolean
  /**
   * If a conflict occurs, exit immediately instead of attempting to continue
   * resolving conflicts
   */
  failOnConflict?: boolean
  /** Do not write the REUC extension on the generated index */
  skipReuc?: boolean
  /**
   * If the commits being merged have multiple merge bases, do not build a
   * recursive merge base (by merging the multiple merge bases), instead
   * simply use the first base.
   */
  noRecursive?: boolean
  /** Similarity to consider a file renamed (default 50) */
  renameThreshold?: number
  /**
   *  Maximum similarity sources to examine for renames (default 200).
   * If the number of rename candidates (add / delete pairs) is greater
   * than this value, inexact rename detection is aborted. This setting
   * overrides the `merge.renameLimit` configuration value.
   */
  targetLimit?: number
  /**
   * Maximum number of times to merge common ancestors to build a
   * virtual merge base when faced with criss-cross merges.  When
   * this limit is reached, the next ancestor will simply be used
   * instead of attempting to merge it.  The default is unlimited.
   */
  recursionLimit?: number
  /** Specify a side to favor for resolving conflicts */
  filFavor?: FileFavor
  /** Create standard conflicted merge files */
  standardStyle?: boolean
  /** Create diff3-style file */
  diff3Style?: boolean
  /** Condense non-alphanumeric regions for simplified diff file */
  simplifyAlnum?: boolean
  /** Ignore all whitespace */
  ignoreWhitespace?: boolean
  /** Ignore changes in amount of whitespace */
  ignoreWhitespaceChange?: boolean
  /** Ignore whitespace at end of line */
  ignoreWhitespaceEol?: boolean
  /** Use the "patience diff" algorithm */
  patience?: boolean
  /** Take extra time to find minimal diff */
  minimal?: boolean
}
export interface MergeAnalysis {
  /** No merge is possible. */
  none: boolean
  /**
   * A "normal" merge; both HEAD and the given merge input have diverged
   * from their common ancestor. The divergent commits must be merged.
   */
  normal: boolean
  /**
   * All given merge inputs are reachable from HEAD, meaning the
   * repository is up-to-date and no merge needs to be performed.
   */
  upToDate: boolean
  /**
   * The given merge input is a fast-forward from HEAD and no merge
   * needs to be performed.  Instead, the client can check out the
   * given merge input.
   */
  fastForward: boolean
  /**
   * The HEAD of the current repository is "unborn" and does not point to
   * a valid commit.  No merge can be performed, but the caller may wish
   * to simply set HEAD to the target commit(s).
   */
  unborn: boolean
}
export interface MergePreference {
  /**
   * No configuration was found that suggests a preferred behavior for
   * merge.
   */
  none: boolean
  /**
   * There is a `merge.ff=false` configuration setting, suggesting that
   * the user does not want to allow a fast-forward merge.
   */
  noFastForward: boolean
  /**
   * There is a `merge.ff=only` configuration setting, suggesting that
   * the user only wants fast-forward merges.
   */
  fastForwardOnly: boolean
}
export interface MergeAnalysisResult {
  analysis: MergeAnalysis
  preference: MergePreference
}
/**
 * - `Any` : Any kind of git object
 * - `Commit` : An object which corresponds to a git commit
 * - `Tree` : An object which corresponds to a git tree
 * - `Blob` : An object which corresponds to a git blob
 * - `Tag` : An object which corresponds to a git tag
 */
export type ObjectType = 'Any' | 'Commit' | 'Tree' | 'Blob' | 'Tag';
/**
 * Check if given string is valid Oid.
 *
 * @category Oid
 * @signature
 * ```ts
 * function isValidOid(value: string): boolean;
 * ```
 *
 * @param {string} value - String to check if is valid Oid.
 * @returns Returns `false` if the string is empty, is longer than 40 hex
 * characters, or contains any non-hex characters.
 */
export declare function isValidOid(value: string): boolean
/**
 * Test if this Oid is all zeros.
 *
 * @category Oid
 * @signature
 * ```ts
 * function isZeroOid(value: string): boolean;
 * ```
 *
 * @param {string} value - String to check if is zero Oid.
 * @returns Returns `true` if the string is zero Oid.
 * @example
 * ```ts
 * import { zeroOid, isZeroOid } from 'es-git';
 *
 * console.assert(isZeroOid(zeroOid());
 * ```
 */
export declare function isZeroOid(value: string): boolean
/**
 * Creates an all zero Oid structure.
 *
 * @category Oid
 * @signature
 * ```ts
 * function zeroOid(): string;
 * ```
 *
 * @returns Zero Oid string.
 */
export declare function zeroOid(): string
/**
 * Hashes the provided data as an object of the provided type, and returns
 * an Oid corresponding to the result. This does not store the object
 * inside any object database or repository.
 *
 * @category Oid
 * @signature
 * ```ts
 * function hashObjectOid(objType: ObjectType, bytes: Buffer): string;
 * ```
 *
 * @param {ObjectType} objType - Git object type.
 * @param {Buffer} bytes - Data to hashed.
 * @returns Hashed string.
 */
export declare function hashObjectOid(objType: ObjectType, bytes: Buffer): string
/**
 * Hashes the content of the provided file as an object of the provided type,
 * and returns an Oid corresponding to the result. This does not store the object
 * inside any object database or repository.
 *
 * @category Oid
 * @signature
 * ```ts
 * function hashFileOid(objType: ObjectType, path: string): string;
 * ```
 *
 * @param {ObjectType} objType - Git object type.
 * @param {string} path - File path to make hash.
 * @returns Hashed string.
 */
export declare function hashFileOid(objType: ObjectType, path: string): string
/**
 * - `Direct` : A reference which points at an object id.
 * - `Symbolic` : A reference which points at another reference.
 */
export type ReferenceType = 'Direct' | 'Symbolic';
/**
 * Ensure the reference name is well-formed.
 *
 * Validation is performed as if `ReferenceFormat.AllowOnelevel`
 * was given to `normalizeReferenceName`  No normalization is performed, however.
 *
 * @category Reference
 * @signature
 * ```ts
 * function isValidReferenceName(refname: string): boolean;
 * ```
 *
 * @param {string} refname - Reference name to check if it is valid.
 * @returns Returns `true` if reference name is valid.
 *
 * @example
 * ```ts
 * import { isValidReferenceName } from 'es-git';
 *
 * console.assert(isValidReferenceName("HEAD"));
 * console.assert(isValidReferenceName("refs/heads/main"));
 *
 * // But:
 * console.assert(!isValidReferenceName("main"));
 * console.assert(!isValidReferenceName("refs/heads/*"));
 * console.assert(!isValidReferenceName("foo//bar"));
 * ```
 */
export declare function isValidReferenceName(refname: string): boolean
/**
 * - `ReferenceFormat.Normal` : No particular normalization.
 * - `ReferenceFormat.AllowOnelevel` : Control whether one-level refname are accepted
 * (i.e., refnames that do not contain multiple `/`-separated components). Those are
 * expected to be written only using uppercase letters and underscore
 * (e.g. `HEAD`, `FETCH_HEAD`).
 * - `ReferenceFormat.RefspecPattern` : Interpret the provided name as a reference pattern
 * for a refspec (as used with remote repositories). If this option is enabled, the name
 * is allowed to contain a single `*` in place of a full pathname
 * components (e.g., `foo/*\/bar` but not `foo/bar*`).
 * - `ReferenceFormat.RefspecShorthand` : Interpret the name as part of a refspec in shorthand
 * form so the `AllowOnelevel` naming rules aren't enforced and `main` becomes a valid name.
 */
export enum ReferenceFormat {
  Normal = 0,
  AllowOnelevel = 1,
  RefspecPattern = 2,
  RefspecShorthand = 4
}
/**
 * Normalize reference name and check validity.
 *
 * This will normalize the reference name by collapsing runs of adjacent
 * slashes between name components into a single slash. It also validates
 * the name according to the following rules:
 *
 * 1. If `ReferenceFormat.AllowOnelevel` is given, the name may
 *    contain only capital letters and underscores, and must begin and end
 *    with a letter. (e.g. "HEAD", "ORIG_HEAD").
 * 2. The flag `ReferenceFormat.RefspecShorthand` has an effect
 *    only when combined with `ReferenceFormat.AllowOnelevel`. If
 *    it is given, "shorthand" branch names (i.e. those not prefixed by
 *    `refs/`, but consisting of a single word without `/` separators)
 *    become valid. For example, "main" would be accepted.
 * 3. If `ReferenceFormat.RefspecPattern` is given, the name may
 *    contain a single `*` in place of a full pathname component (e.g.
 *    `foo/*\/bar`, `foo/bar*`).
 * 4. Names prefixed with "refs/" can be almost anything. You must avoid
 *    the characters '~', '^', ':', '\\', '?', '[', and '*', and the
 *    sequences ".." and "@{" which have special meaning to revparse.
 *
 * @category Reference
 * @signature
 * ```ts
 * function normalizeReferenceName(refname: string, format?: number | null | undefined): string | null;
 * ```
 *
 * @param {string} refname - Reference name to normalize.
 * @param {number} [format] - Reference format flags which used for normalize.
 *
 * @returns If the reference passes validation, it is returned in normalized form,
 * otherwise an `null` is returned.
 *
 * @example
 * ```ts
 * import { normalizeReferenceName, ReferenceFormat } from 'es-git';
 *
 * console.assert(
 *   normalizeReferenceName('foo//bar'),
 *   'foo/bar'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'HEAD',
 *     ReferenceFormat.AllowOnelevel
 *   ),
 *   'HEAD'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'refs/heads/*',
 *     ReferenceFormat.RefspecPattern
 *   ),
 *   'refs/heads/*'
 * );
 * console.assert(
 *   normalizeReferenceName(
 *     'main',
 *     ReferenceFormat.AllowOnelevel | ReferenceFormat.RefspecShorthand
 *   ),
 *   'main'
 * );
 * ```
 */
export declare function normalizeReferenceName(refname: string, format?: number | undefined | null): string | null
export interface RenameReferenceOptions {
  /**
   * If the force flag is not enabled, and there's already a reference with
   * the given name, the renaming will fail.
   */
  force?: boolean
  logMessage?: string
}
/**
 * - `Fetch` : Fetch direction.
 * - `Push` : Push direction.
 */
export type Direction = 'Fetch' | 'Push';
/**
 * A data object to represent a git [refspec][1].
 *
 * Refspecs are currently mainly accessed/created through a `Remote`.
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-The-Refspec
 */
export interface Refspec {
  direction: Direction
  /** The source specifier. */
  src: string
  /** The destination specifier. */
  dst: string
  /** Force update setting. */
  force: boolean
}
/** A interface to represent git credentials in libgit2. */
export type Credential = {
 type: 'Default';
} | {
 type: 'SSHKeyFromAgent';
 username?: string;
} | {
 type: 'SSHKeyFromPath';
 username?: string;
 publicKeyPath?: string;
 privateKeyPath: string;
 passphrase?: string;
} | {
 type: 'SSHKey';
 username?: string;
 publicKey?: string;
 privateKey: string;
 passphrase?: string;
} | {
 type: 'Plain';
 username?: string;
 password: string;
};
export interface ProxyOptions {
  /**
   * Try to auto-detect the proxy from the git configuration.
   *
   * Note that this will override `url` specified before.
   */
  auto?: boolean
  /**
   * Specify the exact URL of the proxy to use.
   *
   * Note that this will override `auto` specified before.
   */
  url?: string
}
/**
 * - `Unspecified` : Use the setting from the configuration.
 * - `On` : Force pruning on.
 * - `Off` : Force pruning off
 */
export type FetchPrune = 'Unspecified' | 'On' | 'Off';
/**
 * - `Unspecified` : Use the setting from the remote's configuration
 * - `Auto` : Ask the server for tags pointing to objects we're already downloading
 * - `None` : Don't ask for any tags beyond the refspecs
 * - `All` : Ask for all the tags
 */
export type AutotagOption = 'Unspecified' | 'Auto' | 'None' | 'All';
/**
 * - `None` : Do not follow any off-site redirects at any stage of the fetch or push.
 * - `Initial` : Allow off-site redirects only upon the initial request. This is the default.
 * - `All` : Allow redirects at any stage in the fetch or push.
 */
export type RemoteRedirect = 'None' | 'Initial' | 'All';
export interface FetchOptions {
  credential?: Credential
  /** Set the proxy options to use for the fetch operation. */
  proxy?: ProxyOptions
  /** Set whether to perform a prune after the fetch. */
  prune?: FetchPrune
  /**
   * Set fetch depth, a value less or equal to 0 is interpreted as pull
   * everything (effectively the same as not declaring a limit depth).
   */
  depth?: number
  /**
   * Set how to behave regarding tags on the remote, such as auto-downloading
   * tags for objects we're downloading or downloading all of them.
   *
   * The default is to auto-follow tags.
   */
  downloadTags?: AutotagOption
  /**
   * Set remote redirection settings; whether redirects to another host are
   * permitted.
   *
   * By default, git will follow a redirect on the initial request
   * (`/info/refs`), but not subsequent requests.
   */
  followRedirects?: RemoteRedirect
  /** Set extra headers for this fetch operation. */
  customHeaders?: Array<string>
}
/** Options to control the behavior of a git push. */
export interface PushOptions {
  credential?: Credential
  /** Set the proxy options to use for the push operation. */
  proxy?: ProxyOptions
  /**
   * If the transport being used to push to the remote requires the creation
   * of a pack file, this controls the number of worker threads used by the
   * packbuilder when creating that pack file to be sent to the remote.
   *
   * If set to 0, the packbuilder will auto-detect the number of threads to
   * create, and the default value is 1.
   */
  pbParallelism?: number
  /**
   * Set remote redirection settings; whether redirects to another host are
   * permitted.
   *
   * By default, git will follow a redirect on the initial request
   * (`/info/refs`), but not subsequent requests.
   */
  followRedirects?: RemoteRedirect
  /** Set extra headers for this push operation. */
  customHeaders?: Array<string>
  /** Set "push options" to deliver to the remote. */
  remoteOptions?: Array<string>
}
export interface CreateRemoteOptions {
  fetchRefspec?: string
}
export interface FetchRemoteOptions {
  /** Options which can be specified to various fetch operations. */
  fetch?: FetchOptions
  reflogMsg?: string
}
export interface PruneOptions {
  credential?: Credential
}
/**
 * Available states are `Clean`, `Merge`, `Revert`, `RevertSequence`, `CherryPick`,
 * `CherryPickSequence`, `Bisect`, `Rebase`, `RebaseInteractive`, `RebaseMerge`,
 * `ApplyMailbox`, `ApplyMailboxOrRebase`.
 */
export type RepositoryState = 'Clean' | 'Merge' | 'Revert' | 'RevertSequence' | 'CherryPick' | 'CherryPickSequence' | 'Bisect' | 'Rebase' | 'RebaseInteractive' | 'RebaseMerge' | 'ApplyMailbox' | 'ApplyMailboxOrRebase';
/** Mode options for `RepositoryInitOptions`. */
export enum RepositoryInitMode {
  /** Use permissions configured by umask (default) */
  SharedUnmask = 0,
  /**
   * Use `--shared=group` behavior, chmod'ing the new repo to be
   * group writable and "g+sx" for sticky group assignment.
   */
  SharedGroup = 1533,
  /** Use `--shared=all` behavior, adding world readability. */
  SharedAll = 1535
}
export interface RepositoryInitOptions {
  /**
   * Create a bare repository with no working directory.
   *
   * Defaults to `false`.
   */
  bare?: boolean
  /**
   * Return an error if the repository path appears to already be a git
   * repository.
   *
   * Defaults to `false`.
   */
  noReinit?: boolean
  /**
   * Normally a '/.git/' will be appended to the repo path for non-bare repos
   * (if it is not already there), but passing this flag prevents that
   * behavior.
   *
   * Defaults to `false`.
   */
  noDotgitDir?: boolean
  /**
   * Make the repo path (and workdir path) as needed. The ".git" directory
   * will always be created regardless of this flag.
   *
   * Defaults to `true`.
   */
  mkdir?: boolean
  /**
   * Make the repo path (and workdir path) as needed. The ".git" directory
   * will always be created regardless of this flag.
   *
   * Defaults to `true`.
   */
  mkpath?: boolean
  /** Set to one of the `RepositoryInit` constants, or a custom value. */
  mode?: number
  /**
   * Enable or disable using external templates.
   *
   * If enabled, then the `template_path` option will be queried first, then
   * `init.templatedir` from the global config, and finally
   * `/usr/share/git-core-templates` will be used (if it exists).
   *
   * Defaults to `true`.
   */
  externalTemplate?: boolean
  /**
   * When the `externalTemplate` option is set, this is the first location
   * to check for the template directory.
   *
   * If this is not configured, then the default locations will be searched
   * instead.
   */
  templatePath?: string
  /**
   * The path to the working directory.
   *
   * If this is a relative path it will be evaluated relative to the repo
   * path. If this is not the "natural" working directory, a .git gitlink
   * file will be created here linking to the repo path.
   */
  workdirPath?: string
  /**
   * If set, this will be used to initialize the "description" file in the
   * repository instead of using the template content.
   */
  description?: string
  /**
   * The name of the head to point HEAD at.
   *
   * If not configured, this will be taken from your git configuration.
   * If this begins with `refs/` it will be used verbatim;
   * otherwise `refs/heads/` will be prefixed.
   */
  initialHead?: string
  /**
   * If set, then after the rest of the repository initialization is
   * completed an `origin` remote will be added pointing to this URL.
   */
  originUrl?: string
}
export interface RepositoryOpenOptions {
  /**
   * If this option is `true`, the path must point directly to a repository; otherwise,
   * this may point to a subdirectory of a repository, and `open` will search up through parent
   * directories.
   */
  noSearch?: boolean
  /**
   * If this option is `true`, the search through parent directories will not cross
   * a filesystem boundary (detected when the stat st_dev field changes).
   */
  crossFs?: boolean
  /**
   * If this option is `true`, force opening the repository as bare event if it isn't, ignoring
   * any working directory, and defer loading the repository configuration for performance.
   */
  bare?: boolean
  /** If this options is `true`, don't try appending `/.git` to `path`. */
  noDotgit?: boolean
  /**
   * If this option is `true`, `open` will ignore other options and `ceilingDirs`, and respect
   * the same environment variables git does.
   * Note, however, that `path` overrides `$GIT_DIR`.
   */
  fromEnv?: boolean
  /**
   * ceiling_dirs specifies a list of paths that the search through parent
   * directories will stop before entering.
   */
  ceilingDirs?: Array<string>
}
export interface RepositoryCloneOptions {
  /**
   * Indicate whether the repository will be cloned as a bare repository or
   * not.
   */
  bare?: boolean
  /**
   * Specify the name of the branch to check out after the clone.
   *
   * If not specified, the remote's default branch will be used.
   */
  branch?: string
  /**
   * Clone a remote repository, initialize and update its submodules
   * recursively.
   *
   * This is similar to `git clone --recursive`.
   */
  recursive?: boolean
  /** Options which can be specified to various fetch operations. */
  fetch?: FetchOptions
}
export interface ExtractedSignature {
  /** GPG signature of the commit, or null if the commit is not signed. */
  signature: string
  /** Signed data of the commit. */
  signedData: string
}
/**
 * Creates a new repository in the specified folder.
 *
 * @category Repository
 * @signature
 * ```ts
 * function initRepository(
 *   path: string,
 *   options?: RepositoryInitOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined,
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to create new repository.
 * @param {RepositoryInitOptions} [options] - Options which can be used to configure
 * how a repository is initialized.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns A new repository.
 *
 * @example
 *
 * Basic example.
 *
 * ```ts
 * import { initRepository } from 'es-git';
 *
 * const repo = await initRepository('/path/to/repo');
 * ```
 *
 * Create bare repository.
 *
 * ```ts
 * import { initRepository } from 'es-git';
 *
 * const repo = await initRepository('/path/to/repo.git', {
 *   bare: true,
 * });
 * ```
 */
export declare function initRepository(path: string, options?: RepositoryInitOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>
/**
 * Attempt to open an already-existing repository at `path`.
 *
 * @category Repository
 * @signature
 * ```ts
 * function openRepository(
 *   path: string,
 *   options?: RepositoryOpenOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined,
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to repository already-existing.
 * @param {RepositoryOpenOptions} [options] - Options which can be used to configure
 * how a repository is initialized.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns Opened repository.
 *
 * @example
 *
 * Basic example.
 *
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('/path/to/repo');
 * ```
 *
 * Open bare repository.
 *
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('/path/to/repo.git', {
 *   bare: true,
 * });
 * ```
 */
export declare function openRepository(path: string, options?: RepositoryOpenOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>
/**
 * Attempt to open an already-existing repository at or above `path`.
 *
 * This starts at `path` and looks up the filesystem hierarchy
 * until it finds a repository.
 *
 * @category Repository
 * @signature
 * ```ts
 * function discoverRepository(path: string, signal?: AbortSignal | null | undefined): Promise<Repository>;
 * ```
 *
 * @param {string} path - Directory path to discover repository.
 * @param {AbortSignal} [signal] - Abort signal.
 *
 * @returns Git repository.
 */
export declare function discoverRepository(path: string, signal?: AbortSignal | undefined | null): Promise<Repository>
/**
 * Clone a remote repository.
 *
 * This will use the options configured so far to clone the specified URL
 * into the specified local path.
 *
 * @category Repository
 *
 * @signature
 * ```ts
 * function cloneRepository(
 *   url: string,
 *   path: string,
 *   options?: RepositoryCloneOptions | null | undefined,
 *   signal?: AbortSignal | null | undefined
 * ): Promise<Repository>;
 * ```
 *
 * @param {string} url - Remote URL for repository.
 * @param {string} path - Local path to clone repository.
 * @param {RepositoryCloneOptions|undefined|null} [options] - Clone options for repository.
 * @param {AbortSignal|undefined|null} [signal] - Abort signal.
 * @returns Repository instance
 *
 * @example
 *
 * Clone repository using `https://` protocol.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * const repo = await cloneRepository(
 *   'https://github.com/toss/es-git',
 *   '/path/to/clone',
 * );
 * ```
 *
 * Clone repository using `git://` protocol.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * const repo = await cloneRepository(
 *   'git@github.com:toss/es-git',
 *   '/path/to/clone',
 * );
 * ```
 *
 * Clone repository with authentication.
 *
 * ```ts
 * import { cloneRepository } from 'es-git';
 *
 * // Authenticate using ssh-agent
 * const repo = await cloneRepository('git@github.com:toss/es-git', '.', {
 *   fetch: {
 *     credential: {
 *       type: 'SSHKeyFromAgent',
 *     },
 *   },
 * });
 * ```
 */
export declare function cloneRepository(url: string, path: string, options?: RepositoryCloneOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<Repository>
/**
 * Flags for the revparse.
 * - `Single` : The spec targeted a single object.
 * - `Range` : The spec targeted a range of commits.
 * - `MergeBase` : The spec used the `...` operator, which invokes special semantics.
 */
export enum RevparseMode {
  Single = 1,
  Range = 2,
  MergeBase = 4
}
/**
 * Check revparse mode contains specific flags.
 *
 * @category Revparse
 * @signature
 * ```ts
 * function revparseModeContains(source: number, target: number): boolean;
 * ```
 *
 * @param {number} source - Source flags.
 * @param {number} target - Target flags.
 * @returns Returns `true` is source flags contains target flags.
 *
 * @example
 * ```ts
 * import { openRepository, revparseModeContains, RevparseMode } from 'es-git';
 *
 * const repo = await openRepository('.');
 * const spec = repo.revparse('main..other');
 *
 * console.assert(revparseModeContains(spec.mode, RevparseMode.Range));
 * ```
 */
export declare function revparseModeContains(source: number, target: number): boolean
/** A revspec represents a range of revisions within a repository. */
export interface Revspec {
  /** Access the `from` range of this revspec. */
  from?: string
  /** Access the `to` range of this revspec. */
  to?: string
  /** Returns the intent of the revspec. */
  mode: number
}
export enum RevwalkSort {
  None = 0,
  Topological = 1,
  Time = 2,
  Reverse = 4
}
/**
 * A Signature is used to indicate authorship of various actions throughout the
 * library.
 * Signatures contain a name, email, and timestamp.
 */
export interface Signature {
  /** Name on the signature. */
  name: string
  /** Email on the signature. */
  email: string
  /** Time in seconds, from epoch */
  timestamp: number
}
export interface SignatureTimeOptions {
  /** Time in seconds, from epoch */
  timestamp: number
  /** Timezone offset, in minutes */
  offset?: number
}
/**
 * Create a new action signature.
 *
 * @category Signature
 * @signature
 * ```ts
 * function createSignature(
 *   name: string,
 *   email: string,
 *   timeOptions?: SignatureTimeOptions | null | undefined,
 * ): Signature;
 * ```
 *
 * @param {string} name - Name on the signature.
 * @param {string} email - Email on the signature.
 * @param {SignatureTimeOptions} [timeOptions] - Time options for signature.
 *
 * @returns
 *
 * @example
 * ```ts
 * import { createSignature } from 'es-git';
 *
 * const author = createSignature(
 *   'Seokju Na',
 *   'seokju.me@toss.im',
 * );
 * ```
 */
export declare function createSignature(name: string, email: string, timeOptions?: SignatureTimeOptions | undefined | null): Signature
export interface SignaturePayload {
  /** Name on the signature. */
  name: string
  /** Email on the signature. */
  email: string
  timeOptions?: SignatureTimeOptions
}
/**
 * Options for saving a stash.
 *
 * All fields are optional. If not provided, sensible defaults will be used.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 *
 * // Basic usage
 * repo.stashSave({
 *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' }
 * });
 *
 * // With options
 * repo.stashSave({
 *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
 *   message: 'WIP: feature implementation',
 *   includeUntracked: true
 * });
 * ```
 */
export interface StashSaveOptions {
  /**
   * The identity of the person performing the stashing.
   * If not provided, uses the repository's default signature.
   */
  stasher?: SignaturePayload
  /**
   * Description along with the stashed state.
   * If not provided, a default message will be generated.
   */
  message?: string
  /**
   * Whether to stash untracked files.
   * Default: false
   */
  includeUntracked?: boolean
  /**
   * Whether to stash ignored files.
   * Default: false
   */
  includeIgnored?: boolean
  /**
   * Whether to retain the index after stashing.
   * If true, staged changes remain in the index after stashing.
   * Default: false
   */
  keepIndex?: boolean
}
/**
 * Options for applying a stash.
 *
 * Controls how a stash is applied to the working directory.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 *
 * // Default apply
 * repo.stashApply(0);
 *
 * // With options
 * repo.stashApply(0, { reinstantiateIndex: true });
 * ```
 */
export interface StashApplyOptions {
  /**
   * Whether to reinstall the index from the stash.
   * If true, the index state recorded in the stash is also restored.
   * Default: false
   */
  reinstantiateIndex?: boolean
}
export interface Status {
  current: boolean
  indexNew: boolean
  indexModified: boolean
  indexDeleted: boolean
  indexRenamed: boolean
  indexTypechange: boolean
  wtNew: boolean
  wtModified: boolean
  wtDeleted: boolean
  wtTypechange: boolean
  wtRenamed: boolean
  wtUnreadable: boolean
  ignored: boolean
  conflicted: boolean
}
/**
 * - `Index` : Only gives status based on HEAD to index comparison, not looking at
 * working directory changes.
 * - `Workdir` : Only gives status based on index to working directory comparison, not
 * comparing the index to the HEAD.
 * - `IndexAndWorkdi` : The default, this roughly matches `git status --porcelain` regarding
 * which files are included and in what order.
 */
export type StatusShow = 'Index' | 'Workdir' | 'IndexAndWorkdir';
export interface StatusOptions {
  /**
   * Select the files on which to report status.
   * The default, if unspecified, is to show the index and the working directory.
   */
  show?: StatusShow
  /**
   * Path patterns to match (using fnmatch-style matching).
   * If the `disablePathspecMatch` option is given, then this is a literal
   * path to match. If this is not called, then there will be no patterns to
   * match and the entire directory will be used.
   */
  pathspecs?: Array<string>
  /**
   * Flag whether untracked files will be included.
   * Untracked files will only be included if the workdir files are included
   * in the status "show" option.
   */
  includeUntracked?: boolean
  includeIgnored?: boolean
  includeUnmodified?: boolean
  excludeSubmodules?: boolean
  recurseUntrackedDirs?: boolean
  disablePathspecMatch?: boolean
  recurseIgnoredDirs?: boolean
  renamesHeadToIndex?: boolean
  renamesIndexToWorkdir?: boolean
  sortCaseSensitively?: boolean
  sortCaseInsensitively?: boolean
  renamesFromRewrites?: boolean
  noRefresh?: boolean
  updateIndex?: boolean
  includeUnreadable?: boolean
  includeUnreadableAsUntracked?: boolean
  renameThreshold?: number
}
/**
 * Determine whether a tag name is valid, meaning that (when prefixed with refs/tags/) that
 * it is a valid reference name, and that any additional tag name restrictions are imposed
 * (eg, it cannot start with a -).
 *
 * @category Tag
 * @signature
 * ```ts
 * function isValidTagName(tagName: string): boolean;
 * ```
 *
 * @param {string} tagName - Tag name to check if it is valid.
 * @returns Returns `true` if tag name is valid.
 */
export declare function isValidTagName(tagName: string): boolean
export interface CreateTagOptions {
  /**
   * Signature for tagger.
   *
   * If not provided, default signature of repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  tagger?: SignaturePayload
  /** If `force` is true and a reference already exists with the given name, it'll be replaced. */
  force?: boolean
}
export interface CreateAnnotationTagOptions {
  /**
   * Signature for tagger.
   *
   * If not provided, default signature of repository will be used.
   * If there is no default signature set for the repository, an error will occur.
   */
  tagger?: SignaturePayload
}
export interface CreateLightweightTagOptions {
  /** If `force` is true and a reference already exists with the given name, it'll be replaced. */
  force?: boolean
}
/**
 * - `PreOrder` : Runs the traversal in pre-order.
 * - `PostOrder` : Runs the traversal in post-order.
 */
export type TreeWalkMode = 'PreOrder' | 'PostOrder';
/**
 * A structure to represent an annotated commit, the input to merge and rebase.
 *
 * An annotated commit contains information about how it was looked up, which
 * may be useful for functions like merge or rebase to provide context to the
 * operation.
 */
export declare class AnnotatedCommit {
  /**
   * Gets the commit ID that the given Annotated Commit refers to.
   *
   * @category AnnotatedCommit/Methods
   * @signature
   * ```ts
   * class AnnotatedCommit {
   *   id(): string;
   * }
   * ```
   *
   * @returns The commit ID that this Annotated Commit refers to.
   */
  id(): string
  /**
   * Get the refname that the given Annotated Commit refers to.
   *
   * @category AnnotatedCommit/Methods
   * @signature
   * ```ts
   * class AnnotatedCommit {
   *   refname(): string | null;
   * }
   * ```
   *
   * @returns The refname that this Annotated Commit refers to. If this created from a reference,
   * the return value is `null`.
   * @throws Throws error if the refname is not valid utf-8.
   */
  refname(): string | null
}
/** A wrapper around git2::Blame providing Node.js bindings */
export declare class Blame {
  /**
   * Gets the number of hunks in the blame result
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkCount(): number;
   * }
   * ```
   *
   * @returns The number of hunks in the blame result
   */
  getHunkCount(): number
  /**
   * Checks if the blame result is empty
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns True if the blame result contains no hunks
   */
  isEmpty(): boolean
  /**
   * Gets blame information for the specified index
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkByIndex(index: number): BlameHunk;
   * }
   * ```
   *
   * @param {number} index - Index of the hunk to get (0-based)
   * @returns Blame information for the specified index
   * @throws If no hunk is found at the index
   */
  getHunkByIndex(index: number): BlameHunk
  /**
   * Gets blame information for the specified line
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   getHunkByLine(line: number): BlameHunk;
   * }
   * ```
   *
   * @param {number} line - Line number to get blame information for (1-based)
   * @returns Blame information for the specified line
   * @throws If no hunk is found for the line
   */
  getHunkByLine(line: number): BlameHunk
  /**
   * Gets all blame hunks as an iterator
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   iter(): Generator<BlameHunk>;
   * }
   * ```
   *
   * @returns Iterator of all blame hunks
   * @example
   * ```ts
   * // Using for...of loop
   * for (const hunk of blame.iter()) {
   *   console.log(hunk.finalCommitId);
   * }
   *
   * // Using spread operator to collect all hunks
   * const hunks = [...blame.iter()];
   * ```
   */
  iter(): BlameHunks
  /**
   * Collects blame hunks by scanning file lines as an iterator
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   iterByLine(): Generator<BlameHunk>;
   * }
   * ```
   *
   * @returns Iterator of blame hunks collected by line scanning
   * @example
   * ```ts
   * // Using for...of loop
   * for (const hunk of blame.iterByLine()) {
   *   console.log(hunk.finalCommitId);
   * }
   *
   * // Using spread operator to collect all hunks
   * const hunks = [...blame.iterByLine()];
   * ```
   */
  iterByLine(): BlameHunksByLine
  /**
   * Generates blame information from an in-memory buffer
   *
   * @category Blame/Methods
   * @signature
   * ```ts
   * class Blame {
   *   buffer(buffer: Buffer): Blame;
   * }
   * ```
   *
   * @example
   * ```ts
   * const buffer = Buffer.from('modified content');
   * const bufferBlame = blame.buffer(buffer);
   * ```
   *
   * @param {Buffer} buffer - Buffer containing file content to blame
   * @returns A new Blame object for the buffer content
   */
  buffer(buffer: Buffer): Blame
}
/** An iterator over blame hunks. */
export declare class BlameHunks {
  [Symbol.iterator](): Iterator<BlameHunk, void, void>
}
/** Iterator over blame hunks collected line by line. */
export declare class BlameHunksByLine {
  [Symbol.iterator](): Iterator<BlameHunk, void, void>
}
/**
 * A class to represent a git [blob][1].
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Blob {
  /**
   * Get the id (SHA1) of a repository blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository blob.
   */
  id(): string
  /**
   * Determine if the blob content is most certainly binary or not.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   isBinary(): boolean;
   * }
   * ```
   *
   * @returns `true` if blob content is binary.
   */
  isBinary(): boolean
  /**
   * Get the content of this blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   content(): Uint8Array;
   * }
   * ```
   *
   * @returns Content of this blob.
   */
  content(): Uint8Array
  /**
   * Get the size in bytes of the contents of this blob.
   *
   * @category Blob/Methods
   *
   * @signature
   * ```ts
   * class Blob {
   *   size(): bigint;
   * }
   * ```
   *
   * @returns Size in bytes of the contents of this blob.
   */
  size(): bigint
}
/**
 * A structure to represent a git [branch][1]
 *
 * A branch is currently just a wrapper to an underlying `Reference`. The
 * reference can be accessed through the `get` and `into_reference` methods.
 *
 * [1]: http://git-scm.com/book/en/Git-Branching-What-a-Branch-Is
 */
export declare class Branch {
  /**
   * Get the OID pointed to by a reference which is this branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   referenceTarget(): string | null;
   * }
   * ```
   *
   * @returns The OID pointed to by a reference which is this branch.
   */
  referenceTarget(): string | null
  /**
   * Delete an existing branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   delete(): void;
   * }
   * ```
   */
  delete(): void
  /**
   * Determine if the current local branch is pointed at by `HEAD`.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   isHead(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the current local branch is pointed at by `HEAD`.
   */
  isHead(): boolean
  /**
   * Move/rename an existing local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   rename(newBranchName: string, options?: BranchRenameOptions | null | undefined): Branch;
   * }
   * ```
   *
   * @param {string} newBranchName - Branch name to move/rename.
   * @param {BranchRenameOptions} [options] - Options for move/rename branch.
   * @returns Move/renamed branch.
   */
  rename(newBranchName: string, options?: BranchRenameOptions | undefined | null): Branch
  /**
   * Return the name of the given local or remote branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   name(): string;
   * }
   * ```
   *
   * @returns The name of the given local or remote branch.
   * @throws If the name is not valid utf-8.
   */
  name(): string
  /**
   * Return the reference supporting the remote tracking branch, given a
   * local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   findUpstream(): Branch | null;
   * }
   * ```
   *
   * @returns The reference supporting the remote tacking branch.
   */
  findUpstream(): Branch | null
  /**
   * Return the reference supporting the remote tracking branch, given a
   * local branch reference.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   getUpstream(): Branch;
   * }
   * ```
   *
   * @returns The reference supporting the remote tacking branch.
   * @throws Throws error if upstream does not exist.
   */
  getUpstream(): Branch
  /**
   * Set the upstream configuration for a given local branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   setUpstream(upstreamName: string): void;
   * }
   * ```
   *
   * @param {string} upstreamName - Branch name to set as upstream.
   */
  setUpstream(upstreamName: string): void
  /**
   * Unset the upstream configuration for a given local branch.
   *
   * @category Branch/Methods
   * @signature
   * ```ts
   * class Branch {
   *   unsetUpstream(): void;
   * }
   * ```
   */
  unsetUpstream(): void
}
/** An iterator over the branches inside of a repository. */
export declare class Branches {
  [Symbol.iterator](): Iterator<BranchesItem, void, void>
}
/** A class to represent a git commit. */
export declare class Commit {
  /**
   * Get the id (SHA1) of a repository commit
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository commit.
   */
  id(): string
  /**
   * Get the author of this commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   author(): Signature;
   * }
   * ```
   *
   * @returns Author signature of this commit.
   */
  author(): Signature
  /**
   * Get the committer of this commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   committer(): Signature;
   * }
   * ```
   *
   * @returns Committer signature of this commit.
   */
  committer(): Signature
  /**
   * Get the full message of a commit.
   *
   * The returned message will be slightly prettified by removing any
   * potential leading newlines.
   *
   * Throws error if the message is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   message(): string;
   * }
   * ```
   *
   * @returns Full message of this commit.
   * @throws If the message is not valid utf-8.
   */
  message(): string
  /**
   * Get the short "summary" of the git commit message.
   *
   * The returned message is the summary of the commit, comprising the first
   * paragraph of the message with whitespace trimmed and squashed.
   *
   * Throws error if the summary is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   summary(): string | null;
   * }
   * ```
   *
   * @returns Short summary of this commit message.
   * @throws If the summary is not valid utf-8.
   */
  summary(): string | null
  /**
   * Get the long "body" of the git commit message.
   *
   * The returned message is the body of the commit, comprising everything
   * but the first paragraph of the message. Leading and trailing whitespaces
   * are trimmed.
   *
   * Throws error if the summary is not valid utf-8.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   body(): string | null;
   * }
   * ```
   *
   * @returns Long body of this commit message.
   * @throws If the body is not valid utf-8.
   */
  body(): string | null
  /**
   * Get the commit time (i.e. committer time) of a commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   time(): Date;
   * }
   * ```
   *
   * @returns Commit time of a commit.
   */
  time(): Date
  /**
   * Get the tree pointed to by a commit.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   tree(): Tree;
   * }
   * ```
   *
   * @returns Tree pointed to by a commit.
   */
  tree(): Tree
  /**
   * Casts this Commit to be usable as an `GitObject`.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   asObject(): GitObject;
   * }
   * ```
   *
   * @returns `GitObject` that casted from this commit.
   */
  asObject(): GitObject
  /**
   * Get the author of this commit, using the mailmap to map it to the canonical name and email.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   authorWithMailmap(mailmap: Mailmap): Signature;
   * }
   * ```
   *
   * @param {Mailmap} mailmap - The mailmap to use for mapping
   * @returns Author signature of this commit with mapping applied
   * @throws An error if the operation failed.
   */
  authorWithMailmap(mailmap: Mailmap): Signature
  /**
   * Get the committer of this commit, using the mailmap to map it to the canonical name and email.
   *
   * @category Commit/Methods
   *
   * @signature
   * ```ts
   * class Commit {
   *   committerWithMailmap(mailmap: Mailmap): Signature;
   * }
   * ```
   *
   * @param {Mailmap} mailmap - The mailmap to use for mapping
   * @returns Committer signature of this commit with mapping applied
   * @throws An error if the operation failed.
   */
  committerWithMailmap(mailmap: Mailmap): Signature
}
/** An iterator over the `ConfigEntry` values of a config. */
export declare class ConfigEntries {
  [Symbol.iterator](): Iterator<ConfigEntry, void, void>
}
export declare class Config {
  /**
   * Delete a config variable from the config file with the highest level
   * (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   remove(name: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   */
  remove(name: string): void
  /**
   * Remove multivar config variables in the config file with the highest level (usually the
   * local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   removeMultivar(name: string, regexp: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} regexp - The regular expression is applied case-sensitively on the value.
   */
  removeMultivar(name: string, regexp: string): void
  /**
   * Get the value of a boolean config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getBool(name: string): boolean;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a boolean config variable.
   */
  getBool(name: string): boolean
  /**
   * Find the value of a boolean config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findBool(name: string): boolean | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a boolean config variable.
   */
  findBool(name: string): boolean | null
  /**
   * Get the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getI32(name: string): number;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  getI32(name: string): number
  /**
   * Find the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findI32(name: string): number | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  findI32(name: string): number | null
  /**
   * Get the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getI64(name: string): number;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  getI64(name: string): number
  /**
   * Find the value of an integer config variable.
   *
   * All config files will be looked into, in the order of their defined
   * level. A higher level means a higher priority. The first occurrence of
   * the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findI64(name: string): number | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of an integer config variable.
   */
  findI64(name: string): number | null
  /**
   * Get the value of a string config variable as a byte slice.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getBytes(name: string): Uint8Array;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable as a byte slice.
   */
  getBytes(name: string): Uint8Array
  /**
   * Find the value of a string config variable as a byte slice.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findBytes(name: string): Uint8Array | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable as a byte slice.
   */
  findBytes(name: string): Uint8Array | null
  /**
   * Get the value of a string config variable as an owned string.
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getString(name: string): string;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable.
   * @throws An error will be returned if the config value is not valid utf-8.
   */
  getString(name: string): string
  /**
   * Find the value of a string config variable as an owned string.
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findString(name: string): string | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a string config variable.
   */
  findString(name: string): string | null
  /**
   * Get the value of a path config variable.
   *
   * A leading '~' will be expanded to the global search path (which
   * defaults to the user's home directory but can be overridden via
   * [`git_libgit2_opts`][1].
   *
   * [1]: https://libgit2.org/docs/reference/v1.9.0/common/git_libgit2_opts.html
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getPath(name: string): string;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a path config variable.
   */
  getPath(name: string): string
  /**
   * Find the value of a path config variable.
   *
   * A leading '~' will be expanded to the global search path (which
   * defaults to the user's home directory but can be overridden via
   * [`git_libgit2_opts`][1].
   *
   * [1]: https://libgit2.org/docs/reference/v1.9.0/common/git_libgit2_opts.html
   *
   * All config files will be looked into, in the order of their
   * defined level. A higher level means a higher priority. The
   * first occurrence of the variable will be returned here.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findPath(name: string): string | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns The value of a path config variable.
   */
  findPath(name: string): string | null
  /**
   * Get the entry for a config variable.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   getEntry(name: string): ConfigEntry;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns `ConfigEntry` object representing a certain entry owned by a `Config` instance.
   */
  getEntry(name: string): ConfigEntry
  /**
   * Find the entry for a config variable.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   findEntry(name: string): ConfigEntry | null;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @returns `ConfigEntry` object representing a certain entry owned by a `Config` instance.
   */
  findEntry(name: string): ConfigEntry | null
  /**
   * Iterate over all the config variables.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   entries(glob?: string): ConfigEntries;
   * }
   * ```
   *
   * @param {string} [glob] - If `glob` is provided, then the iterator will only iterate over all
   * variables whose name matches the pattern.
   * The regular expression is applied case-sensitively on the normalized form of
   * the variable name: the section and variable parts are lower-cased. The
   * subsection is left unchanged.
   *
   * @returns An iterator over the `ConfigEntry` values of a config.
   * @example
   *
   * ```ts
   * import { openDefaultConfig } from 'es-git';
   *
   * const config = openDefaultConfig();
   * for (const entry of config.entries()) {
   *   console.log(entry.name, entry.value);
   * }
   * ```
   */
  entries(glob?: string | undefined | null): ConfigEntries
  /**
   * Iterate over the values of a multivar.
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   multivar(name: string, regexp?: string): ConfigEntries;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} [regexp] - If `regexp` is provided, then the iterator will only iterate over all
   * values which match the pattern.
   * The regular expression is applied case-sensitively on the normalized form of
   * the variable name: the section and variable parts are lower-cased. The
   * subsection is left unchanged.
   *
   * @returns An iterator over the `ConfigEntry` values of a config.
   */
  multivar(name: string, regexp?: string | undefined | null): ConfigEntries
  /**
   * Set the value of a boolean config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setBool(name: string, value: boolean): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {boolean} value - The value of config entry.
   */
  setBool(name: string, value: boolean): void
  /**
   * Set the value of an integer config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setI32(name: string, value: number): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {number} value - The value of config entry.
   */
  setI32(name: string, value: number): void
  /**
   * Set the value of an integer config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setI64(name: string, value: number): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {number} value - The value of config entry.
   */
  setI64(name: string, value: number): void
  /**
   * Set the value of an multivar config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setMultivar(name: string, regexp: string, value: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} regexp - The regular expression is applied case-sensitively on the value.
   * @param {string} value - The value of config entry.
   */
  setMultivar(name: string, regexp: string, value: string): void
  /**
   * Set the value of a string config variable in the config file with the
   * highest level (usually the local one).
   *
   * @category Config/Methods
   * @signature
   * ```ts
   * class Config {
   *   setString(name: string, value: string): void;
   * }
   * ```
   *
   * @param {string} name - The name of config entry.
   * @param {string} value - The value of config entry.
   */
  setString(name: string, value: string): void
}
/**
 * The diff object that contains all individual file deltas.
 *
 * This is an opaque structure which will be allocated by one of the diff
 * generator functions on the `Repository` class (e.g. `diffTreeToTree`
 * or other `diff*` functions).
 */
export declare class Diff {
  /**
   * Merge one diff into another.
   *
   * This merges items from the "from" list into the "self" list.  The
   * resulting diff will have all items that appear in either list.
   * If an item appears in both lists, then it will be "merged" to appear
   * as if the old version was from the "onto" list and the new version
   * is from the "from" list (with the exception that if the item has a
   * pending DELETE in the middle, then it will show as deleted).
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   merge(diff: Diff): void;
   * }
   * ```
   *
   * @param {Diff} diff - Another diff to merge.
   */
  merge(diff: Diff): void
  /**
   * Returns an iterator over the deltas in this diff.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   deltas(): Deltas;
   * }
   * ```
   *
   * @returns An iterator over the deltas in this diff.
   */
  deltas(): Deltas
  /**
   * Check if deltas are sorted case sensitively or insensitively.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   isSortedIcase(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if deltas are sorted case insensitively.
   */
  isSortedIcase(): boolean
  /**
   * Accumulate diff statistics for all patches.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   stats(): DiffStats;
   * }
   * ```
   *
   * @returns Diff statistics for all patches.
   */
  stats(): DiffStats
  /**
   * Iterate over a diff generating formatted text output.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   print(options?: DiffPrintOptions | null | undefined): string;
   * }
   * ```
   *
   * @param {DiffPrintOptions} [options] - Print options for diff.
   * @returns Formatted text output.
   */
  print(options?: DiffPrintOptions | undefined | null): string
  /**
   * Transform a diff marking file renames, copies, etc.
   *
   * This modifies a diff in place, replacing old entries that look like
   * renames or copies with new entries reflecting those changes. This also
   * will, if requested, break modified files into add/remove pairs if the
   * amount of change is above a threshold.
   *
   * @category Diff/Methods
   * @signature
   * ```ts
   * class Diff {
   *   findSimilar(options?: DiffFindOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {DiffFindOptions} [options] - Options for finding diff.
   */
  findSimilar(options?: DiffFindOptions | undefined | null): void
}
/** A class describing a hunk of a diff. */
export declare class DiffStats {
  /**
   * Get the total number of files changed in a diff.
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get filesChanged(): bigint;
   * }
   * ```
   *
   * @returns Total number of files changed in a diff.
   */
  get filesChanged(): bigint
  /**
   * Get the total number of insertions in a diff
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get insertions(): bigint;
   * }
   * ```
   *
   * @returns Total number of insertions in a diff.
   */
  get insertions(): bigint
  /**
   * Get the total number of deletions in a diff
   *
   * @category Diff/DiffStats
   * @signature
   * ```ts
   * class DiffStats {
   *   get deletions(): bigint;
   * }
   * ```
   *
   * @returns Total number of deletions in a diff.
   */
  get deletions(): bigint
}
/** An iterator over the diffs in a delta. */
export declare class Deltas {
  [Symbol.iterator](): Iterator<DiffDelta, void, void>
}
/** Description of changes to one entry. */
export declare class DiffDelta {
  /**
   * Returns the flags on the delta.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   flags(): number;
   * }
   * ```
   *
   * @returns The flags on the delta.
   *
   * @example
   * ```ts
   * import { DiffDelta, DiffFlags, diffFlagsContains } from 'es-git';
   *
   * const delta: DiffDelta;
   * console.assert(diffFlagsContains(delta.flags(), DiffFlags.Binary | DiffFlags.ValidId));
   * ```
   */
  flags(): number
  /**
   * Returns the number of files in this delta.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   numFiles(): number;
   * }
   * ```
   *
   * @returns The number of files in this delta.
   */
  numFiles(): number
  /**
   * Returns the status of this entry.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   status(): DeltaType;
   * }
   * ```
   *
   * @returns The status of this entry.
   */
  status(): DeltaType
  /**
   * Return the file which represents the "from" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   oldFile(): DiffFile;
   * }
   * ```
   *
   * @returns The file which represents the "from" side of the diff.
   */
  oldFile(): DiffFile
  /**
   * Return the file which represents the "to" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   *
   * @category Diff/DiffDelta
   * @signature
   * ```ts
   * class DiffDelta {
   *   newFile(): DiffFile;
   * }
   * ```
   *
   * @returns The file which represents the "to" side of the diff.
   */
  newFile(): DiffFile
}
/**
 * Description of one side of a delta.
 *
 * Although this is called a "file" it could represent a file, a symbolic
 * link, a submodule commit id, or even a tree (although that only happens if
 * you are tracking type changes or ignored/untracked directories).
 */
export declare class DiffFile {
  /**
   * Returns the Oid of this item.
   *
   * If this entry represents an absent side of a diff (e.g. the `oldFile`
   * of a `Added` delta), then the oid returned will be zeroes.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   id(): string;
   * }
   * ```
   *
   * @returns The Oid of this item.
   */
  id(): string
  /**
   * Returns the path of the entry relative to the working directory of the
   * repository.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   path(): string | null;
   * }
   * ```
   *
   * @returns Ths path of the entry relative to the working directory of the repository.
   */
  path(): string | null
  /**
   * Returns the size of this entry, in bytes.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   size(): bigint;
   * }
   * ```
   *
   * @returns The size of this entry, in bytes.
   */
  size(): bigint
  /**
   * Returns `true` if file(s) are treated as binary data.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   isBinary(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if file(s) are treated as binary data.
   */
  isBinary(): boolean
  /**
   * Returns `true` if `id` value is known correct.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   isValidId(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if `id` value is known correct.
   */
  isValidId(): boolean
  /**
   * Returns `true` if file exists at this side of the delta.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   exists(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if file exists at this side of the delta.
   */
  exists(): boolean
  /**
   * Returns file mode.
   *
   * @category Diff/DiffFile
   * @signature
   * ```ts
   * class DiffFile {
   *   mode(): FileMode;
   * }
   * ```
   *
   * @returns
   */
  mode(): FileMode
}
/**
 * A class to represent a git [index][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Index {
  /**
   * Get index on-disk version.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   version(): number;
   * }
   * ```
   *
   * @returns Index on-disk version.
   * Valid return values are 2, 3, or 4. If 3 is returned, an index
   * with version 2 may be written instead, if the extension data in
   * version 3 is not necessary.
   */
  version(): number
  /**
   * Set index on-disk version.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   setVersion(version: number): void;
   * }
   * ```
   *
   * @param {string} version - Version to set.
   * Valid values are 2, 3, or 4. If 2 is given, git_index_write may
   * write an index with version 3 instead, if necessary to accurately
   * represent the index.
   */
  setVersion(version: number): void
  /**
   * Get one of the entries in the index by its path.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   getByPath(path: string, stage?: IndexStage | null | undefined): IndexEntry | null;
   * }
   * ```
   *
   * @param {string} path - Path to lookup entry.
   * @param {IndexStage} [stage] - Git index stage states.
   * @returns Index entry for the path.
   */
  getByPath(path: string, stage?: IndexStage | undefined | null): IndexEntry | null
  /**
   * Add or update an index entry from a file on disk.
   *
   * This forces the file to be added to the index, not looking at gitignore
   * rules.
   *
   * If this file currently is the result of a merge conflict, this file will
   * no longer be marked as conflicting. The data about the conflict will be
   * moved to the "resolve undo" (REUC) section.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   addPath(path: string): void;
   * }
   * ```
   *
   * @param {string} path - Relative file path to the repository's working directory and must be
   * readable.
   *
   * @throws This method will fail in bare index instances.
   */
  addPath(path: string): void
  /**
   * Add or update index entries matching files in the working directory.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   addAll(pathspecs: string[], options?: IndexAddAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory. Each file that matches will be added
   * to the index (either updating an existing entry or adding a new entry).
   * @param {IndexAddAllOptions} [options] - Options for add or update index entries.
   *
   * @throws This method will fail in bare index instances.
   *
   * @example
   *
   * Emulate `git add *`:
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const index = repo.index();
   * index.addAll(['*']);
   * index.write();
   * ```
   */
  addAll(pathspecs: Array<string>, options?: IndexAddAllOptions | undefined | null): void
  /**
   * Update the contents of an existing index object in memory by reading
   * from the hard disk.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   read(force?: boolean | null | undefined): void;
   * }
   * ```
   *
   * @param {boolean} [force] - If force is `true`, this performs a "hard" read that discards
   * in-memory changes and always reloads the on-disk index data. If there is no on-disk version,
   * the index will be cleared.
   *
   * If force is `false`, this does a "soft" read that reloads the index data
   * from disk only if it has changed since the last time it was loaded.
   * Purely in-memory index data will be untouched. Be aware: if there are
   * changes on disk, unwritten in-memory changes are discarded.
   */
  read(force?: boolean | undefined | null): void
  /**
   * Write an existing index object from memory back to disk using an atomic
   * file lock.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   write(): void;
   * }
   * ```
   */
  write(): void
  /**
   * Write the index as a tree.
   *
   * This method will scan the index and write a representation of its
   * current state back to disk; it recursively creates tree objects for each
   * of the subtrees stored in the index, but only returns the OID of the
   * root tree. This is the OID that can be used e.g. to create a commit.
   *
   * The index instance cannot be bare, and needs to be associated to an
   * existing repository.
   *
   * The index must not contain any file in conflict.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   writeTree(): string;
   * }
   * ```
   */
  writeTree(): string
  /**
   * Remove an index entry corresponding to a file on disk.
   *
   * If this file currently is the result of a merge conflict, this file will
   * no longer be marked as conflicting. The data about the conflict will be
   * moved to the "resolve undo" (REUC) section.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   removePath(path: string, options?: IndexRemoveOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string} path - Relative file path to the repository's working directory.
   * @param {IndexRemoveOptions} options - Options for remove an index entry.
   */
  removePath(path: string, options?: IndexRemoveOptions | undefined | null): void
  /**
   * Remove all matching index entries.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   removeAll(pathspecs: string[], options?: IndexRemoveAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory
   * @param {IndexRemoveAllOptions} options - Options for remove all matching index entry.
   */
  removeAll(pathspecs: Array<string>, options?: IndexRemoveAllOptions | undefined | null): void
  /**
   * Update all index entries to match the working directory.
   *
   * This scans the existing index entries and synchronizes them with the
   * working directory, deleting them if the corresponding working directory
   * file no longer exists otherwise updating the information (including
   * adding the latest version of file to the ODB if needed).
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   updateAll(pathspecs: string[], options?: IndexUpdateAllOptions | null | undefined): void;
   * }
   * ```
   *
   * @param {string[]} pathspecs - A List of file names of shell glob patterns that will matched
   * against files in the repository's working directory
   * @param {IndexUpdateAllOptions} options - Options for update all matching index entry.
   *
   * @throws This method will fail in bare index instances.
   */
  updateAll(pathspecs: Array<string>, options?: IndexUpdateAllOptions | undefined | null): void
  /**
   * Get the count of entries currently in the index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   count(): number;
   * }
   * ```
   *
   * @returns The count of entries currently in the index.
   */
  count(): number
  /**
   * Return `true` is there is no entry in the index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` is there is no entry in the index.
   */
  isEmpty(): boolean
  /**
   * Get the full path to the index file on disk.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   path(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if this is an in-memory index.
   */
  path(): string | null
  /**
   * Does this index have conflicts?
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   hasConflicts(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the index contains conflicts, `false` if it does not.
   */
  hasConflicts(): boolean
  /**
   * Get an iterator over the entries in this index.
   *
   * @category Index/Methods
   * @signature
   * ```ts
   * class Index {
   *   entries(): IndexEntries;
   * }
   * ```
   *
   * @returns An iterator over the entries in this index.
   */
  entries(): IndexEntries
}
/** An iterator over the entries in an index. */
export declare class IndexEntries {
  [Symbol.iterator](): Iterator<IndexEntry, void, void>
}
/** A wrapper around git2::Mailmap providing Node.js bindings */
export declare class Mailmap {
  /**
   * Add a new Mailmap entry.
   *
   * Maps an author/committer (specified by `replace_name` and `replace_email`)
   * to the specified real name and email. The `replace_email` is required but
   * the other parameters can be null.
   *
   * If both `replace_name` and `replace_email` are provided, then the entry will
   * apply to those who match both. If only `replace_name` is provided,
   * it will apply to anyone with that name, regardless of email. If only
   * `replace_email` is provided, it will apply to anyone with that email,
   * regardless of name.
   *
   * @param {AddMailmapEntryData} entry - The mailmap entry data.
   * @returns {void}
   * @throws An error if the operation failed.
   *
   * @category Mailmap/Methods
   *
   * @signature
   * ```ts
   * class Mailmap {
   *   addEntry(entry: AddMailmapEntryData): void;
   * }
   * ```
   */
  addEntry(entry: AddMailmapEntryData): void
  /**
   * Resolve a signature to its canonical form using a mailmap.
   *
   * Returns a new signature with the canonical name and email.
   *
   * @param {SignaturePayload} signature - Signature to resolve
   * @returns The resolved signature with canonical name and email
   * @throws An error if the operation failed.
   *
   * @category Mailmap/Methods
   *
   * @signature
   * ```ts
   * class Mailmap {
   *   resolveSignature(signature: SignaturePayload): Signature;
   * }
   * ```
   */
  resolveSignature(signature: SignaturePayload): Signature
}
/**
 * A class to represent a git [object][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class GitObject {
  /**
   * Get the id (SHA1) of a repository object.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository object.
   */
  id(): string
  /**
   * Get the object type of object.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   type(): ObjectType | null;
   * }
   * ```
   *
   * @returns If the type is unknown, then `null` is returned.
   */
  type(): ObjectType | null
  /**
   * Recursively peel an object until an object of the specified type is met.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peel(objType: ObjectType): GitObject;
   * }
   * ```
   *
   * @param {ObjectType} objType - If you pass `Any` as the target type, then the object will be
   * peeled until the type changes (e.g. a tag will be chased until the
   * referenced object is no longer a tag).
   *
   * @returns Git object which recursively peeled.
   */
  peel(objType: ObjectType): GitObject
  /**
   * Recursively peel an object until a commit is found.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peelToCommit(): Commit;
   * }
   * ```
   *
   * @returns Git commit.
   */
  peelToCommit(): Commit
  /**
   * Recursively peel an object until a blob is found.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   peelToBlob(): Blob;
   * }
   * ```
   *
   * @returns Git blob.
   */
  peelToBlob(): Blob
  /**
   * Attempt to view this object as a commit.
   *
   * @category GitObject/Methods
   * @signature
   * ```ts
   * class GitObject {
   *   asCommit(): Commit | null;
   * }
   * ```
   *
   * @returns Returns `null` if the object is not actually a commit.
   */
  asCommit(): Commit | null
}
/**
 * A class to represent a git [reference][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-References
 */
export declare class Reference {
  /**
   * Delete an existing reference.
   *
   * This method works for both direct and symbolic references. The reference
   * will be immediately removed on disk.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   delete(): void;
   * }
   * ```
   *
   * @throws This method will throws an error if the reference has changed from the
   * time it was looked up.
   */
  delete(): void
  /**
   * Check if a reference is a local branch.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isBranch(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a local branch.
   */
  isBranch(): boolean
  /**
   * Check if a reference is a note.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isNote(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a note.
   */
  isNote(): boolean
  /**
   * Check if a reference is a remote tracking branch.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isRemote(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a remote tracking branch.
   */
  isRemote(): boolean
  /**
   * Check if a reference is a tag.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   isTag(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if a reference is a tag.
   */
  isTag(): boolean
  /**
   * Get the reference type of a reference.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   type(): ReferenceType | null;
   * }
   * ```
   *
   * @returns Returns `null` if the type is unknown.
   */
  type(): ReferenceType | null
  /**
   * Get the full name of a reference.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   name(): string;
   * }
   * ```
   *
   * @returns Full name of a reference.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string
  /**
   * Get the full shorthand of a reference.
   *
   * This will transform the reference name into a name "human-readable"
   * version. If no shortname is appropriate, it will return the full name.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   shorthand(): string;
   * }
   * ```
   *
   * @returns Full shorthand of a reference.
   * @throws Throws error if the shorthand is not valid utf-8.
   */
  shorthand(): string
  /**
   * Get the OID pointed to by a direct reference.
   *
   * Only available if the reference is direct (i.e. an object id reference,
   * not a symbolic one).
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   target(): string | null;
   * }
   * ```
   *
   * @returns OID pointed to by a direct reference.
   */
  target(): string | null
  /**
   * Return the peeled OID target of this reference.
   *
   * This peeled OID only applies to direct references that point to a hard.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   targetPeel(): string | null;
   * }
   * ```
   *
   * @returns Peeled OID of this reference.
   */
  targetPeel(): string | null
  /**
   * Peel a reference to a tree.
   *
   * This method recursively peels the reference until it reaches
   * a tree.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   peelToTree(): Tree;
   * }
   * ```
   *
   * @returns Peeled `Tree` of this reference.
   */
  peelToTree(): Tree
  /**
   * Get full name to the reference pointed to by a symbolic reference.
   *
   * Only available if the reference is symbolic.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   symbolicTarget(): string | null;
   * }
   * ```
   *
   * @returns Full name of the reference pointed to by a symbolic reference.
   */
  symbolicTarget(): string | null
  /**
   * Resolve a symbolic reference to a direct reference.
   *
   * This method iteratively peels a symbolic reference until it resolves to
   * a direct reference to an OID.
   *
   * If a direct reference is passed as an argument, a copy of that
   * reference is returned.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   resolve(): Reference;
   * }
   * ```
   *
   * @returns Resolved reference.
   */
  resolve(): Reference
  /**
   * Rename an existing reference.
   *
   * This method works for both direct and symbolic references.
   *
   * @category Reference/Methods
   * @signature
   * ```ts
   * class Reference {
   *   rename(newName: string, options?: RenameReferenceOptions | null | undefined): Reference;
   * }
   * ```
   *
   * @param {string} newName - Name to rename an existing reference.
   * @param {RenameReferenceOptions} [options] - Options to rename an existing reference.
   * @returns Renamed reference.
   */
  rename(newName: string, options?: RenameReferenceOptions | undefined | null): Reference
}
/**
 * A class representing a [remote][1] of a git repository.
 *
 * [1]: https://git-scm.com/book/en/Git-Basics-Working-with-Remotes
 */
export declare class Remote {
  /**
   * Get the remote's name.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   name(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if this remote has not yet been named.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string | null
  /**
   * Get the remote's URL.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   url(): string;
   * }
   * ```
   *
   * @throws Throws error if the URL is not valid utf-8.
   */
  url(): string
  /**
   * Get the remote's URL.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   pushurl(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if push url not exists.
   * @throws Throws error if the URL is not valid utf-8.
   */
  pushurl(): string | null
  /**
   * List all refspecs.
   *
   * Filter refspec if has not valid `src` or `dst` with utf-8.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   refspecs(): Refspec[];
   * }
   * ```
   *
   * @returns List all refspecs.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Retrieving the Refspecs configured for this remote
   * const refspecs = remote.refspecs();
   * console.log(refspecs[0]);
   * // For the "+refs/heads/*:refs/remotes/origin/*" Refspec
   * // {
   * //   "direction": "Fetch",
   * //   "src": "refs/heads/*",
   * //   "dst": "refs/remotes/origin/*",
   * //   "force": true
   * // }
   * ```
   */
  refspecs(): Array<Refspec>
  /**
   * Download new data and update tips.
   *
   * Convenience function to connect to a remote, download the data, disconnect and update the remote-tracking branches.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   fetch(
   *     refspecs: string[],
   *     options?: FetchRemoteOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {string[]} refspecs - Refspecs to fetch from remote.
   * @param {FetchRemoteOptions} [options] - Options for fetch remote.
   * @param {AbortSignal} [signal] Abort signal.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Fetching data from the "main" branch
   * await remote.fetch(['main']);
   *
   * // Providing an empty array fetches data using the default Refspec configured for the remote
   * await remote.fetch([]);
   * ```
   */
  fetch(refspecs: Array<string>, options?: FetchRemoteOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Perform a push.
   *
   * Perform all the steps for a push.
   * If no refspecs are passed, then the configured refspecs will be used.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   push(
   *     refspecs: string[],
   *     options?: PushOptions | null | undefined,
   *     signal?: AbortSignal | null | undefined,
   *   ): Promise<void>;
   * }
   * ```
   *
   * @param {string[]} refspecs - Refspecs to push to remote.
   * @param {FetchRemoteOptions} [options] - Options for push remote.
   * @param {AbortSignal} [signal] Abort signal.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * // Push the local "main" branch to the remote "other" branch
   * await remote.push(['refs/heads/main:refs/heads/other']);
   *
   * // Push with credential.
   * await remote.push(['refs/heads/main:refs/heads/other'], {
   *   credential: {
   *     type: 'Plain',
   *     password: '<personal access token>',
   *   },
   * });
   * ```
   */
  push(refspecs: Array<string>, options?: PushOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Prune tracking refs that are no longer present on remote.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   prune(options?: PruneOptions | null | undefined, signal?: AbortSignal | null | undefined): Promise<void>;
   * }
   * ```
   *
   * @param {PruneOptions} [options] - Options for prune remote.
   * @param {AbortSignal} [signal] Abort signal.
   */
  prune(options?: PruneOptions | undefined | null, signal?: AbortSignal | undefined | null): Promise<void>
  /**
   * Get the remote’s default branch.
   *
   * The `fetch` operation from the remote is also performed.
   *
   * @category Remote/Methods
   * @signature
   * ```ts
   * class Remote {
   *   defaultBranch(signal?: AbortSignal | null | undefined): Promise<string>;
   * }
   * ```
   *
   * @param {AbortSignal} [signal] Abort signal.
   * @returns Default branch name.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * const remote = repo.getRemote('origin');
   *
   * const branch = await remote.defaultBranch();
   * console.log(branch); // "refs/heads/main"
   * ```
   */
  defaultBranch(signal?: AbortSignal | undefined | null): Promise<string>
}
/**
 * An owned git repository, representing all state associated with the
 * underlying filesystem.
 *
 * This class corresponds to a git repository in libgit2.
 */
export declare class Repository {
  /**
   * Creates an Annotated Commit from the given commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommit(commit: Commit): AnnotatedCommit;
   * }
   * ```
   *
   * @param {Commit} commit - Commit to creates a Annotated Commit.
   * @returns An Annotated Commit created from commit.
   */
  getAnnotatedCommit(commit: Commit): AnnotatedCommit
  /**
   * Creates a Annotated Commit from the given reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommitFromReference(reference: Reference): AnnotatedCommit;
   * }
   * ```
   *
   * @param {Reference} reference - Reference to creates a Annotated Commit.
   * @returns An Annotated Commit created from reference.
   */
  getAnnotatedCommitFromReference(reference: GitReference): AnnotatedCommit
  /**
   * Creates a Annotated Commit from `FETCH_HEAD`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getAnnotatedCommitFromFetchHead(
   *     branchName: string,
   *     remoteUrl: string,
   *     id: string,
   *   ): AnnotatedCommit;
   * }
   * ```
   *
   * @param {String} branchName - Name of the remote branch.
   * @param {String} remoteUrl - Url of the remote.
   * @param {String} id - The commit object id of the remote branch.
   * @returns An Annotated Commit created from `FETCH_HEAD`.
   */
  getAnnotatedCommitFromFetchHead(branchName: string, remoteUrl: string, id: string): AnnotatedCommit
  /**
   * Creates a blame object for the file at the given path
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   blameFile(path: string, options?: BlameOptions): Blame;
   * }
   * ```
   *
   * @example
   * ```ts
   * // Blame the entire file
   * const blame = repo.blameFile('path/to/file.js');
   *
   * // Blame a single line
   * const lineBlame = repo.blameFile('path/to/file.js', { minLine: 10, maxLine: 10 });
   *
   * // Blame a range of lines
   * const rangeBlame = repo.blameFile('path/to/file.js', { minLine: 5, maxLine: 15 });
   * ```
   *
   * @param {string} path - Path to the file to blame
   * @param {BlameOptions} [options] - Options to control blame behavior
   * @returns Blame object for the specified file
   * @throws If the file doesn't exist or can't be opened
   */
  blameFile(path: string, options?: BlameOptions | undefined | null): Blame
  /**
   * Create a new branch pointing at a target commit
   *
   * A new direct reference will be created pointing to this target commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createBranch(
   *     branchName: string,
   *     target: Commit,
   *     options?: CreateBranchOptions | null | undefined,
   *   ): Branch;
   * }
   * ```
   *
   * @param {string} branchName - Name for the new branch.
   * @param {Commit} target - Target commit which will be pointed by this branch.
   * @param {CreateBranchOptions} [options] - Options for create branch.
   * @returns {Branch} Newly created branch.
   */
  createBranch(branchName: string, target: Commit, options?: CreateBranchOptions | undefined | null): Branch
  /**
   * Lookup a branch by its name in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findBranch(name: string, branchType: BranchType): Branch | null;
   * }
   * ```
   *
   * @param {string} name - A branch name.
   * @param {BranchType} branchType - Branch type to lookup.
   * @returns A found branch.
   */
  findBranch(name: string, branchType: BranchType): Branch | null
  /**
   * Lookup a branch by its name in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getBranch(name: string, branchType: BranchType): Branch;
   * }
   * ```
   *
   * @param {string} name - A branch name.
   * @param {BranchType} branchType - Branch type to lookup.
   * @returns A found branch.
   * @throws Throws error if branch does not exist.
   */
  getBranch(name: string, branchType: BranchType): Branch
  /**
   * Create an iterator which loops over the requested branches.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   branches(filter?: BranchesFilter | null | undefined): Branches;
   * }
   * ```
   *
   * @param {BranchesFilter} [filter] - Filter for the branches iterator.
   * @returns An iterator which loops over the requested branches.
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   *
   * for (const branch of repo.branches()) {
   *   console.log(branch.type); // "Local"
   *   console.log(branch.name); // "main"
   * }
   * ```
   */
  branches(filter?: BranchesFilter | undefined | null): Branches
  /**
   * Updates files in the index and the working tree to match the content of
   * the commit pointed at by HEAD.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutHead(options?: CheckoutOptions | undefined | null): void;
   * }
   * ```
   *
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutHead(options?: CheckoutOptions | undefined | null): void
  /**
   * Updates files in the working tree to match the content of the index.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutIndex(
   *     index?: Index | undefined | null,
   *     options?: CheckoutOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {Index} [index] - Index to checkout. If not given, the repository's index will be used.
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutIndex(index?: Index | undefined | null, options?: CheckoutOptions | undefined | null): void
  /**
   * Updates files in the index and working tree to match the content of the
   * tree pointed at by the treeish.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   checkoutTree(treeish: GitObject, options?: CheckoutOptions | undefined | null): void;
   * }
   * ```
   *
   * @param {GitObject} treeish - Git object which tree pointed.
   * @param {CheckoutOptions} [options] - Options for checkout.
   */
  checkoutTree(treeish: GitObject, options?: CheckoutOptions | undefined | null): void
  /**
   * Lookup a reference to one of the commits in a repository.
   *
   * Returns `null` if the commit does not exist.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   findCommit(oid: string): Commit | null;
   * }
   * ```
   * @param {string} oid - Commit ID(SHA1) to lookup.
   * @returns Commit instance found by oid. Returns `null` if the commit does not exist.
   */
  findCommit(oid: string): Commit | null
  /**
   * Lookup a reference to one of the commits in a repository.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   getCommit(oid: string): Commit;
   * }
   * ```
   *
   * @param {string} oid - Commit ID(SHA1) to lookup.
   * @returns Commit instance found by oid.
   * @throws Throws error if the commit does not exist.
   */
  getCommit(oid: string): Commit
  /**
   * Create new commit in the repository.
   *
   * If the `updateRef` is not `null`, name of the reference that will be
   * updated to point to this commit. If the reference is not direct, it will
   * be resolved to a direct reference. Use "HEAD" to update the HEAD of the
   * current branch and make it point to this commit. If the reference
   * doesn't exist yet, it will be created. If it does exist, the first
   * parent must be the tip of this branch.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   commit(tree: Tree, message: string, options?: CommitOptions | null | undefined): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of created commit.
   */
  commit(tree: Tree, message: string, options?: CommitOptions | undefined | null): string
  /**
   * Get the configuration file for this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   config(): Config;
   * }
   * ```
   *
   * @returns If a configuration file has not been set, the default config set for the
   * repository will be returned, including global and system configurations
   * (if they are available).
   */
  config(): Config
  /**
   * Create a diff with the difference between two tree objects.
   *
   * This is equivalent to `git diff <old-tree> <new-tree>`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToTree(
   *     oldTree?: Tree | null | undefined,
   *     newTree?: Tree | null | undefined,
   *     options?: DiffOptions | null | undefined,
   *   ): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   * @param {Tree} [newTree] - Tree used for the "newFile" side of the delta. If you not pass,
   * then an empty tree is used.
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between two tree objects.
   * @throws Throws error if the `oldTree` and `newTree` is `null`.
   */
  diffTreeToTree(oldTree?: Tree | undefined | null, newTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between two index objects.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffIndexToIndex(
   *     oldIndex: Index,
   *     newIndex: Index,
   *     options?: DiffOptions | null | undefined,
   *   ): Diff;
   * }
   * ```
   *
   * @param {Index} [oldIndex] - Index used for the "oldFile" side of the delta.
   * @param {Index} [newIndex] - Index used for the "newFile" side of the delta.
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between two index objects.
   */
  diffIndexToIndex(oldIndex: Index, newIndex: Index, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between the repository index and the workdir directory.
   *
   * This matches the `git diff` command.  See the note below on
   * `diffTreeToWorkdir` for a discussion of the difference between
   * `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
   * using libgit2.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffIndexToWorkdir(index?: Index | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Index} [index] - Index used for the "oldFile" side of the delta. The working directory
   * will be used for the "newFile" side of the delta.
   *
   * If not you pass, then the existing index of the repository  will be used. In this case,
   * the index will be refreshed from disk (if it has changed) before the diff is generated.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between the repository index and the workdir directory.
   */
  diffIndexToWorkdir(index?: Index | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory.
   *
   * The tree you provide will be used for the "oldFile" side of the delta,
   * and the working directory will be used for the "newFile" side.
   *
   * This is not the same as `git diff <treeish>` or `git diff-index <treeish>`.
   * Those commands use information from the index, whereas this
   * function strictly returns the differences between the tree and the files
   * in the working directory, regardless of the state of the index. Use
   * `diffTreeToWorkdirWithIndex` to emulate those commands.
   *
   * To see difference between this and `diffTreeToWorkdirWithIndex`,
   * consider the example of a staged file deletion where the file has then
   * been put back into the working dir and further modified. The
   * tree-to-workdir diff for that file is 'modified', but `git diff` would
   * show status 'deleted' since there is a staged delete.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToWorkdir(oldTree?: Tree | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between a tree and the working directory.
   */
  diffTreeToWorkdir(oldTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory using index data
   * to account for staged deletes, tracked files, etc.
   *
   * This emulates `git diff <tree>` by diffing the tree to the index and
   * the index to the working directory and blending the results into a
   * single diff that includes staged deleted, etc.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   diffTreeToWorkdirWithIndex(oldTree?: Tree | null | undefined, options?: DiffOptions | null | undefined): Diff;
   * }
   * ```
   *
   * @param {Tree} [oldTree] - Tree used for the "oldFile" side of the delta. If you not pass,
   * then an empty tree is used.
   *
   * @param {DiffOptions} [options] - Describing options about how the diff should be executed.
   *
   * @returns {Diff} Diff between a tree and the working directory using index data to account for
   * staged deletes, tracked files, etc.
   */
  diffTreeToWorkdirWithIndex(oldTree?: Tree | undefined | null, options?: DiffOptions | undefined | null): Diff
  /**
   * Add ignore rules for a repository.
   *
   * This adds ignore rules to the repository. The rules will be used
   * in addition to any existing ignore rules (such as .gitignore files).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   addIgnoreRule(rules: string): void;
   * }
   * ```
   *
   * @param {string} rules - Rules to add, separated by newlines.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * repo.addIgnoreRule("node_modules/");
   * ```
   */
  addIgnoreRule(rules: string): void
  /**
   * Clear ignore rules that were explicitly added.
   *
   * Resets to the default internal ignore rules.
   * This will not turn off rules in .gitignore files that actually exist in the filesystem.
   * The default internal ignores ignore ".", ".." and ".git" entries.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   clearIgnoreRules(): void;
   * }
   * ```
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * repo.addIgnoreRule("*.log");
   * // Later, clear all added rules
   * repo.clearIgnoreRules();
   * ```
   */
  clearIgnoreRules(): void
  /**
   * Test if the ignore rules apply to a given path.
   *
   * This function checks the ignore rules to see if they would apply to the given file.
   * This indicates if the file would be ignored regardless of whether the file is already in the index or committed to the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isPathIgnored(path: string): boolean;
   * }
   * ```
   *
   * @param {string} path - The path to check.
   * @returns {boolean} - True if the path is ignored, false otherwise.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const isIgnored = repo.isPathIgnored("node_modules/some-package");
   * console.log(`Path is ${isIgnored ? "ignored" : "not ignored"}`);
   * ```
   */
  isPathIgnored(path: string): boolean
  /**
   * Get the Index file for this repository.
   *
   * If a custom index has not been set, the default index for the repository
   * will be returned (the one located in `.git/index`).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   index(): Index;
   * }
   * ```
   *
   * @returns The index file for this repository.
   */
  index(): Index
  /**
   * Gets this repository's mailmap.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   mailmap(): Mailmap | null;
   * }
   * ```
   *
   * @returns The mailmap object if it exists, null otherwise
   */
  mailmap(): Mailmap | null
  /**
   * Find a merge base between two commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeBase(one: string, two: string): string;
   * }
   * ```
   *
   * @param {string} one - One of the commits OID.
   * @param {string} two - The other commit OID.
   * @returns The OID of a merge base between 'one' and 'two'.
   */
  getMergeBase(one: string, two: string): string
  /**
   * Find a merge base given a list of commits
   *
   * This behaves similar to [`git merge-base`](https://git-scm.com/docs/git-merge-base#_discussion).
   * Given three commits `a`, `b`, and `c`, `getMergeBaseMany([a, b, c])`
   * will compute a hypothetical commit `m`, which is a merge between `b`
   * and `c`.
   *
   * For example, with the following topology:
   * ```text
   *        o---o---o---o---C
   *       /
   *      /   o---o---o---B
   *     /   /
   * ---2---1---o---o---o---A
   * ```
   *
   * the result of `getMergeBaseMany([a, b, c])` is 1. This is because the
   * equivalent topology with a merge commit `m` between `b` and `c` would
   * is:
   * ```text
   *        o---o---o---o---o
   *       /                 \
   *      /   o---o---o---o---M
   *     /   /
   * ---2---1---o---o---o---A
   * ```
   *
   * and the result of `getMergeBaseMany([a, m])` is 1.
   *
   * ---
   *
   * If you're looking to recieve the common merge base between all the
   * given commits, use `getMergeBaseOctopus`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBaseMany(oids: string[]): string;
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns The OID of a merge base considering all the commits.
   */
  getMergeBaseMany(oids: Array<string>): string
  /**
   * Find a merge base in preparation for an octopus merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBaseOctopus(oids: string[]): string;
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns The OID of a merge base considering all the commits.
   */
  getMergeBaseOctopus(oids: Array<string>): string
  /**
   * Find all merge bases between two commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBases(one: string, two: string): string[];
   * }
   * ```
   *
   * @param {string} one - One of the commits OID.
   * @param {string} two - The other commit OID.
   * @returns Array in which to store the resulting OIDs.
   */
  getMergeBases(one: string, two: string): Array<string>
  /**
   * Find all merge bases given a list of commits
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getMergeBasesMany(oids: string[]): string[];
   * }
   * ```
   *
   * @param {string[]} oids - Oids of the commits.
   * @returns Array in which to store the resulting OIDs.
   */
  getMergeBasesMany(oids: Array<string>): Array<string>
  /**
   * Merges the given commit(s) into HEAD, writing the results into the
   * working directory. Any changes are staged for commit and any conflicts
   * are written to the index. Callers should inspect the repository's index
   * after this completes, resolve any conflicts and prepare a commit.
   *
   * For compatibility with git, the repository is put into a merging state.
   * Once the commit is done (or if the user wishes to abort), you should
   * clear this state by calling `cleanupState()`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   merge(
   *     annotatedCommits: AnnotatedCommit[],
   *     mergeOptions?: MergeOptions | undefined | null,
   *     checkoutOptions?: CheckoutOptions | undefined | null,
   *   ): void;
   * }
   * ```
   *
   * @param {AnnotatedCommit[]} annotatedCommits - Commits to merge.
   * @param {MergeOptions} [mergeOptions] - Merge options.
   * @param {CheckoutOptions} [checkoutOptions] - Checkout options.
   */
  merge(annotatedCommits: Array<AnnotatedCommit>, mergeOptions?: MergeOptions | undefined | null, checkoutOptions?: CheckoutOptions | undefined | null): void
  /**
   * Merge two commits, producing an index that reflects the result of
   * the merge. The index may be written as-is to the working directory or
   * checked out. If the index is to be converted to a tree, the caller
   * should resolve any conflicts that arose as part of the merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeCommits(
   *     ourCommit: Commit,
   *     theirCommit: Commit,
   *     options?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Commit} ourCommit - The commit that reflects the destination tree.
   * @param {Commit} theirCommit - The commit to merge in to `ourCommit`.
   * @param {MergeOptions} [options] - Merge options.
   * @returns The index result.
   */
  mergeCommits(ourCommit: Commit, theirCommit: Commit, options?: MergeOptions | undefined | null): Index
  /**
   * Merge two trees, producing an index that reflects the result of
   * the merge. The index may be written as-is to the working directory or
   * checked out. If the index is to be converted to a tree, the caller
   * should resolve any conflicts that arose as part of the merge.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   mergeTrees(
   *     ancestorTree: Tree,
   *     ourTree: Tree,
   *     theirTree: Tree,
   *     options?: MergeOptions | undefined | null,
   *   ): Index;
   * }
   * ```
   *
   * @param {Tree} ancestorTree - The common ancestor between.
   * @param {Tree} ourTree - The tree that reflects the destination tree.
   * @param {Tree} theirTree - The tree to merge in to `ourTree`.
   * @param {MergeOptions} [options] - Merge options.
   * @returns The index result.
   */
  mergeTrees(ancestorTree: Tree, ourTree: Tree, theirTree: Tree, options?: MergeOptions | undefined | null): Index
  /**
   * Analyzes the given branch(es) and determines the opportunities for
   * merging them into the HEAD of the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   analyzeMergeFor(theirHeads: AnnotatedCommit[]): MergeAnalysisResult;
   * }
   * ```
   *
   * @param {AnnotatedCommit[]} theirHeads - The heads to merge into.
   * @returns Merge analysis result.
   */
  analyzeMerge(theirHeads: Array<AnnotatedCommit>): MergeAnalysisResult
  /**
   * Analyzes the given branch(es) and determines the opportunities for
   * merging them into a reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   analyzeMergeForRef(ourRef: Reference, theirHeads: AnnotatedCommit[]): MergeAnalysisResult;
   * }
   * ```
   *
   * @param {Reference} ourRef - The reference to perform the analysis from.
   * @param {AnnotatedCommit[]} theirHeads - The heads to merge into.
   * @returns Merge analysis result.
   */
  analyzeMergeForRef(ourRef: Reference, theirHeads: Array<AnnotatedCommit>): MergeAnalysisResult
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findObject(oid: string): GitObject | null;
   * }
   * ```
   *
   * @param {string} oid - Git object ID(SHA1) to lookup.
   * @returns Git object. Returns `null` if the object does not exist.
   */
  findObject(oid: string): GitObject | null
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getObject(oid: string): GitObject;
   * }
   * ```
   *
   * @param {string} oid - Git object ID(SHA1) to lookup.
   * @returns Git object.
   * @throws Throws error if the object does not exist.
   */
  getObject(oid: string): GitObject
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findReference(name: string): Reference | null;
   * }
   * ```
   *
   * @param {string} name - Reference name to lookup.
   * @returns Returns `null` if the reference does not exist.
   *
   * @example
   *
   * Get `HEAD` reference from the repository.
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const reference = repo.findReference('HEAD');
   * ```
   */
  findReference(name: string): Reference | null
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getReference(name: string): Reference;
   * }
   * ```
   *
   * @param {string} name - Reference name to lookup.
   * @returns Git reference.
   * @throws Throws error if the reference does not exist.
   *
   * @example
   *
   * Get `HEAD` reference from the repository.
   *
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const reference = repo.getReference('HEAD');
   * ```
   */
  getReference(name: string): Reference
  /**
   * List all remotes for a given repository
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   remoteNames(): string[];
   * }
   * ```
   *
   * @returns All remote names for this repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('/path/to/repo');
   * console.log(repo.remoteNames()); // ["origin"]
   * ```
   */
  remoteNames(): Array<string>
  /**
   * Get remote from repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getRemote(name: string): Remote;
   * }
   * ```
   *
   * @returns Remote instance.
   * @throws Throws error if remote does not exist.
   */
  getRemote(name: string): Remote
  /**
   * Find remote from repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findRemote(name: string): Remote | null;
   * }
   * ```
   *
   * @returns Returns `null` if remote does not exist.
   */
  findRemote(name: string): Remote | null
  /**
   * Add a remote with the default fetch refspec to the repository’s configuration.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createRemote(name: string, url: string, options?: CreateRemoteOptions | null | undefined): Remote;
   * }
   * ```
   *
   * @param {string} name - The name of the remote.
   * @param {string} url - Remote url.
   * @param {CreateRemoteOptions} [options] - Options for creating remote.
   * @returns Created remote.
   */
  createRemote(name: string, url: string, options?: CreateRemoteOptions | undefined | null): Remote
  /**
   * Tests whether this repository is a bare repository or not.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isBare(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a bare.
   */
  isBare(): boolean
  /**
   * Tests whether this repository is a shallow clone.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isShallow(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a shallow clone.
   */
  isShallow(): boolean
  /**
   * Tests whether this repository is a worktree.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isWorktree(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is a worktree.
   */
  isWorktree(): boolean
  /**
   * Tests whether this repository is empty.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if repository is empty.
   */
  isEmpty(): boolean
  /**
   * Returns the path to the `.git` folder for normal repositories or the
   * repository itself for bare repositories.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   path(): string;
   * }
   * ```
   *
   * @returns The path to the `.git` folder for normal repositories or the repository itself
   * for bare repositories.
   */
  path(): string
  /**
   * Returns the current state of this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   state(): RepositoryState;
   * }
   * ```
   *
   * @returns The current state of this repository.
   */
  state(): RepositoryState
  /**
   * Get the path of the working directory for this repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   workdir(): string | null;
   * }
   * ```
   *
   * @returns The path of the working directory for this repository.
   * If this repository is bare, then `null` is returned.
   * ```
   */
  workdir(): string | null
  /**
   * Retrieve and resolve the reference pointed at by `HEAD`.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   head(): Reference;
   * }
   * ```
   *
   * @returns Reference pointed at by `HEAD`.
   */
  head(): Reference
  /**
   * Make the repository `HEAD` point to the specified reference.
   *
   * If the provided reference points to a tree or a blob, the `HEAD` is
   * unaltered and an error is returned.
   *
   * If the provided reference points to a branch, the `HEAD` will point to
   * that branch, staying attached, or become attached if it isn't yet. If
   * the branch doesn't exist yet, no error will be returned. The `HEAD` will
   * then be attached to an unborn branch.
   *
   * Otherwise, the `HEAD` will be detached and will directly point to the
   * commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHead(refname: string): void;
   * }
   * ```
   *
   * @param {string} refname - Specified reference to point into `HEAD`.
   */
  setHead(refname: string): void
  /**
   * Determines whether the repository `HEAD` is detached.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   headDetached(): boolean;
   * }
   * ```
   *
   * @returns Returns `true` if the repository `HEAD` is detached.
   */
  headDetached(): boolean
  /**
   * Make the repository HEAD directly point to the commit.
   *
   * If the provided commitish cannot be found in the repository, the HEAD
   * is unaltered and an error is returned.
   *
   * If the provided commitish cannot be peeled into a commit, the HEAD is
   * unaltered and an error is returned.
   *
   * Otherwise, the HEAD will eventually be detached and will directly point
   * to the peeled commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHeadDetached(commitish: Commit): void;
   * }
   * ```
   *
   * @param {Commit} commit - A Commit which the HEAD should point to.
   */
  setHeadDetached(commit: Commit): void
  /**
   * Make the repository HEAD directly point to the commit.
   *
   * If the provided commitish cannot be found in the repository, the HEAD
   * is unaltered and an error is returned.
   * If the provided commitish cannot be peeled into a commit, the HEAD is
   * unaltered and an error is returned.
   * Otherwise, the HEAD will eventually be detached and will directly point
   * to the peeled commit.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   setHeadDetachedFromAnnotated(commitish: AnnotatedCommit): void;
   * }
   * ```
   *
   * @param {AnnotatedCommit} commitish - An Annotated Commit which the HEAD should point to.
   */
  setHeadDetachedFromAnnotated(commitish: AnnotatedCommit): void
  /**
   * Extract a signature from an object identified by its ID.
   *
   * This method can be used for any object that may be signed, such as commits or tags.
   *
   * @category Repository/Methods
   *
   * @signature
   * ```ts
   * class Repository {
   *   extractSignature(oid: string): ExtractedSignature | null;
   * }
   * ```
   *
   * @param {string} oid - Object ID (SHA1) of the signed object to extract the signature from.
   * @returns An ExtractedSignature object containing the signature and signed data if the object is signed,
   *          or null if the object is not signed.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const commit = repo.getCommit('a01e9888e46729ef4aa68953ba19b02a7a64eb82');
   *
   * // Extract the signature from a commit
   * const signatureInfo = repo.extractSignature(commit.id());
   *
   * if (signatureInfo) {
   *   console.log('Object is signed!');
   *   console.log('Signature:', signatureInfo.signature);
   *   console.log('Signed data:', signatureInfo.signedData);
   * } else {
   *   console.log('Object is not signed');
   * }
   * ```
   */
  extractSignature(oid: string): ExtractedSignature | null
  /**
   * Remove all the metadata associated with an ongoing command like merge,
   * revert, cherry-pick, etc. For example: `MERGE_HEAD`, `MERGE_MSG`, etc.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   cleanupState(): void;
   * }
   * ```
   */
  cleanupState(): void
  /**
   * Execute a rev-parse operation against the `spec` listed.
   *
   * The resulting revision specification is returned, or an error is
   * returned if one occurs.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revparse(spec: string): Revspec;
   * }
   * ```
   *
   * @param {string} spec - Revision string.
   * @returns
   */
  revparse(spec: string): Revspec
  /**
   * Find a single object, as specified by a revision string.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revparseSingle(spec: string): string;
   * }
   * ```
   *
   * @param {string} spec - Revision string.
   * @returns OID of single object.
   * @throws Throws error if the object does not exist.
   */
  revparseSingle(spec: string): string
  /**
   * Create a revwalk that can be used to traverse the commit graph.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   revwalk(): Revwalk;
   * }
   * ```
   *
   * @returns Revwalk to traverse the commit graph in this repository.
   */
  revwalk(): Revwalk
  /**
   * Save the local modifications to a new stash.
   *
   * This method saves your current working directory and index state to a new stash entry,
   * allowing you to temporarily store changes and work on something else. The working directory
   * is reverted to match the HEAD commit after stashing.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashSave(options?: StashSaveOptions): string;
   * }
   * ```
   *
   * @param {StashSaveOptions} [options] - Options for saving the stash.
   * @returns {string} The object ID (40-character SHA1) of the commit containing the stashed state.
   * @throws {Error} If there are no local changes to stash or if the stash operation fails.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Simple stash
   * const stashId = repo.stashSave({
   *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
   *   message: 'WIP: implementing new feature'
   * });
   *
   * // Stash including untracked files
   * repo.stashSave({
   *   stasher: { name: 'Seokju Na', email: 'seokju.me@toss.im' },
   *   includeUntracked: true
   * });
   * ```
   */
  stashSave(options?: StashSaveOptions | undefined | null): string
  /**
   * Apply a single stashed state from the stash list.
   *
   * This method applies the changes from a stash entry to your working directory.
   * Unlike `stashPop`, this does not remove the stash from the list after applying.
   * Conflicts may occur if the stashed changes conflict with the current working directory.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashApply(index: number, options?: StashApplyOptions): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to apply (0 is the most recent).
   * @param {StashApplyOptions} [options] - Options for applying the stash.
   * @throws {Error} If the stash index is invalid or if there are conflicts during application.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Apply the most recent stash
   * repo.stashApply(0);
   *
   * // Apply with options
   * repo.stashApply(0, { reinstantiateIndex: true });
   * ```
   */
  stashApply(index: number, options?: StashApplyOptions | undefined | null): void
  /**
   * Remove a single stashed state from the stash list.
   *
   * This permanently deletes a stash entry. The stash is removed from the list and
   * cannot be recovered. All subsequent stashes will be reindexed (e.g., stash@{2}
   * becomes stash@{1} after dropping stash@{1}).
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashDrop(index: number): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to drop (0 is the most recent).
   * @throws {Error} If the stash index is invalid.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Drop the most recent stash
   * repo.stashDrop(0);
   *
   * // Drop the third stash
   * repo.stashDrop(2);
   * ```
   */
  stashDrop(index: number): void
  /**
   * Apply a single stashed state from the stash list and remove it from the list if successful.
   *
   * This method combines `stashApply` and `stashDrop` into a single operation. It applies
   * the stash to your working directory and, if successful, removes it from the stash list.
   * If the application fails (e.g., due to conflicts), the stash remains in the list.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashPop(index: number, options?: StashApplyOptions): void;
   * }
   * ```
   *
   * @param {number} index - The index of the stash to pop (0 is the most recent).
   * @param {StashApplyOptions} [options] - Options for applying the stash.
   * @throws {Error} If the stash index is invalid or if there are conflicts during application.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   *
   * // Pop the most recent stash
   * repo.stashPop(0);
   *
   * // Pop with options
   * repo.stashPop(0, { reinstantiateIndex: true });
   * ```
   */
  stashPop(index: number, options?: StashApplyOptions | undefined | null): void
  /**
   * Get the list of stash states in the repository.
   *
   * Returns a StashList object that provides access to all stashes in the repository.
   * The list is ordered with the most recent stash at index 0.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   stashList(): StashList;
   * }
   * ```
   *
   * @returns {StashList} A container providing access to all stash entries in the repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * if (!stashList.isEmpty()) {
   *   console.log(`Found ${stashList.len()} stashes`);
   *   for (const stash of stashList.iter()) {
   *     console.log(`${stash.index()}: ${stash.message()}`);
   *   }
   * }
   * ```
   */
  stashList(): StashList
  /**
   * Test if the ignore rules apply to a given file.
   *
   * This function checks the ignore rules to see if they would apply to the
   * given file. This indicates if the file would be ignored regardless of
   * whether the file is already in the index or committed to the repository.
   *
   * One way to think of this is if you were to do "git add ." on the
   * directory containing the file, would it be added or not?
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   statusShouldIgnore(path: string): boolean;
   * }
   * ```
   *
   * @param {string} path - A given file path.
   * @returns Returns `true` if the ignore rules apply to a given file.
   */
  statusShouldIgnore(path: string): boolean
  /**
   * Get file status for a single file.
   *
   * This tries to get status for the filename that you give. If no files
   * match that name (in either the HEAD, index, or working directory), this
   * returns NotFound.
   *
   * If the name matches multiple files (for example, if the path names a
   * directory or if running on a case- insensitive filesystem and yet the
   * HEAD has two entries that both match the path), then this returns
   * Ambiguous because it cannot give correct results.
   *
   * This does not do any sort of rename detection. Renames require a set of
   * targets and because of the path filtering, there is not enough
   * information to check renames correctly. To check file status with rename
   * detection, there is no choice but to do a full `statuses` and scan
   * through looking for the path that you are interested in.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getStatusFile(path: string): Status;
   * }
   * ```
   *
   * @param {string} path - A single file path.
   * @returns The `Status` of this single file.
   * @throws Throws error if the status file does not exist.
   */
  getStatusFile(path: string): Status
  /**
   * Get file status for a single file.
   *
   * This tries to get status for the filename that you give. If no files
   * match that name (in either the HEAD, index, or working directory), this
   * returns NotFound.
   *
   * If the name matches multiple files (for example, if the path names a
   * directory or if running on a case- insensitive filesystem and yet the
   * HEAD has two entries that both match the path), then this returns
   * Ambiguous because it cannot give correct results.
   *
   * This does not do any sort of rename detection. Renames require a set of
   * targets and because of the path filtering, there is not enough
   * information to check renames correctly. To check file status with rename
   * detection, there is no choice but to do a full `statuses` and scan
   * through looking for the path that you are interested in.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findStatusFile(path: string): Status | null;
   * }
   * ```
   *
   * @param {string} path - A single file path.
   * @returns The `Status` of this single file. If the status file does not exists, returns `null`.
   */
  findStatusFile(path: string): Status | null
  /**
   * Gather file status information and populate the returned structure.
   *
   * Note that if a pathspec is given in the options to filter the
   * status, then the results from rename detection (if you enable it) may
   * not be accurate. To do rename detection properly, this must be called
   * with no pathspec so that all files can be considered.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   statuses(): Statuses;
   * }
   * ```
   *
   * @returns A container for a list of status information about a repository.
   */
  statuses(): Statuses
  /**
   * Lookup a tag object by prefix hash from the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findTag(oid: string): Tag | null;
   * }
   * ```
   *
   * @param {string} oid - Prefix hash.
   * @returns Returns `null` if tag does not exist.
   */
  findTag(oid: string): Tag | null
  /**
   * Lookup a tag object by prefix hash from the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getTag(oid: string): Tag;
   * }
   * ```
   *
   * @param {string} oid - Prefix hash.
   * @throws Throws error if tag does not exist.
   */
  getTag(oid: string): Tag
  /**
   * Get a list with all the tags in the repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   tagNames(pattern?: string | null | undefined): string[];
   * }
   * ```
   *
   * @param {string} [pattern] - An optional fnmatch pattern can also be specified.
   */
  tagNames(pattern?: string | undefined | null): Array<string>
  /**
   * Iterate over all tags calling `callback` on each.
   * The callback is provided the tag id and name.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   tagForeach(callback: (oid: string, name: string) => boolean): void;
   * }
   * ```
   *
   * @param {(oid: string, name: string) => boolean} callback - If you wish to stop iteration,
   * return `false` in the callback.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const tags = [];
   * repo.tagForeach((sha, name) => {
   *   tags.push([name, sha]);
   *   return true;
   * });
   *
   * console.log(tags);
   * // [['aa0040546ed22b8bb33f3bd621e8d10ed849b02c', 'refs/tags/v0'],
   * //  ['674e3327707fcf32a348ecfc0cb6b93e57398b8c', 'refs/tags/v1'],
   * //  ['567aa5c6b219312dc7758ab88ebb7a1e5d36d26b', 'refs/tags/v2']]
   * ```
   */
  tagForeach(callback: (oid: string, name: string) => boolean): void
  /**
   * Delete an existing tag reference.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   deleteTag(name: string): void;
   * }
   * ```
   *
   * @param {string} name - The tag name will be checked for validity, see `isValidTagName`
   * for some rules about valid names.
   */
  deleteTag(name: string): void
  /**
   * Create a new tag in the repository from an object.
   *
   * A new reference will also be created pointing to this tag object.
   *
   * The message will not be cleaned up.
   *
   * The tag name will be checked for validity. You must avoid the characters
   * '~', '^', ':', ' \ ', '?', '[', and '*', and the sequences ".." and " @
   * {" which have special meaning to revparse.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createTag(
   *     name: string,
   *     target: GitObject,
   *     message: string,
   *     options?: CreateTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {string} message - The message of tag.
   * @param {CreateTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const commit = repo.getCommit('828954df9f08dc8e172447cdacf0ddea1adf9e63');
   *
   * const sha = repo.createTag(
   *   'mytag',
   *   commit.asObject(),
   *   'this is my tag message',
   *   {
   *     tagger: {
   *       name: 'Seokju Na',
   *       email: 'seokju.me@toss.im',
   *     },
   *   },
   * );
   * const tag = repo.getTag(sha);
   * console.log(tag.name()); // "mytag"
   * console.log(tag.target().id()); // "828954df9f08dc8e172447cdacf0ddea1adf9e63"
   * ```
   */
  createTag(name: string, target: GitObject, message: string, options?: CreateTagOptions | undefined | null): string
  /**
   * Create a new tag in the repository from an object without creating a reference.
   *
   * The message will not be cleaned up.
   *
   * The tag name will be checked for validity. You must avoid the characters
   * '~', '^', ':', ' \ ', '?', '[', and '*', and the sequences ".." and " @
   * {" which have special meaning to revparse.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createAnnotationTag(
   *     name: string,
   *     target: GitObject,
   *     message: string,
   *     options?: CreateAnnotationTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {string} message - The message of tag.
   * @param {CreateAnnotationTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   */
  createAnnotationTag(name: string, target: GitObject, message: string, options?: CreateAnnotationTagOptions | undefined | null): string
  /**
   * Create a new lightweight tag pointing at a target object.
   *
   * A new direct reference will be created pointing to this target object.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   createLightweightTag(
   *     name: string,
   *     target: GitObject,
   *     options?: CreateLightweightTagOptions | null | undefined,
   *   ): string;
   * }
   * ```
   *
   * @param {string} name - The name of tag.
   * @param {GitObject} target - Git object to pointed by this tag.
   * @param {CreateLightweightTagOptions} [options] - Options for creating the tag.
   *
   * @returns Tag OID(SHA1) which created.
   */
  createLightweightTag(name: string, target: GitObject, options?: CreateLightweightTagOptions | undefined | null): string
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   getTree(oid: string): Tree;
   * }
   * ```
   *
   * @param {string} oid - ID(SHA1) to lookup.
   * @returns Git tree.
   * @throws Throws error if tree does not exist.
   */
  getTree(oid: string): Tree
  /**
   * Lookup a reference to one of the objects in a repository.
   *
   * @category Repository/Methods
   * @signature
   * ```ts
   * class Repository {
   *   findTree(oid: string): Tree | null;
   * }
   * ```
   *
   * @param {string} oid - ID(SHA1) to lookup.
   * @returns If it does not exist, returns `null`.
   */
  findTree(oid: string): Tree | null
}
/**
 * A revwalk allows traversal of the commit graph defined by including one or
 * more leaves and excluding one or more roots.
 */
export declare class Revwalk {
  [Symbol.iterator](): Iterator<string, void, void>
  /**
   * Reset a revwalk to allow re-configuring it.
   *
   * The revwalk is automatically reset when iteration of its commits
   * completes.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   reset(): this;
   * }
   * ```
   */
  reset(): this
  /**
   * Set the order in which commits are visited.
   *
   * @category Revwalk/Methods
   *
   * @signature
   * ```ts
   * class Revwalk {
   *   setSorting(sort: number): this;
   * }
   * ```
   *
   * @param {number} sort - Orderings that may be specified for Revwalk iteration.
   * - `RevwalkSort.None` : Sort the repository contents in no particular ordering.
   * This sorting is arbitrary, implementation-specific, and subject to
   * change at any time. This is the default sorting for new walkers.
   * - `RevwalkSort.Topological` : Sort the repository contents in topological order
   * (children before parents).
   * This sorting mode can be combined with time sorting.
   * - `RevwalkSort.Time` : Sort the repository contents by commit time.
   * This sorting mode can be combined with topological sorting.
   * - `RevwalkSort.Reverse` : Iterate through the repository contents in reverse order.
   * This sorting mode can be combined with any others.
   *
   * @example
   * ```ts
   * import { openRepository, RevwalkSort } from 'es-git';
   *
   * const repo = await openRepository('.');
   * const revwalk = repo.revwalk();
   * revwalk.setSorting(RevwalkSort.Time | RevwalkSort.Reverse);
   * ```
   */
  setSorting(sort: number): this
  /**
   * Simplify the history by first-parent.
   *
   * No parents other than the first for each commit will be enqueued.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   simplifyFirstParent(): this;
   * }
   * ```
   */
  simplifyFirstParent(): this
  /**
   * Mark a commit to start traversal from.
   *
   * The given OID must belong to a commitish on the walked repository.
   *
   * The given commit will be used as one of the roots when starting the
   * revision walk. At least one commit must be pushed onto the walker before
   * a walk can be started.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   push(oid: string): this;
   * }
   * ```
   *
   * @param {string} oid - OID which belong to a commitish on the walked repository.
   */
  push(oid: string): this
  /**
   * Push the repository's HEAD.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushHead(): this;
   * }
   * ```
   */
  pushHead(): this
  /**
   * Push matching references.
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * will be pushed to the revision walker.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushGlob(glob: string): this;
   * }
   * ```
   *
   * @param {string} glob - A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  pushGlob(glob: string): this
  /**
   * Push and hide the respective endpoints of the given range.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushRange(range: string): this;
   * }
   * ```
   *
   * @param {string} range - The range should be of the form `<commit>..<commit>` where each
   * `<commit>` is in the form accepted by `revparseSingle`. The left-hand
   * commit will be hidden and the right-hand commit pushed.
   */
  pushRange(range: string): this
  /**
   * Push the OID pointed to by a reference.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   pushRef(reference: string): this;
   * }
   * ```
   *
   * @param {string} reference - The reference must point to a commitish.
   */
  pushRef(reference: string): this
  /**
   * Mark a commit as not of interest to this revwalk.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hide(oid: string): this;
   * }
   * ```
   *
   * @param {string} oid - Marked commit OID as not of interest of this revwalk.
   */
  hide(oid: string): this
  /**
   * Hide the repository's HEAD.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideHead(): this;
   * }
   * ```
   */
  hideHead(): this
  /**
   * Hide matching references.
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * and their ancestors will be hidden from the output on the revision walk.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideGlob(glob: string): this;
   * }
   * ```
   *
   * @param {string} glob - A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  hideGlob(glob: string): this
  /**
   * Hide the OID pointed to by a reference.
   *
   * @category Revwalk/Methods
   * @signature
   * ```ts
   * class Revwalk {
   *   hideRef(reference: string): this;
   * }
   * ```
   *
   * @param {string} reference - The reference must point to a commitish.
   */
  hideRef(reference: string): this
}
/**
 * A class to represent a git stash entry.
 *
 * A stash entry represents a snapshot of the working directory and index that has been saved
 * temporarily. Each stash entry has an index (position in the stash stack), an ID (commit SHA),
 * and an optional message describing the changes.
 */
export declare class StashEntry {
  /**
   * Get the index of this stash entry.
   *
   * The index represents the position of this stash in the stash stack, where 0 is the most recent stash.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   index(): number;
   * }
   * ```
   *
   * @returns {number} Index of this stash entry (0-based, with 0 being the most recent).
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.index()); // 0
   * ```
   */
  index(): number
  /**
   * Get the id (SHA1) of this stash entry.
   *
   * Each stash is stored as a commit object, and this returns the commit SHA.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   id(): string;
   * }
   * ```
   *
   * @returns {string} The 40-character hexadecimal SHA1 hash of the stash commit.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.id()); // e.g., "a1b2c3d4e5f6..."
   * ```
   */
  id(): string
  /**
   * Get the message of this stash entry.
   *
   * Returns the message associated with the stash when it was created. If no custom message
   * was provided, it returns the default message generated by Git.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashEntry {
   *   message(): string | null;
   * }
   * ```
   *
   * @returns {string | null} The stash message, or null if not available.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   * const stash = stashList.get(0);
   * console.log(stash?.message()); // e.g., "WIP on main: abc1234 fix: typo"
   * ```
   */
  message(): string | null
}
/**
 * A container for a list of stash entries about a repository.
 *
 * The stash list provides access to all stashes in the repository. Stashes are indexed
 * from 0 (most recent) to n-1 (oldest). This class provides methods to access individual
 * stashes, check the count, and iterate over all stashes.
 *
 * @example
 * ```ts
 * import { openRepository } from 'es-git';
 *
 * const repo = await openRepository('./path/to/repo');
 * const stashList = repo.stashList();
 * console.log(`Total stashes: ${stashList.len()}`);
 *
 * // Iterate over all stashes
 * for (const stash of stashList.iter()) {
 *   console.log(`${stash.index()}: ${stash.message()}`);
 * }
 * ```
 */
export declare class StashList {
  /**
   * Gets a stash entry from this list at the specified index.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   get(index: number): StashEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of the stash entry to get (0-based, where 0 is the most recent).
   * @returns {StashEntry | null} A stash entry from this list at the specified index, or `null` if the index is out of bounds.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * // Get the most recent stash
   * const stash = stashList.get(0);
   * if (stash) {
   *   console.log(stash.message());
   * }
   * ```
   */
  get(index: number): StashEntry | null
  /**
   * Gets the count of stash entries in this list.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   len(): number;
   * }
   * ```
   *
   * @returns If there are no stashes in the repository, this should return 0.
   */
  len(): number
  /**
   * Check if the stash list is empty.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns {boolean} Returns `true` if there are no stash entries in this repository.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * if (stashList.isEmpty()) {
   *   console.log('No stashes found');
   * } else {
   *   console.log(`Found ${stashList.len()} stashes`);
   * }
   * ```
   */
  isEmpty(): boolean
  /**
   * Returns an iterator over the stash entries in this list.
   *
   * The iterator yields stash entries in order from newest (index 0) to oldest.
   *
   * @category Stash/Methods
   * @signature
   * ```ts
   * class StashList {
   *   iter(): StashListIter;
   * }
   * ```
   *
   * @returns {StashListIter} An iterator that yields StashEntry objects.
   *
   * @example
   * ```ts
   * import { openRepository } from 'es-git';
   *
   * const repo = await openRepository('./path/to/repo');
   * const stashList = repo.stashList();
   *
   * // Iterate over stashes
   * for (const stash of stashList.iter()) {
   *   console.log(`${stash.index()}: ${stash.message()}`);
   * }
   * ```
   */
  iter(): StashListIter
}
export declare class StashListIter {
  [Symbol.iterator](): Iterator<StashEntry, void, void>
}
/**
 * A container for a list of status information about a repository.
 *
 * Each instance appears as if it were a collection, having a length and
 * allowing indexing, as well as providing an iterator.
 */
export declare class Statuses {
  /**
   * Gets a status entry from this list at the specified index.
   *
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   get(index: number): StatusEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of the status entry to get.
   * @returns A status entry from this list at the specified index. Returns `null` if the status
   * entry does not exist.
   */
  get(index: number): StatusEntry | null
  /**
   * Gets the count of status entries in this list.
   *
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   len(): number;
   * }
   * ```
   *
   * @returns If there are no changes in status (according to the options given
   * when the status list was created), this should return 0.
   */
  len(): bigint
  /**
   * @category Status/Statuses
   * @signature
   * ```ts
   * class Statuses {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` if there is no status entry in this list.
   */
  isEmpty(): boolean
  /** Returns an iterator over the statuses in this list. */
  iter(): StatusesIter
}
export declare class StatusesIter {
  [Symbol.iterator](): Iterator<StatusEntry, void, void>
}
/** A structure representing an entry in the `Statuses` structure. */
export declare class StatusEntry {
  /**
   * Access this entry's path name as a string.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   path(): string;
   * }
   * ```
   *
   * @returns The path of this entry.
   */
  path(): string
  /**
   * Access the status for this file.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   status(): Status;
   * }
   * ```
   *
   * @returns Status data for this entry.
   */
  status(): Status
  /**
   * Access detailed information about the differences between the file in
   * `HEAD` and the file in the index.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   headToIndex(): DiffDelta | null;
   * }
   * ```
   *
   * @returns The differences between the file in `HEAD` and the file in the index.
   */
  headToIndex(): DiffDelta | null
  /**
   * Access detailed information about the differences between the file in
   * the index and the file in the working directory.
   *
   * @category Status/StatusEntry
   * @signature
   * ```ts
   * class StatusEntry {
   *   indexToWorkdir(): DiffDelta | null;
   * }
   * ```
   *
   * @returns Differences between the file in the index and the file in the working directory.
   */
  indexToWorkdir(): DiffDelta | null
}
/**
 * A class to represent a git [tag][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Basics-Tagging
 */
export declare class Tag {
  /**
   * Get the id (SHA1) of a repository tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of this tag.
   */
  id(): string
  /**
   * Get the message of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   message(): string | null;
   * }
   * ```
   *
   * @returns Returns `null` if there is no message or if it is not valid utf8.
   */
  message(): string | null
  /**
   * Get the name of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   name(): string;
   * }
   * ```
   *
   * @returns Name of tag.
   * @throws Throws error if it is not valid utf8.
   */
  name(): string
  /**
   * Recursively peel a tag until a non tag Git object is found.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   peel(): GitObject;
   * }
   * ```
   *
   * @returns Git object for this tag.
   */
  peel(): GitObject
  /**
   * Get the tagger (author) of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   tagger(): Signature | null;
   * }
   * ```
   *
   * @returns If the author is unspecified, then `null` is returned.
   */
  tagger(): Signature | null
  /**
   * Get the tagged object of a tag.
   *
   * This method performs a repository lookup for the given object and
   * returns it.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   target(): GitObject;
   * }
   * ```
   *
   * @returns Tagged git object of a tag.
   */
  target(): GitObject
  /**
   * Get the OID of the tagged object of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   targetId(): string;
   * }
   * ```
   *
   * @returns OID of the tagged object of a tag.
   */
  targetId(): string
  /**
   * Get the ObjectType of the tagged object of a tag.
   *
   * @category Tag/Methods
   * @signature
   * ```ts
   * class Tag {
   *   targetType(): ObjectType | null;
   * }
   * ```
   *
   * @returns ObjectType of the tagged object of a tag.
   */
  targetType(): ObjectType | null
}
/**
 * A class to represent a git [tree][1].
 *
 * [1]: https://git-scm.com/book/en/Git-Internals-Git-Objects
 */
export declare class Tree {
  /**
   * Get the id (SHA1) of a repository object.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID(SHA1) of a repository object.
   */
  id(): string
  /**
   * Get the number of entries listed in this tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   len(): bigint;
   * }
   * ```
   *
   * @returns The number of entries listed in this tree.
   */
  len(): bigint
  /**
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   isEmpty(): boolean;
   * }
   * ```
   *
   * @returns Return `true` if there is no entry.
   */
  isEmpty(): boolean
  /**
   * Returns an iterator over the entries in this tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   iter(): TreeIter;
   * }
   * ```
   *
   * @returns An iterator over the entries in this tree.
   */
  iter(): TreeIter
  /**
   * Traverse the entries in a tree and its subtrees in post or pre-order.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   walk(mode: TreeWalkMode, callback: (entry: TreeEntry) => number): void;
   * }
   * ```
   *
   * @param {TreeWalkMode} mode - A indicator of whether a tree walk should be performed
   * in pre-order or post-order.
   *
   * @param {(entry: TreeEntry) => number} callback - The callback function will be run on
   * each node of the tree that's walked. The return code of this function will determine
   * how the walk continues.
   * `libgit2` requires that the callback be an integer, where 0 indicates a successful visit,
   * 1 skips the node, and -1 aborts the traversal completely.
   */
  walk(mode: TreeWalkMode, callback: (entry: TreeEntry) => number): void
  /**
   * Lookup a tree entry by SHA value.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getId(id: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} id - SHA value.
   *
   * @returns Tree entry with the given ID(SHA1).
   */
  getId(id: string): TreeEntry | null
  /**
   * Lookup a tree entry by its position in the tree.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   get(index: number): TreeEntry | null;
   * }
   * ```
   *
   * @param {number} index - Index of tree entry.
   *
   * @returns Tree entry.
   */
  get(index: number): TreeEntry | null
  /**
   * Lookup a tree entry by its filename.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getName(filename: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} filename - Filename of tree entry.
   *
   * @returns Tree entry.
   */
  getName(filename: string): TreeEntry | null
  /**
   * Retrieve a tree entry contained in a tree or in any of its subtrees,
   * given its relative path.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   getPath(path: string): TreeEntry | null;
   * }
   * ```
   *
   * @param {string} path - Relative path to tree entry.
   *
   * @returns Tree entry.
   */
  getPath(path: string): TreeEntry | null
  /**
   * Casts this Tree to be usable as an `GitObject`.
   *
   * @category Tree/Methods
   * @signature
   * ```ts
   * class Tree {
   *   asObject(): GitObject;
   * }
   * ```
   *
   * @returns Git object.
   */
  asObject(): GitObject
}
/** An iterator over the entries in a tree. */
export declare class TreeIter {
  [Symbol.iterator](): Iterator<TreeEntry, void, void>
}
/**
 * A class representing an entry inside of a tree. An entry is borrowed
 * from a tree.
 */
export declare class TreeEntry {
  /**
   * Get the id of the object pointed by the entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   id(): string;
   * }
   * ```
   *
   * @returns ID of the object pointed by the entry.
   */
  id(): string
  /**
   * Get the filename of a tree entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   name(): string;
   * }
   * ```
   *
   * @returns The filename of a tree entry.
   * @throws Throws error if the name is not valid utf-8.
   */
  name(): string
  /**
   * Get the type of the object pointed by the entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   type(): ObjectType | null;
   * }
   * ```
   *
   * @returns The type of the object pointed by the entry.
   */
  type(): ObjectType | null
  /**
   * Get the UNIX file attributes of a tree entry.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   filemode(): number;
   * }
   * ```
   *
   * @returns UNIX file attributes of a tree entry.
   */
  filemode(): number
  /**
   * Convert a tree entry to the object it points to.
   *
   * @category Tree/TreeEntry
   * @signature
   * ```ts
   * class TreeEntry {
   *   toObject(repo: Repository): GitObject;
   * }
   * ```
   *
   * @param {Repository} repo - Repository which this tree entry belongs to.
   * @returns Git object that pointed by the entry.
   */
  toObject(repo: Repository): GitObject
}
